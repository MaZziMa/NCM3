# ==================================================
# Path: E:\NCM3
# Detected tech: csharp, docker, javascript
# ==================================================

## DIRECTORY STRUCTURE
```
NCM3/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ .vs/
‚îú‚îÄ‚îÄ Backups/
‚îÇ   ‚îî‚îÄ‚îÄ NCM3_Backup_20250523_130036.bak
‚îú‚îÄ‚îÄ ComplianceRules/
‚îú‚îÄ‚îÄ ConfigBackups/
‚îú‚îÄ‚îÄ Logs/
‚îú‚îÄ‚îÄ NCM3/
‚îÇ   ‚îú‚îÄ‚îÄ Constants/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AppConstants.cs
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigManagementController.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HomeController.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RestoreController.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RoutersController.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SNMPTestController.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsController.cs
‚îÇ   ‚îú‚îÄ‚îÄ Extensions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppSettingsExtensions.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoggingExtensions.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ServiceCollectionExtensions.cs
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GlobalExceptionHandlerMiddleware.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GlobalExceptionHandlerMiddlewareExtensions.cs
‚îÇ   ‚îú‚îÄ‚îÄ Migrations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250516021914_InitialCreate.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250516021914_InitialCreate.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250516140127_AddEnablePasswordColumn.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250516142445_AddEnablePassword.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250516142445_AddEnablePassword.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250520030802_AddRouterConfigurationsNavigation.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250520030802_AddRouterConfigurationsNavigation.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250520085538_AddIsAvailableToRouter.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250520085538_AddIsAvailableToRouter.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250523025411_AddRouterGroup.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250523025411_AddRouterGroup.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250524062658_AddBackupTypeAndCommentToRouterConfiguration.Designer.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 20250524062658_AddBackupTypeAndCommentToRouterConfiguration.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NCMDbContextModelSnapshot.cs
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NotificationHistoryViewModel.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppSettings.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChangeDetectionSettings.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ComplianceResult.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ComplianceRule.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigTemplate.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorViewModel.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NCMDbContext.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Router.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RouterConfiguration.cs
‚îÇ   ‚îú‚îÄ‚îÄ Properties/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ launchSettings.json
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChangeDetection/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChangeDetectionOrchestrator.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChangeDetectionStrategy.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IChangeDetectionStrategy.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SNMPPollingStrategy.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SNMPPollingStrategy.cs.bak
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SNMPVerificationService.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SSHPollingStrategy.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationChangedEvent.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EventBus.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IEventBus.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InMemoryEventBus.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AmazonS3Service.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AutomaticConfigurationChangeDetector.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackupNotificationHandler.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BackupService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChangeDetectionOrchestrator.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationManagementService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EncryptionService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NotificationHelper.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NotificationLogger.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RouterConnectionService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RouterService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ S3BackupService.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TelegramNotificationService.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WebhookNotificationService.cs
‚îÇ   ‚îú‚îÄ‚îÄ Validators/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ModelValidators.cs
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigManagement/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Compare.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompareSelection.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompareWithTemplate.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompareWithTemplateSelection.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ComplianceRules.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateRule.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateTemplate.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Search.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SearchResults.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Templates.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UnifiedCompareWithTemplate.cshtml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Home/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Index.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Privacy.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Restore.cshtml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Routers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationHistory.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Create.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DebugSsh.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Delete.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Details.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Edit.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Index.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ViewConfiguration.cshtml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Settings/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Index.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NotificationHistory.cshtml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Shared/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Error.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _Layout.cshtml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _Layout.cshtml.css
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ _ValidationScriptsPartial.cshtml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _ViewImports.cshtml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ _ViewStart.cshtml
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îú‚îÄ‚îÄ logs/
‚îÇ   ‚îú‚îÄ‚îÄ obj/
‚îÇ   ‚îú‚îÄ‚îÄ wwwroot/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ site.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ site.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ favicon.ico
‚îÇ   ‚îú‚îÄ‚îÄ NCM3.csproj
‚îÇ   ‚îú‚îÄ‚îÄ NCM3.csproj.user
‚îÇ   ‚îú‚îÄ‚îÄ Program.cs
‚îÇ   ‚îú‚îÄ‚îÄ SNMPTimeTester.cs
‚îÇ   ‚îú‚îÄ‚îÄ appsettings.Development.json
‚îÇ   ‚îú‚îÄ‚îÄ appsettings.json
‚îÇ   ‚îú‚îÄ‚îÄ ncm.db
‚îÇ   ‚îî‚îÄ‚îÄ run-project.bat
‚îú‚îÄ‚îÄ Templates/
‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îú‚îÄ‚îÄ TestResults/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deploy_sang5 20250523T110633_30656/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ In/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DESKTOP-4CMFFTN/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Out/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deploy_sang5 20250523T111122_22204/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ In/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DESKTOP-4CMFFTN/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Out/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deploy_sang5 20250523T111318_21324/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ In/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DESKTOP-4CMFFTN/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Out/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deploy_sang5 20250523T111403_13224/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ In/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DESKTOP-4CMFFTN/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Out/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Deploy_sang5 20250523T111518_21848/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ In/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ DESKTOP-4CMFFTN/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Out/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îú‚îÄ‚îÄ obj/
‚îÇ   ‚îú‚îÄ‚îÄ MSTestSettings.cs
‚îÇ   ‚îú‚îÄ‚îÄ NCM3.Tests.csproj
‚îÇ   ‚îú‚îÄ‚îÄ SNMPPollingStrategyTests.cs
‚îÇ   ‚îú‚îÄ‚îÄ TelegramNotificationServiceTests.cs
‚îÇ   ‚îî‚îÄ‚îÄ Test1.cs
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ NCM3.sln
‚îú‚îÄ‚îÄ backup-database.bat
‚îú‚îÄ‚îÄ backup-scheduler.ps1
‚îú‚îÄ‚îÄ cleanup-backups.ps1
‚îî‚îÄ‚îÄ docker-compose.yml
```

## FILE CONTENTS

### NCM3\Program.cs
```cs
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Middleware;
using NCM3.Extensions;
using Microsoft.Extensions.Logging;
using Serilog.Extensions.Logging;
using FluentValidation;
using NCM3.Validators;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Amazon.S3;
using Amazon.Extensions.NETCore.Setup;
using Amazon.Runtime;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllersWithViews();

// Configure CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("DefaultPolicy", policy =>
    {
        policy.WithOrigins("https://localhost:5001", "https://localhost:5000") 
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

// Add health checks
builder.Services.AddHealthChecks();

// Add DB context - using SQL Server
builder.Services.AddDbContext<NCMDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// Add services
builder.Services.AddScoped<RouterService>();
builder.Services.AddScoped<RouterConnectionService>();
builder.Services.AddScoped<ConfigurationManagementService>();
builder.Services.AddHttpClient();
builder.Services.AddScoped<ITelegramNotificationService, TelegramNotificationService>();
builder.Services.AddScoped<IWebhookNotificationService, WebhookNotificationService>();
builder.Services.AddSingleton<IEncryptionService, EncryptionService>();
builder.Services.AddScoped<NotificationHelper>();
builder.Services.AddScoped<NotificationLogger>();

// Add AWS S3 services
var awsOptions = builder.Configuration.GetAWSOptions();
// Ensure credentials are explicitly configured from appsettings.json
var accessKey = builder.Configuration["AWS:AccessKeyId"];
var secretKey = builder.Configuration["AWS:SecretAccessKey"];
if (!string.IsNullOrEmpty(accessKey) && !string.IsNullOrEmpty(secretKey))
{
    // Always set credentials explicitly to ensure they're used
    awsOptions.Credentials = new BasicAWSCredentials(accessKey, secretKey);
    Console.WriteLine($"AWS Credentials configured explicitly from appsettings.json");
}
else
{
    Console.WriteLine("Warning: AWS credentials not found in appsettings.json");
}

// ƒê·∫£m b·∫£o Region ƒë∆∞·ª£c thi·∫øt l·∫≠p
if (awsOptions.Region == null && !string.IsNullOrEmpty(builder.Configuration["AWS:Region"]))
{
    awsOptions.Region = Amazon.RegionEndpoint.GetBySystemName(builder.Configuration["AWS:Region"]);
    Console.WriteLine($"AWS Region set to: {awsOptions.Region?.SystemName}");
}

builder.Services.AddDefaultAWSOptions(awsOptions);
builder.Services.AddAWSService<IAmazonS3>();
builder.Services.AddScoped<IS3BackupService, S3BackupService>();

// Add change detection services
builder.Services.AddChangeDetectionServices();

// Th√™m d·ªãch v·ª• t·ª± ƒë·ªông ph√°t hi·ªán thay ƒë·ªïi c·∫•u h√¨nh
builder.Services.AddHostedService<AutomaticConfigurationChangeDetector>();

// Th√™m d·ªãch v·ª• x·ª≠ l√Ω th√¥ng b√°o
builder.Services.AddNotificationServices();

// Th√™m File Logger
builder.Services.AddFileLogger(builder.Configuration);

// C·∫•u h√¨nh th∆∞ m·ª•c sao l∆∞u
builder.Services.ConfigureBackupFolders(builder.Configuration);

// ƒêƒÉng k√Ω FluentValidation
builder.Services.AddValidatorsFromAssemblyContaining<RouterValidator>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
else
{
    // Trong m√¥i tr∆∞·ªùng ph√°t tri·ªÉn, s·ª≠ d·ª•ng middleware x·ª≠ l√Ω ngo·∫°i l·ªá to√†n c·ª•c
    app.UseGlobalExceptionHandler();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

// Th√™m CORS
app.UseCors("DefaultPolicy");

// Th√™m Security Headers
app.Use(async (context, next) =>
{
    // C√°c security headers c∆° b·∫£n
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Append("X-Frame-Options", "SAMEORIGIN");
    context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Append("Referrer-Policy", "strict-origin-when-cross-origin");
    
    // Content-Security-Policy ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ cho ph√©p c√°c ngu·ªìn t√†i nguy√™n c·∫ßn thi·∫øt
    context.Response.Headers.Append("Content-Security-Policy", 
        "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
        "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; " + 
        "font-src 'self' https://cdn.jsdelivr.net; " + 
        "img-src 'self' data: https:; " +
        "connect-src 'self';"
    );
    
    await next();
});

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

// Map health check endpoint
app.MapHealthChecks("/health");

app.Run();

```

### NCM3\SNMPTimeTester.cs
```cs

```

### NCM3\Constants\AppConstants.cs
```cs
namespace NCM3.Constants
{
    public static class RouterStatus
    {
        public const string Unknown = "Unknown";
        public const string Connected = "Connected";
        public const string Disconnected = "Disconnected";
        public const string Error = "Error";
        public const string ConfigBackupSuccessful = "ConfigBackupSuccessful";
        public const string ConfigBackupFailed = "ConfigBackupFailed";
    }
    
    public static class BackupTypes
    {
        public const string Manual = "Manual";
        public const string Scheduled = "Scheduled";
        public const string PreChange = "PreChange";
        public const string PostChange = "PostChange";
        public const string Automatic = "Automatic"; // Added
    }
    
    public static class DefaultSettings
    {
        public const int SSHPort = 22;
        public const int SSHTimeout = 45; // seconds
        public const int SSHRetryAttempts = 2;
        public const int SSHKeepAliveInterval = 60; // seconds
    }
    
    public static class SSHCommands
    {
        public const string TerminalLength = "terminal length 0";
        public const string ShowRunningConfig = "show running-config";
        public const string Enable = "enable";
    }
    
    public static class NotificationMessages
    {
        public const string ConfigChangeTitle = "üîî Thay ƒë·ªïi C·∫•u h√¨nh";
        public const string ComplianceCheckTitle = "‚ö†Ô∏è Ki·ªÉm tra tu√¢n th·ªß";
        public const string RouterConnectivityTitle = "üîå K·∫øt n·ªëi thi·∫øt b·ªã";
    }
}

```

### NCM3\Controllers\ConfigManagementController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.EntityFrameworkCore;
using DiffPlex.DiffBuilder.Model;
using NCM3.Models;
using NCM3.Services;

namespace NCM3.Controllers
{
    public class ConfigManagementController : Controller
    {
        private readonly NCMDbContext _context;
        private readonly ConfigurationManagementService _configService;

        public ConfigManagementController(NCMDbContext context, ConfigurationManagementService configService)
        {
            _context = context;
            _configService = configService;
        }

        // GET: ConfigManagement/CompareSelection/{routerId}
        public async Task<IActionResult> CompareSelection(int? routerId)
        {
            if (routerId == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(routerId);
            if (router == null)
            {
                return NotFound();
            }

            var configs = await _context.RouterConfigurations
                .Where(c => c.RouterId == routerId)
                .OrderByDescending(c => c.BackupDate)
                .ToListAsync();

            ViewBag.Router = router;
            ViewBag.ConfigList = new SelectList(configs, "Id", "Version");

            return View();
        }

        // POST: ConfigManagement/Compare
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Compare(int configId1, int configId2)
        {
            var config1 = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId1);
                
            var config2 = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId2);

            if (config1 == null || config2 == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareConfigurationsAsync(configId1, configId2);

            ViewBag.Config1 = config1;
            ViewBag.Config2 = config2;
            ViewBag.FullConfig1 = config1.Content;
            ViewBag.FullConfig2 = config2.Content;
            
            return View(diff);
        }
        
        // GET: ConfigManagement/UnifiedCompareWithTemplate/{configId}/{templateId}
        [HttpGet]
        public async Task<IActionResult> UnifiedCompareWithTemplate(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            var template = await _context.ConfigTemplates.FindAsync(templateId);

            if (config == null || template == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareWithTemplateAsync(configId, templateId);

            ViewBag.Config = config;
            ViewBag.Template = template;
            ViewBag.FullConfig = config.Content;
            ViewBag.FullTemplate = template.Content;
            
            return View(diff);
        }

        // GET: ConfigManagement/Search
        public IActionResult Search()
        {
            ViewBag.Routers = new SelectList(_context.Routers, "Id", "Hostname");
            return View();
        }

        // POST: ConfigManagement/SearchResults
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> SearchResults(string searchTerm, int? routerId = null)
        {
            if (string.IsNullOrEmpty(searchTerm))
            {
                return RedirectToAction(nameof(Search));
            }

            var results = await _configService.SearchInConfigurationsAsync(searchTerm, routerId);
            
            ViewBag.SearchTerm = searchTerm;
            if (routerId.HasValue)
            {
                ViewBag.Router = await _context.Routers.FindAsync(routerId);
            }
            
            return View(results);
        }

        // GET: ConfigManagement/Templates
        public async Task<IActionResult> Templates()
        {
            return View(await _context.ConfigTemplates.ToListAsync());
        }
        
        // GET: ConfigManagement/CreateTemplate
        public IActionResult CreateTemplate()
        {
            return View();
        }
        
        // POST: ConfigManagement/CreateTemplate
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateTemplate([Bind("Name,Content,Description,DeviceType")] ConfigTemplate template)
        {
            if (ModelState.IsValid)
            {
                template.CreatedDate = DateTime.Now;
                template.CreatedBy = "System"; // Sau n√†y s·∫Ω l√† ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p
                template.Version = "1.0";
                
                _context.Add(template);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Templates));
            }
            return View(template);
        }
        
        // GET: ConfigManagement/EditTemplate/5
        public async Task<IActionResult> EditTemplate(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var template = await _context.ConfigTemplates.FindAsync(id);
            if (template == null)
            {
                return NotFound();
            }
            
            return View(template);
        }
        
        // POST: ConfigManagement/EditTemplate/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditTemplate(int id, [Bind("Id,Name,Content,Description,DeviceType,CreatedDate,CreatedBy")] ConfigTemplate template)
        {
            if (id != template.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    // C·∫≠p nh·∫≠t phi√™n b·∫£n
                    if (!string.IsNullOrEmpty(template.Version))
                    {
                        var versionParts = template.Version.Split('.');
                        if (versionParts.Length >= 2 && int.TryParse(versionParts[1], out int minorVersion))
                        {
                            template.Version = $"{versionParts[0]}.{minorVersion + 1}";
                        }
                    }
                    else
                    {
                        template.Version = "1.0";
                    }
                    
                    _context.Update(template);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!TemplateExists(template.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(Templates));
            }
            return View(template);
        }
        
        // GET: ConfigManagement/DeleteTemplate/5
        public async Task<IActionResult> DeleteTemplate(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var template = await _context.ConfigTemplates
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (template == null)
            {
                return NotFound();
            }

            return View(template);
        }
        
        // POST: ConfigManagement/DeleteTemplateConfirmed/5
        [HttpPost, ActionName("DeleteTemplate")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteTemplateConfirmed(int id)
        {
            var template = await _context.ConfigTemplates.FindAsync(id);
            if (template != null)
            {
                _context.ConfigTemplates.Remove(template);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(Templates));
        }
        
        // GET: ConfigManagement/CompareWithTemplate/{configId}
        public async Task<IActionResult> CompareWithTemplateSelection(int? configId)
        {
            if (configId == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            if (config == null)
            {
                return NotFound();
            }

            var templates = await _context.ConfigTemplates.ToListAsync();
            if (!templates.Any())
            {
                TempData["Message"] = "Kh√¥ng c√≥ template n√†o. Vui l√≤ng t·∫°o template tr∆∞·ªõc.";
                return RedirectToAction("Templates");
            }

            ViewBag.Config = config;
            ViewBag.Templates = new SelectList(templates, "Id", "Name");

            return View();
        }
        
        // POST: ConfigManagement/CompareWithTemplate
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CompareWithTemplate(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            var template = await _context.ConfigTemplates.FindAsync(templateId);

            if (config == null || template == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareWithTemplateAsync(configId, templateId);

            ViewBag.Config = config;
            ViewBag.Template = template;
            
            return View(diff);
        }

        // GET: ConfigManagement/ComplianceRules
        public async Task<IActionResult> ComplianceRules()
        {
            return View(await _context.ComplianceRules.ToListAsync());
        }
        
        // GET: ConfigManagement/CreateRule
        public IActionResult CreateRule()
        {
            return View();
        }
        
        // POST: ConfigManagement/CreateRule
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateRule([Bind("Name,Pattern,Description,Severity,DeviceType,ExpectedResult,Notes")] ComplianceRule rule)
        {
            if (ModelState.IsValid)
            {
                rule.CreatedDate = DateTime.Now;
                rule.CreatedBy = "System"; // Sau n√†y s·∫Ω l√† ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p
                rule.IsActive = true;
                
                _context.Add(rule);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(ComplianceRules));
            }
            return View(rule);
        }
        
        // GET: ConfigManagement/EditRule/5
        public async Task<IActionResult> EditRule(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var rule = await _context.ComplianceRules.FindAsync(id);
            if (rule == null)
            {
                return NotFound();
            }
            
            return View(rule);
        }
        
        // POST: ConfigManagement/EditRule/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditRule(int id, [Bind("Id,Name,Pattern,Description,Severity,DeviceType,ExpectedResult,CreatedBy,CreatedDate,IsActive,Notes")] ComplianceRule rule)
        {
            if (id != rule.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    _context.Update(rule);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!RuleExists(rule.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(ComplianceRules));
            }
            return View(rule);
        }
        
        // GET: ConfigManagement/DeleteRule/5
        public async Task<IActionResult> DeleteRule(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var rule = await _context.ComplianceRules
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (rule == null)
            {
                return NotFound();
            }

            return View(rule);
        }
        
        // POST: ConfigManagement/DeleteRule/5
        [HttpPost, ActionName("DeleteRule")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteRuleConfirmed(int id)
        {
            var rule = await _context.ComplianceRules.FindAsync(id);
            if (rule != null)
            {
                _context.ComplianceRules.Remove(rule);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(ComplianceRules));
        }
        
        // GET: ConfigManagement/CheckCompliance/{configId}
        public async Task<IActionResult> CheckCompliance(int? configId)
        {
            if (configId == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            if (config == null)
            {
                return NotFound();
            }

            var results = await _configService.CheckComplianceAsync(config.Id);
            
            // L∆∞u k·∫øt qu·∫£ v√†o database n·∫øu c·∫ßn
            _context.ComplianceResults.AddRange(results);
            await _context.SaveChangesAsync();
            
            ViewBag.Config = config;
            ViewBag.Router = config.Router;
            
            // L·∫•y th√¥ng tin c√°c quy t·∫Øc
            var ruleIds = results.Select(r => r.RuleId).ToList();
            var rules = await _context.ComplianceRules
                .Where(r => ruleIds.Contains(r.Id))
                .ToDictionaryAsync(r => r.Id);
            
            ViewBag.Rules = rules;
            
            return View(results);
        }
        
        private bool TemplateExists(int id)
        {
            return _context.ConfigTemplates.Any(e => e.Id == id);
        }
        
        private bool RuleExists(int id)
        {
            return _context.ComplianceRules.Any(e => e.Id == id);
        }
    }
}
```

### NCM3\Controllers\HomeController.cs
```cs
using System.Diagnostics;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;

namespace NCM3.Controllers
{    public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;
        private readonly NCMDbContext _context;

        public HomeController(ILogger<HomeController> logger, NCMDbContext context)
        {
            _logger = logger;
            _context = context;
        }

        public IActionResult Index()
        {
            // Check if there are routers in the system
            if (_context.Routers.Any())
            {
                return View();
            }
            
            // If no routers exist, redirect to routers page to add one
            return RedirectToAction("Index", "Routers");
        }

        public IActionResult Privacy()
        {
            return View();
        }        // GET: /Home/Restore
        public IActionResult Restore()
        {
            return View();
        }

        // GET: /Home/GetRouters
        [HttpGet]
        public async Task<IActionResult> GetRouters()
        {
            try
            {
                var routers = await _context.Routers                .AsNoTracking()
                .OrderBy(r => r.Hostname)
                .Select(r => new { r.Id, r.Hostname, r.IpAddress, r.IsAvailable })
                .ToListAsync();

                return Json(routers);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "L·ªói khi t·∫£i danh s√°ch router");
                return Json(new { error = "Kh√¥ng th·ªÉ t·∫£i danh s√°ch router: " + ex.Message });
            }
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
    }
}

```

### NCM3\Controllers\RestoreController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services;
using System.IO;

namespace NCM3.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class RestoreController : ControllerBase
    {
        private readonly ILogger<RestoreController> _logger;
        private readonly NCMDbContext _context;
        private readonly RouterService _routerService;

        public RestoreController(ILogger<RestoreController> logger, NCMDbContext context, RouterService routerService)
        {
            _logger = logger;
            _context = context;
            _routerService = routerService;
        }

        // GET: api/restore/router/{id}/backups
        [HttpGet("router/{id}/backups")]
        public async Task<IActionResult> GetRouterBackups(int id)
        {
            _logger.LogInformation("Getting backup list for router with ID {RouterId}", id);
            
            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                _logger.LogWarning("Router with ID {RouterId} not found", id);
                return NotFound(new { success = false, message = "Router kh√¥ng t·ªìn t·∫°i" });
            }

            var backups = await _context.RouterConfigurations
                .Where(c => c.RouterId == id)
                .OrderByDescending(c => c.BackupDate)
                .Select(c => new {
                    c.Id,
                    c.BackupDate,
                    c.BackupType,
                    ConfigSize = c.Content.Length,
                    c.Comment
                })
                .ToListAsync();

            _logger.LogInformation("Retrieved {BackupCount} backups for router {RouterName}", backups.Count, router.Hostname);
            
            return Ok(new { 
                success = true, 
                router = new { router.Id, router.Hostname, router.IpAddress },
                backups 
            });
        }

        // GET: api/restore/backup/{id}
        [HttpGet("backup/{id}")]
        public async Task<IActionResult> GetBackupDetail(int id)
        {
            _logger.LogInformation("Getting details for backup with ID {BackupId}", id);
            
            var backup = await _context.RouterConfigurations.FindAsync(id);
            if (backup == null)
            {
                _logger.LogWarning("Backup with ID {BackupId} not found", id);
                return NotFound(new { success = false, message = "B·∫£n sao l∆∞u kh√¥ng t·ªìn t·∫°i" });
            }

            var router = await _context.Routers.FindAsync(backup.RouterId);
            if (router == null)
            {
                _logger.LogWarning("Associated router for backup ID {BackupId} not found", id);
                return NotFound(new { success = false, message = "Router kh√¥ng t·ªìn t·∫°i" });
            }

            _logger.LogInformation("Retrieved details for backup {BackupId} of router {RouterName}", 
                id, router.Hostname);
            
            return Ok(new { 
                success = true, 
                backup = new {
                    backup.Id,
                    backup.BackupDate,
                    backup.BackupType,
                    backup.Content,
                    backup.Comment,
                    Router = new { router.Id, router.Hostname, router.IpAddress }
                }
            });
        }

        // POST: api/restore/router/{id}
        [HttpPost("router/{id}")]
        public async Task<IActionResult> RestoreRouter(int id, [FromBody] RestoreRequest request)
        {
            _logger.LogInformation("Received restore request for router ID {RouterId} with backup ID {BackupId}",
                id, request?.BackupId);
                
            if (request == null || request.BackupId <= 0)
            {
                _logger.LogWarning("Invalid restore request received for router {RouterId}", id);
                return BadRequest(new { success = false, message = "Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá" });
            }

            // Fetch router with configurations included
            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == id);

            if (router == null)
            {
                _logger.LogWarning("Router with ID {RouterId} not found", id);
                return NotFound(new { success = false, message = "Router kh√¥ng t·ªìn t·∫°i" });
            }

            // Get the specific backup to restore
            var backup = await _context.RouterConfigurations.FindAsync(request.BackupId);
            if (backup == null || backup.RouterId != id)
            {
                _logger.LogWarning("Backup {BackupId} not found or doesn't belong to router {RouterName}", 
                    request.BackupId, router.Hostname);
                return NotFound(new { 
                    success = false, 
                    message = "B·∫£n sao l∆∞u kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng thu·ªôc v·ªÅ router n√†y" 
                });
            }

            // Validate IP address before proceeding
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogError("Router {RouterName} (ID: {RouterId}) has no IP address configured", 
                    router.Hostname, router.Id);
                return BadRequest(new { 
                    success = false, 
                    message = $"Router {router.Hostname} kh√¥ng c√≥ ƒë·ªãa ch·ªâ IP" 
                });
            }

            if (!System.Net.IPAddress.TryParse(router.IpAddress, out var ipAddress))
            {
                _logger.LogError("Router {RouterName} has invalid IP address: {IPAddress}", 
                    router.Hostname, router.IpAddress);
                return BadRequest(new { 
                    success = false, 
                    message = $"Router {router.Hostname} c√≥ ƒë·ªãa ch·ªâ IP kh√¥ng h·ª£p l·ªá: {router.IpAddress}" 
                });
            }

            try
            {
                // Create a backup of the current configuration if requested
                if (request.CreateBackupBeforeRestore)
                {
                    try
                    {
                        _logger.LogInformation("Creating pre-restore backup for router {RouterName}", router.Hostname);
                        
                        // Get the current configuration before restoring
                        string currentConfig = await _routerService.GetConfigurationAsync(router);
                        
                        // Check if the configuration retrieval failed
                        if (string.IsNullOrEmpty(currentConfig) || currentConfig.StartsWith("Error:"))
                        {
                            _logger.LogWarning("Could not create pre-restore backup for router {RouterName}: {ErrorMessage}", 
                                router.Hostname, currentConfig ?? "No configuration received");
                            
                            // Continue with restore anyway, but inform the user
                            _logger.LogInformation("Continuing with restore operation despite backup failure");
                        }
                        else
                        {
                            // Create a backup of the current configuration
                            var currentBackup = new RouterConfiguration
                            {
                                RouterId = router.Id,
                                BackupDate = DateTime.UtcNow,
                                BackupType = "Pre-Restore",
                                Content = currentConfig,
                                BackupBy = User.Identity?.Name ?? "System",
                                Comment = "B·∫£n sao l∆∞u t·ª± ƒë·ªông tr∆∞·ªõc khi kh√¥i ph·ª•c"
                            };
                            
                            _context.RouterConfigurations.Add(currentBackup);
                            await _context.SaveChangesAsync();
                            _logger.LogInformation("Successfully created pre-restore backup (ID: {BackupId}) for router {RouterName}", 
                                currentBackup.Id, router.Hostname);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Failed to create pre-restore backup for router {RouterName}", router.Hostname);
                        // Continue with restore anyway since this is just a precaution
                    }
                }
                
                // Log the actual restoration attempt
                _logger.LogInformation("Attempting to restore configuration to router {RouterName} ({IPAddress}) from backup created on {BackupDate}", 
                    router.Hostname, ipAddress.ToString(), backup.BackupDate);

                // Perform the actual restoration
                bool success = await _routerService.RestoreConfigurationAsync(router, backup.Content);
                
                if (success)
                {
                    _logger.LogInformation("Successfully restored configuration for router {RouterName} from backup {BackupId}", 
                        router.Hostname, backup.Id);
                    
                    // Record the restoration in the database
                    var restoreRecord = new RouterConfiguration
                    {
                        RouterId = router.Id,
                        BackupDate = DateTime.UtcNow,
                        BackupType = "Restore",
                        Content = backup.Content,
                        BackupBy = User.Identity?.Name ?? "System",
                        Comment = $"Kh√¥i ph·ª•c t·ª´ b·∫£n sao l∆∞u ng√†y {backup.BackupDate:yyyy-MM-dd HH:mm:ss}"
                    };
                    
                    _context.RouterConfigurations.Add(restoreRecord);
                    await _context.SaveChangesAsync();
                    
                    _logger.LogInformation("Created restore record (ID: {RecordId}) for router {RouterName}", 
                        restoreRecord.Id, router.Hostname);
                    
                    return Ok(new { 
                        success = true, 
                        message = $"ƒê√£ kh√¥i ph·ª•c c·∫•u h√¨nh th√†nh c√¥ng cho router {router.Hostname}" 
                    });
                }
                else
                {
                    _logger.LogError("Failed to restore configuration for router {RouterName} from backup {BackupId}", 
                        router.Hostname, backup.Id);
                    
                    return BadRequest(new { 
                        success = false, 
                        message = $"Kh√¥ng th·ªÉ kh√¥i ph·ª•c c·∫•u h√¨nh cho router {router.Hostname}" 
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while restoring configuration for router {RouterName}: {Error}",
                    router.Hostname, ex.Message);
                
                return StatusCode(500, new { 
                    success = false, 
                    message = $"L·ªói khi kh√¥i ph·ª•c c·∫•u h√¨nh: {ex.Message}" 
                });
            }
        }
    }

    public class RestoreRequest
    {
        public int BackupId { get; set; }
        public bool CreateBackupBeforeRestore { get; set; } = true;
    }
}

```

### NCM3\Controllers\RoutersController.cs
```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Constants;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration; // Added for S3 settings

namespace NCM3.Controllers
{
    public class RoutersController : Controller
    {
        private readonly NCMDbContext _context;
        private readonly RouterService _routerService;
        private readonly IEncryptionService _encryptionService;
        private readonly ConfigurationManagementService _configService;
        private readonly ITelegramNotificationService _telegramService;
        private readonly NotificationHelper _notificationHelper;
        private readonly ILogger<RoutersController> _logger;
        private readonly IS3BackupService _s3Service; // Added for S3 backup
        private readonly IConfiguration _configuration; // Added for S3 settings

        public RoutersController(NCMDbContext context, 
                              RouterService routerService, 
                              IEncryptionService encryptionService,
                              ConfigurationManagementService configService,
                              ITelegramNotificationService telegramService,
                              NotificationHelper notificationHelper,
                              ILogger<RoutersController> logger,
                              IS3BackupService s3BackupService, // Added
                              IConfiguration configuration) // Added
        {
            _context = context;
            _routerService = routerService;
            _encryptionService = encryptionService;
            _configService = configService;
            _telegramService = telegramService;
            _notificationHelper = notificationHelper;
            _logger = logger;
            _s3Service = s3BackupService; // Added
            _configuration = configuration; // Added
        }

        // GET: Routers
        public async Task<IActionResult> Index()
        {
            return View(await _context.Routers.ToListAsync());
        }

        // GET: Routers/Details/5
        public async Task<IActionResult> Details(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            return View(router);
        }

        // GET: Routers/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Routers/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create([Bind("Id,Hostname,IpAddress,Username,Password,EnablePassword,Model,OSVersion")] Router router)
        {
            if (ModelState.IsValid)
            {
                // M√£ h√≥a m·∫≠t kh·∫©u tr∆∞·ªõc khi l∆∞u v√†o database
                router.Password = _encryptionService.Encrypt(router.Password);
                if (!string.IsNullOrEmpty(router.EnablePassword))
                {
                    router.EnablePassword = _encryptionService.Encrypt(router.EnablePassword);
                }
                
                router.Status = RouterStatus.Unknown;
                router.IsAvailable = false; // Set default availability status to false
                _context.Add(router);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Index));
            }
            return View(router);
        }

        // GET: Routers/Edit/5
        public async Task<IActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }
            return View(router);
        }

        // POST: Routers/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, [Bind("Id,Hostname,IpAddress,Username,Password,EnablePassword,Model,OSVersion,Status,IsAvailable")] Router router)
        {
            if (id != router.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    // Check if password was left blank (meaning keep the existing one)
                    var existingRouter = await _context.Routers.AsNoTracking().FirstOrDefaultAsync(r => r.Id == id);
                    if (existingRouter != null)
                    {
                        if (string.IsNullOrEmpty(router.Password))
                        {
                            router.Password = existingRouter.Password;
                        }
                        else
                        {
                            // M√£ h√≥a m·∫≠t kh·∫©u m·ªõi
                            router.Password = _encryptionService.Encrypt(router.Password);
                        }
                        
                        if (string.IsNullOrEmpty(router.EnablePassword))
                        {
                            router.EnablePassword = existingRouter.EnablePassword;
                        }
                        else if (!string.IsNullOrEmpty(router.EnablePassword))
                        {
                            // M√£ h√≥a enable password m·ªõi
                            router.EnablePassword = _encryptionService.Encrypt(router.EnablePassword);
                        }
                    }
                    
                    _context.Update(router);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!RouterExists(router.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(Index));
            }
            return View(router);
        }

        // GET: Routers/Delete/5
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            return View(router);
        }

        // POST: Routers/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var router = await _context.Routers.FindAsync(id);
            if (router != null)
            {
                _context.Routers.Remove(router);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(Index));
        }

        // GET: Routers/TestConnection/5
        public async Task<IActionResult> TestConnection(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }

            bool isConnected = await _routerService.CheckConnectionAsync(router);
            
            // Update the router status in the database
            _context.Update(router);
            await _context.SaveChangesAsync();
            
            return RedirectToAction(nameof(Details), new { id = router.Id });
        }

        // GET: Routers/BackupConfiguration/5
        public async Task<IActionResult> BackupConfiguration(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            try
            {
                string configContent = await _routerService.GetConfigurationAsync(router);
                
                // Create a new configuration backup
                var routerConfig = new RouterConfiguration
                {
                    RouterId = router.Id,
                    BackupDate = DateTime.UtcNow, 
                    Content = configContent, // Use the fetched config content
                    Version = $"Manual_{DateTime.UtcNow:yyyyMMdd_HHmmss}", // Changed prefix to Manual
                    BackupBy = User?.Identity?.Name ?? "System", // Get current user or default to System
                    BackupType = BackupTypes.Manual 
                };
                
                _context.RouterConfigurations.Add(routerConfig);
                
                router.LastBackup = routerConfig.BackupDate;
                _context.Update(router);
                
                await _context.SaveChangesAsync();

                // Upload to S3 if enabled
                bool enableS3Backup = _configuration.GetValue<bool>("AWS:S3:EnableS3Backup", false);
                if (enableS3Backup)
                {
                    try
                    {
                        bool s3UploadSuccess = await _s3Service.UploadBackupAsync(router.Id, configContent, routerConfig.Version, routerConfig.BackupBy);
                        if (s3UploadSuccess)
                        {
                            _logger.LogInformation($"ƒê√£ t·∫£i b·∫£n sao l∆∞u th·ªß c√¥ng {routerConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                        }
                        else
                        {
                            _logger.LogWarning($"Kh√¥ng t·∫£i ƒë∆∞·ª£c b·∫£n sao l∆∞u th·ªß c√¥ng {routerConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                            // Optionally, add a TempData message for the user if S3 upload fails
                            // TempData["WarningMessage"] = "ƒê√£ sao l∆∞u c·ª•c b·ªô th√†nh c√¥ng, nh∆∞ng kh√¥ng th·ªÉ t·∫£i l√™n S3.";
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"L·ªói khi t·∫£i b·∫£n sao l∆∞u th·ªß c√¥ng {routerConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                        // Optionally, add a TempData message for the user
                        // TempData["WarningMessage"] = "ƒê√£ sao l∆∞u c·ª•c b·ªô th√†nh c√¥ng, nh∆∞ng ƒë√£ x·∫£y ra l·ªói khi t·∫£i l√™n S3.";
                    }
                }
                
                // Ki·ªÉm tra v√† g·ª≠i th√¥ng b√°o n·∫øu c√≥ thay ƒë·ªïi
                await _notificationHelper.DetectAndNotifyConfigurationChangeAsync(
                    router,
                    configContent, // Use the fetched config content
                    "Sao l∆∞u c·∫•u h√¨nh th·ªß c√¥ng"
                );
                
                _logger.LogInformation("ƒê√£ sao l∆∞u c·∫•u h√¨nh cho router {RouterName}", router.Hostname);
                TempData["SuccessMessage"] = "ƒê√£ sao l∆∞u c·∫•u h√¨nh th√†nh c√¥ng.";
                
                return RedirectToAction(nameof(ConfigurationHistory), new { id = router.Id });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "L·ªói khi sao l∆∞u c·∫•u h√¨nh router {RouterId}: {Message}", id, ex.Message);
                TempData["ErrorMessage"] = $"L·ªói khi sao l∆∞u c·∫•u h√¨nh: {ex.Message}";
                return RedirectToAction(nameof(Details), new { id = router.Id });
            }
        }

        // GET: Routers/ConfigurationHistory/5
        public async Task<IActionResult> ConfigurationHistory(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }

            var configs = await _context.RouterConfigurations
                .Where(c => c.RouterId == id)
                .OrderByDescending(c => c.BackupDate)
                .ToListAsync();
                
            ViewBag.Router = router;
            
            return View(configs);
        }

        // GET: Routers/ViewConfiguration/5
        public async Task<IActionResult> ViewConfiguration(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (config == null)
            {
                return NotFound();
            }

            return View(config);
        }

        // GET: Routers/DebugSsh/5
        public async Task<IActionResult> DebugSsh(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }
            
            ViewBag.Router = router;
            ViewBag.DebugLog = await _routerService.DebugSshConnectionAsync(router);
            
            return View();
        }

        private bool RouterExists(int id)
        {
            return _context.Routers.Any(e => e.Id == id);
        }
    }
}
```

### NCM3\Controllers\SettingsController.cs
```cs
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services;
using System.IO;
using System.Text;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace NCM3.Controllers
{
    public class SettingsController : Controller
    {        private readonly ILogger<SettingsController> _logger;
        private readonly IConfiguration _configuration;
        private readonly ITelegramNotificationService _telegramService;
        private readonly IWebhookNotificationService _webhookService;
        private readonly string _appSettingsFilePath;
        private readonly NotificationLogger? _notificationLogger;
        
        public SettingsController(
            ILogger<SettingsController> logger,
            IConfiguration configuration,
            ITelegramNotificationService telegramService,
            IWebhookNotificationService webhookService,
            NotificationLogger? notificationLogger = null)
        {
            _logger = logger;
            _configuration = configuration;
            _telegramService = telegramService;
            _webhookService = webhookService;
            _notificationLogger = notificationLogger;
            
            // L·∫•y ƒë∆∞·ªùng d·∫´n t·ªõi t·ªáp appsettings.json
            _appSettingsFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "appsettings.json");
        }
        
        public IActionResult Index()
        {
            var viewModel = new SettingsViewModel
            {
                NotificationSettings = new NotificationSettings
                {
                    TelegramBotToken = _configuration["Telegram:BotToken"] ?? string.Empty,
                    TelegramChatId = _configuration["Telegram:ChatId"] ?? string.Empty,
                    EnableTelegram = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) && 
                                    !string.IsNullOrEmpty(_configuration["Telegram:ChatId"]),
                    WebhookUrl = _configuration["Notification:WebhookUrl"] ?? string.Empty,
                    EnableWebhook = bool.TryParse(_configuration["Notification:EnableWebhook"], out bool enableWebhook) && enableWebhook,
                    NotifyOnConfigChange = !bool.TryParse(_configuration["Notification:NotifyOnConfigChange"], out bool notifyConfig) || notifyConfig,
                    NotifyOnComplianceIssue = !bool.TryParse(_configuration["Notification:NotifyOnComplianceIssue"], out bool notifyCompliance) || notifyCompliance,
                    NotifyOnConnectivityChange = !bool.TryParse(_configuration["Notification:NotifyOnConnectivityChange"], out bool notifyConn) || notifyConn
                },
                
                AutoDetectionSettings = new AutoDetectionSettings
                {
                    EnableAutoDetection = bool.TryParse(_configuration["AutoDetection:Enabled"], out bool enabled) && enabled,
                    CheckIntervalMinutes = int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int interval) 
                        ? interval 
                        : 30,
                    DetectConfigChanges = !bool.TryParse(_configuration["AutoDetection:DetectConfigChanges"], out bool detectConfig) || detectConfig,
                    DetectConnectivityChanges = !bool.TryParse(_configuration["AutoDetection:DetectConnectivityChanges"], out bool detectConn) || detectConn,
                    DetectComplianceIssues = !bool.TryParse(_configuration["AutoDetection:DetectComplianceIssues"], out bool detectComp) || detectComp
                },
                
                // Ki·ªÉm tra tr·∫°ng th√°i d·ªãch v·ª•
                DetectionServiceRunning = bool.TryParse(_configuration["AutoDetection:Enabled"], out bool serviceRunning) && serviceRunning,
                TelegramEnabled = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) && 
                                  !string.IsNullOrEmpty(_configuration["Telegram:ChatId"])
            };
            
            return View(viewModel);
        }
          public async Task<IActionResult> SaveNotificationSettings(NotificationSettings model)
        {
            if (!ModelState.IsValid)
            {
                return RedirectToAction(nameof(Index));
            }
            
            try
            {
                // ƒê·ªçc t·ªáp c·∫•u h√¨nh
                var json = await System.IO.File.ReadAllTextAsync(_appSettingsFilePath);
                var jsonObj = JObject.Parse(json);
                
                // C·∫≠p nh·∫≠t c·∫•u h√¨nh Telegram
                if (jsonObj["Telegram"] == null)
                {
                    jsonObj["Telegram"] = new JObject();
                }
                
                if (jsonObj["Telegram"] != null)
                {
                    jsonObj["Telegram"]["BotToken"] = model.EnableTelegram ? model.TelegramBotToken : string.Empty;
                    jsonObj["Telegram"]["ChatId"] = model.EnableTelegram ? model.TelegramChatId : string.Empty;
                }
                
                // C·∫≠p nh·∫≠t c·∫•u h√¨nh Notification
                if (jsonObj["Notification"] == null)
                {
                    jsonObj["Notification"] = new JObject();
                }
                
                if (jsonObj["Notification"] != null)
                {
                    jsonObj["Notification"]["EnableWebhook"] = model.EnableWebhook.ToString().ToLower();
                    jsonObj["Notification"]["WebhookUrl"] = model.WebhookUrl;
                    jsonObj["Notification"]["NotifyOnConfigChange"] = model.NotifyOnConfigChange.ToString().ToLower();
                    jsonObj["Notification"]["NotifyOnComplianceIssue"] = model.NotifyOnComplianceIssue.ToString().ToLower();
                    jsonObj["Notification"]["NotifyOnConnectivityChange"] = model.NotifyOnConnectivityChange.ToString().ToLower();
                }
                
                // Ghi l·∫°i t·ªáp c·∫•u h√¨nh
                await System.IO.File.WriteAllTextAsync(_appSettingsFilePath, jsonObj.ToString(Formatting.Indented));
                
                _logger.LogInformation("ƒê√£ c·∫≠p nh·∫≠t thi·∫øt l·∫≠p th√¥ng b√°o");
                TempData["SuccessMessage"] = "ƒê√£ l∆∞u thi·∫øt l·∫≠p th√¥ng b√°o th√†nh c√¥ng";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "L·ªói khi l∆∞u thi·∫øt l·∫≠p th√¥ng b√°o: {Error}", ex.Message);
                TempData["ErrorMessage"] = $"L·ªói khi l∆∞u thi·∫øt l·∫≠p: {ex.Message}";
            }
            
            return RedirectToAction(nameof(Index));
        }
        
        [HttpPost]
        public async Task<IActionResult> SaveAutoDetectionSettings(AutoDetectionSettings model)
        {
            if (!ModelState.IsValid)
            {
                return RedirectToAction(nameof(Index));
            }
            
            try
            {
                // ƒê·ªçc t·ªáp c·∫•u h√¨nh
                var json = await System.IO.File.ReadAllTextAsync(_appSettingsFilePath);
                var jsonObj = JObject.Parse(json);
                
                // C·∫≠p nh·∫≠t c·∫•u h√¨nh AutoDetection
                if (jsonObj["AutoDetection"] == null)
                {
                    jsonObj["AutoDetection"] = new JObject();
                }
                
                jsonObj["AutoDetection"]["Enabled"] = model.EnableAutoDetection.ToString().ToLower();
                jsonObj["AutoDetection"]["CheckIntervalMinutes"] = model.CheckIntervalMinutes.ToString();
                jsonObj["AutoDetection"]["DetectConfigChanges"] = model.DetectConfigChanges.ToString().ToLower();
                jsonObj["AutoDetection"]["DetectConnectivityChanges"] = model.DetectConnectivityChanges.ToString().ToLower();
                jsonObj["AutoDetection"]["DetectComplianceIssues"] = model.DetectComplianceIssues.ToString().ToLower();
                
                // Ghi l·∫°i t·ªáp c·∫•u h√¨nh
                await System.IO.File.WriteAllTextAsync(_appSettingsFilePath, jsonObj.ToString(Formatting.Indented));
                
                _logger.LogInformation("ƒê√£ c·∫≠p nh·∫≠t thi·∫øt l·∫≠p t·ª± ƒë·ªông ph√°t hi·ªán");
                TempData["SuccessMessage"] = "ƒê√£ l∆∞u thi·∫øt l·∫≠p t·ª± ƒë·ªông ph√°t hi·ªán th√†nh c√¥ng";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "L·ªói khi l∆∞u thi·∫øt l·∫≠p t·ª± ƒë·ªông ph√°t hi·ªán: {Error}", ex.Message);
                TempData["ErrorMessage"] = $"L·ªói khi l∆∞u thi·∫øt l·∫≠p: {ex.Message}";
            }
            
            return RedirectToAction(nameof(Index));
        }          [HttpPost]
        public async Task<IActionResult> TestTelegramConnection()
        {
            var viewModel = new SettingsViewModel();
            
            try
            {
                // Create a long test message to verify truncation works
                var longTestMessage = "Th√¥ng b√°o n√†y ch·ªâ ƒë·ªÉ x√°c nh·∫≠n k·∫øt n·ªëi th√†nh c√¥ng gi·ªØa NCM3 v√† Telegram.\n\n" + 
                                     GenerateLongTestMessage();
                
                await _telegramService.SendConfigChangeNotificationAsync(
                    "Ki·ªÉm tra k·∫øt n·ªëi",
                    "Th·ª≠ nghi·ªám",
                    longTestMessage);
                
                viewModel.TestResult = "K·∫øt n·ªëi th√†nh c√¥ng! ƒê√£ g·ª≠i tin nh·∫Øn ki·ªÉm tra ƒë·∫øn Telegram. Ki·ªÉm tra xem tin nh·∫Øn c√≥ hi·ªÉn th·ªã ƒë√∫ng v√† kh√¥ng b·ªã l·ªói.";
                viewModel.TestSuccessful = true;
                
                _logger.LogInformation("Ki·ªÉm tra k·∫øt n·ªëi Telegram th√†nh c√¥ng");
                TempData["TestResult"] = viewModel.TestResult;
                TempData["TestSuccessful"] = true;
            }
            catch (Exception ex)
            {
                viewModel.TestResult = $"L·ªói k·∫øt n·ªëi: {ex.Message}";
                viewModel.TestSuccessful = false;
                
                _logger.LogError(ex, "L·ªói ki·ªÉm tra k·∫øt n·ªëi Telegram: {Error}", ex.Message);
                TempData["TestResult"] = viewModel.TestResult;
                TempData["TestSuccessful"] = false;
            }
            
            return RedirectToAction(nameof(Index));
        }
        
        // Helper method to generate a long message for testing
        private string GenerateLongTestMessage()
        {
            var result = new StringBuilder();
            result.AppendLine("ƒê√¢y l√† m·ªôt tin nh·∫Øn d√†i ƒë·ªÉ ki·ªÉm tra ch·ª©c nƒÉng x·ª≠ l√Ω tin nh·∫Øn d√†i trong Telegram:");
            result.AppendLine();
            result.AppendLine("```");
            
            // Generate fake router config changes
            for (int i = 1; i <= 100; i++)
            {
                if (i % 2 == 0)
                {
                    result.AppendLine($"+ interface GigabitEthernet0/{i}");
                    result.AppendLine($"+  description Added connection to Server{i}");
                    result.AppendLine($"+  ip address 192.168.{i}.1 255.255.255.0");
                    result.AppendLine($"+  no shutdown");
                }
                else
                {
                    result.AppendLine($"- interface GigabitEthernet0/{i}");
                    result.AppendLine($"-  description Old connection to Switch{i}");
                    result.AppendLine($"-  ip address 10.0.{i}.1 255.255.255.0");
                    result.AppendLine($"-  shutdown");
                }
            }
            
            result.AppendLine("```");
            return result.ToString();
        }
        
        /// <summary>
        /// Hi·ªÉn th·ªã l·ªãch s·ª≠ th√¥ng b√°o
        /// </summary>
        public async Task<IActionResult> NotificationHistory(string filter = "all", int page = 1, int pageSize = 20)
        {
            if (_notificationLogger == null)
            {
                return View(new Models.ViewModels.NotificationHistoryViewModel());
            }
            
            var model = await _notificationLogger.GetNotificationHistoryAsync(filter, page, pageSize);
            return View(model);
        }
    }
}

```

### NCM3\Controllers\SNMPTestController.cs
```cs
using System;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using SnmpSharpNet;

namespace NCM3.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class SNMPTestController : ControllerBase
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<SNMPTestController> _logger;

        public SNMPTestController(IConfiguration configuration, ILogger<SNMPTestController> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        [HttpPost]
        public IActionResult TestSNMPCredentials([FromBody] SNMPTestRequest request)
        {
            if (string.IsNullOrEmpty(request.IpAddress))
            {
                return BadRequest(new { success = false, message = "IP Address is required" });
            }            if (string.IsNullOrEmpty(request.Community))
            {
                // Use default community if none provided
                request.Community = _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Community", "public");
            }

            if (string.IsNullOrEmpty(request.Version))
            {
                // Use default version if none provided
                request.Version = _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Version", "Auto");
            }            try
            {                // Validate IP address format
                if (!IPAddress.TryParse(request.IpAddress, out IPAddress? ipAddressResult) || ipAddressResult == null)
                {
                    return BadRequest(new { 
                        success = false, 
                        message = $"Invalid IP address format: {request.IpAddress}" 
                    });
                }
                
                IPAddress ipAddress = ipAddressResult;
                
                var community = new OctetString(request.Community);
                var param = new AgentParameters(community);
                
                // Get SNMP settings from config
                int port = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Port", 161);
                int timeout = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Timeout", 2000);
                int retries = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Retries", 0);
                
                var target = new UdpTarget(ipAddress, port, timeout, retries);
                
                try
                {
                    // Create Pdu for SNMP GET
                    var pdu = new Pdu(PduType.Get);                    // Use system description OID (common on all SNMP devices)
                    var oid = new Oid("1.3.6.1.2.1.1.1.0"); // sysDescr.0
                    pdu.VbList.Add(oid);
                      // Determine SNMP version to use
                    SnmpPacket? result = null;
                    string snmpVersion = request.Version?.ToLower() ?? "auto";
                    string versionUsed = "";
                    
                    if (snmpVersion == "v1" || snmpVersion == "1")
                    {
                        // Use SNMPv1
                        param.Version = SnmpVersion.Ver1;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv1";
                    }
                    else if (snmpVersion == "v2" || snmpVersion == "v2c" || snmpVersion == "2")
                    {
                        // Use SNMPv2c
                        param.Version = SnmpVersion.Ver2;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv2c";
                    }
                    else // "auto" or any other value
                    {
                        // Try SNMPv2c first, then fallback to SNMPv1 if it fails
                        try
                        {
                            param.Version = SnmpVersion.Ver2;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv2c";
                        }
                        catch (Exception ex)
                        {
                            _logger.LogInformation("SNMPv2c request failed, falling back to SNMPv1: {ErrorMessage}", ex.Message);
                            
                            // Reset PDU for new request
                            pdu = new Pdu(PduType.Get);
                            pdu.VbList.Add(oid);
                            
                            param.Version = SnmpVersion.Ver1;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv1";
                        }
                    }
                    
                    // Process the result based on the actual type returned
                    if (result != null)
                    {
                        if (result is SnmpV2Packet v2Packet && v2Packet.Pdu.ErrorStatus == 0)
                        {
                            var sysdescr = v2Packet.Pdu.VbList[0].Value.ToString();
                            return Ok(new { 
                                success = true, 
                                message = $"SNMP test successful using {versionUsed}", 
                                sysDescr = sysdescr,
                                version = versionUsed
                            });
                        }
                        else if (result is SnmpV1Packet v1Packet && v1Packet.Pdu.ErrorStatus == 0)
                        {
                            var sysdescr = v1Packet.Pdu.VbList[0].Value.ToString();
                            return Ok(new { 
                                success = true, 
                                message = $"SNMP test successful using {versionUsed}", 
                                sysDescr = sysdescr,
                                version = versionUsed
                            });
                        }
                        else
                        {
                            // Handle case where we got a response but with an error
                            string errorStatus = "unknown";
                            int errorIndex = -1;
                            
                            if (result is SnmpV2Packet v2P)
                            {
                                errorStatus = v2P.Pdu.ErrorStatus.ToString();
                                errorIndex = v2P.Pdu.ErrorIndex;
                            }
                            else if (result is SnmpV1Packet v1P)
                            {
                                errorStatus = v1P.Pdu.ErrorStatus.ToString();
                                errorIndex = v1P.Pdu.ErrorIndex;
                            }
                            
                            return BadRequest(new { 
                                success = false, 
                                message = $"SNMP GET failed using {versionUsed}. Error: {errorStatus}, Index: {errorIndex}", 
                                version = versionUsed
                            });
                        }
                    }
                    else
                    {
                        return BadRequest(new { 
                            success = false, 
                            message = $"No response received from SNMP request using {versionUsed}"
                        });
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error testing SNMP for IP {IPAddress}: {ErrorMessage}",
                        request.IpAddress, ex.Message);
                    
                    return BadRequest(new { 
                        success = false, 
                        message = $"Error: {ex.Message}" 
                    });
                }
                finally
                {
                    target.Close();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SNMP test: {ErrorMessage}", ex.Message);
                return BadRequest(new { 
                    success = false, 
                    message = $"Error: {ex.Message}" 
                });
            }
        }
    }    public class SNMPTestRequest
    {
        public string? IpAddress { get; set; }
        public string? Community { get; set; }
        public string? Version { get; set; }
    }
}

```

### NCM3\Extensions\AppSettingsExtensions.cs
```cs
using System;
using System.IO;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace NCM3.Extensions
{
    public static class AppSettingsExtensions
    {
        public static IServiceCollection ConfigureBackupFolders(this IServiceCollection services, IConfiguration configuration)
        {
            // L·∫•y ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c t·ª´ c·∫•u h√¨nh
            var backupFolder = configuration["AppSettings:BackupFolder"];
            var configBackupFolder = configuration["AppSettings:ConfigBackupFolder"];
            var logFolder = configuration["AppSettings:LogFolder"];
            var templatePath = configuration["AppSettings:TemplatePath"];
            var complianceRulesPath = configuration["AppSettings:ComplianceRulesPath"];
            
            // T·∫°o c√°c th∆∞ m·ª•c n·∫øu ch√∫ng ch∆∞a t·ªìn t·∫°i
            CreateDirectoryIfNotExists(backupFolder);
            CreateDirectoryIfNotExists(configBackupFolder);
            CreateDirectoryIfNotExists(logFolder);
            CreateDirectoryIfNotExists(templatePath);
            CreateDirectoryIfNotExists(complianceRulesPath);
            
            return services;
        }
        
        private static void CreateDirectoryIfNotExists(string path)
        {
            if (!string.IsNullOrEmpty(path) && !Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception ex)
                {
                    // Log l·ªói n·∫øu kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c
                    Console.WriteLine($"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c {path}: {ex.Message}");
                }
            }
        }
    }
}

```

### NCM3\Extensions\LoggingExtensions.cs
```cs
using System;
using Microsoft.Extensions.Logging;
using System.IO;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;

namespace NCM3.Extensions
{
    public static class LoggingExtensions
    {
        public static IServiceCollection AddFileLogger(this IServiceCollection services, IConfiguration configuration)
        {
            // ƒê·∫£m b·∫£o th∆∞ m·ª•c logs t·ªìn t·∫°i
            var logsPath = Path.Combine(Directory.GetCurrentDirectory(), "logs");
            if (!Directory.Exists(logsPath))
            {
                Directory.CreateDirectory(logsPath);
            }

            services.AddLogging(builder =>
            {
                builder.AddConfiguration(configuration.GetSection("Logging"));
                builder.AddConsole();
                builder.AddDebug();
                
                // Th√™m file logger n·∫øu ƒë√£ c·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
                var logFilePath = configuration["Logging:File:Path"];
                if (!string.IsNullOrEmpty(logFilePath))
                {
                    builder.AddFile(configuration.GetSection("Logging:File"));
                }
            });

            return services;
        }
    }
}

```

### NCM3\Extensions\ServiceCollectionExtensions.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using NCM3.Services;
using NCM3.Services.Events;
using NCM3.Services.ChangeDetection;
using NCM3.Models;

namespace NCM3.Extensions
{
    public static class ServiceCollectionExtensions
    {
        public static void AddNotificationServices(this IServiceCollection services)
        {
            // Register a hosted service that will handle the circular dependency initialization
            services.AddHostedService<NotificationInitializerService>();
        }          public static void AddChangeDetectionServices(this IServiceCollection services)
        {
            // Register the event bus as a singleton
            services.AddSingleton<IEventBus, InMemoryEventBus>();
            
            // Create factory for RouterService to avoid scoping issues
            services.AddSingleton<Func<RouterService>>(serviceProvider => () => 
            {
                // Create a scope to resolve the scoped RouterService
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<RouterService>();
            });
            
            // Create factory for DbContext to avoid scoping issues
            services.AddSingleton<Func<NCMDbContext>>(serviceProvider => () => 
            {
                // Create a scope to resolve the scoped DbContext
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            });
            
            // Register change detection strategies with factory dependencies
            services.AddSingleton<SNMPPollingStrategy>(serviceProvider => 
            {
                var logger = serviceProvider.GetRequiredService<ILogger<SNMPPollingStrategy>>();
                var configuration = serviceProvider.GetRequiredService<IConfiguration>();
                var routerServiceFactory = serviceProvider.GetRequiredService<Func<RouterService>>();
                var dbContextFactory = serviceProvider.GetRequiredService<Func<NCMDbContext>>();
                
                return new SNMPPollingStrategy(logger, configuration, routerServiceFactory, dbContextFactory);
            });
            
            services.AddSingleton<SSHPollingStrategy>(serviceProvider => 
            {
                var logger = serviceProvider.GetRequiredService<ILogger<SSHPollingStrategy>>();
                var configuration = serviceProvider.GetRequiredService<IConfiguration>();
                var routerServiceFactory = serviceProvider.GetRequiredService<Func<RouterService>>();
                var dbContextFactory = serviceProvider.GetRequiredService<Func<NCMDbContext>>();
                
                return new SSHPollingStrategy(logger, configuration, routerServiceFactory, dbContextFactory);
            });
            
            // Create a singleton factory that will provide the strategies
            services.AddSingleton<Func<IEnumerable<IChangeDetectionStrategy>>>(serviceProvider => () =>
            {
                var strategies = new List<IChangeDetectionStrategy>
                {
                    serviceProvider.GetRequiredService<SNMPPollingStrategy>(),
                    serviceProvider.GetRequiredService<SSHPollingStrategy>()
                };
                
                return strategies;
            });
            
            // Register the orchestrator as a hosted service
            services.AddHostedService<ChangeDetectionOrchestrator>();
        }

        public static IServiceCollection AddCustomServices(this IServiceCollection services)
        {
            services.AddScoped<NCMDbContext>();
            services.AddSingleton<Func<NCMDbContext>>(serviceProvider => () =>
            {
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            });

            services.AddScoped<RouterService>();
            services.AddSingleton<Func<RouterService>>(serviceProvider => () =>
            {
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<RouterService>();
            });

            services.AddScoped<IChangeDetectionStrategy, SNMPPollingStrategy>();
            services.AddScoped<IChangeDetectionStrategy, SSHPollingStrategy>();
            services.AddSingleton<ChangeDetectionOrchestrator>();

            return services;
        }
    }    // This hosted service will run after all services are built and initialize the circular dependency
    public class NotificationInitializerService : Microsoft.Extensions.Hosting.IHostedService
    {
        private readonly IServiceProvider _serviceProvider;

        public NotificationInitializerService(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            // Create a scope to resolve scoped services
            using (var scope = _serviceProvider.CreateScope())
            {
                var configService = scope.ServiceProvider.GetRequiredService<ConfigurationManagementService>();
                var notificationHelper = scope.ServiceProvider.GetRequiredService<NotificationHelper>();
                var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                
                // Set up the circular dependency
                configService.SetNotificationHelper(notificationHelper);
                
                // Initialize the Telegram notification service
                telegramService.Initialize();
            }
            
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }
}

```

### NCM3\Middleware\GlobalExceptionHandlerMiddleware.cs
```cs
using System;
using System.Net;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

namespace NCM3.Middleware
{
    public class GlobalExceptionHandlerMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<GlobalExceptionHandlerMiddleware> _logger;

        public GlobalExceptionHandlerMiddleware(RequestDelegate next, ILogger<GlobalExceptionHandlerMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                await HandleExceptionAsync(context, ex);
            }
        }

        private Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            _logger.LogError(exception, $"L·ªói x·∫£y ra: {exception.Message}");
            
            context.Response.ContentType = "application/json";
            
            var statusCode = HttpStatusCode.InternalServerError;
            var message = "ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n.";

            // C√≥ th·ªÉ x·ª≠ l√Ω c√°c lo·∫°i l·ªói c·ª• th·ªÉ ·ªü ƒë√¢y
            if (exception is UnauthorizedAccessException)
            {
                statusCode = HttpStatusCode.Unauthorized;
                message = "B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.";
            }
            else if (exception is ArgumentException || exception is ArgumentNullException)
            {
                statusCode = HttpStatusCode.BadRequest;
                message = exception.Message;
            }
            else if (exception is TimeoutException)
            {
                statusCode = HttpStatusCode.RequestTimeout;
                message = "Y√™u c·∫ßu ƒë√£ h·∫øt th·ªùi gian ch·ªù. Vui l√≤ng th·ª≠ l·∫°i sau.";
            }
            
            context.Response.StatusCode = (int)statusCode;
            
            // Khi y√™u c·∫ßu l√† API, tr·∫£ v·ªÅ JSON
            if (context.Request.Headers["Accept"].ToString().Contains("application/json"))
            {
                var result = JsonSerializer.Serialize(new { error = message });
                return context.Response.WriteAsync(result);
            }
            
            // Khi y√™u c·∫ßu l√† t·ª´ tr√¨nh duy·ªát, chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang l·ªói
            context.Response.Redirect($"/Home/Error?message={WebUtility.UrlEncode(message)}");
            return Task.CompletedTask;
        }
    }
}

```

### NCM3\Middleware\GlobalExceptionHandlerMiddlewareExtensions.cs
```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

namespace NCM3.Middleware
{
    // Extension method ƒë·ªÉ th√™m middleware n√†y m·ªôt c√°ch d·ªÖ d√†ng
    public static class GlobalExceptionHandlerMiddlewareExtensions
    {
        public static IApplicationBuilder UseGlobalExceptionHandler(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<GlobalExceptionHandlerMiddleware>();
        }
    }
}

```

### NCM3\Migrations\20250516021914_InitialCreate.cs
```cs
Ôªøusing System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Routers",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Hostname = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    IpAddress = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Username = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Password = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Model = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    OSVersion = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    LastBackup = table.Column<DateTime>(type: "datetime2", nullable: true),
                    Status = table.Column<string>(type: "nvarchar(max)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Routers", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "RouterConfigurations",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    RouterId = table.Column<int>(type: "int", nullable: false),
                    BackupDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Version = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    BackupBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RouterConfigurations", x => x.Id);
                    table.ForeignKey(
                        name: "FK_RouterConfigurations_Routers_RouterId",
                        column: x => x.RouterId,
                        principalTable: "Routers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_RouterConfigurations_RouterId",
                table: "RouterConfigurations",
                column: "RouterId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "RouterConfigurations");

            migrationBuilder.DropTable(
                name: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250516021914_InitialCreate.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250516021914_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250516140127_AddEnablePasswordColumn.cs
```cs
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddEnablePasswordColumn : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults");

            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults");

            migrationBuilder.AddColumn<string>(
                name: "EnablePassword",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId",
                principalTable: "RouterConfigurations",
                principalColumn: "Id");

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults",
                column: "RouterId",
                principalTable: "Routers",
                principalColumn: "Id");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults");

            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults");

            migrationBuilder.DropColumn(
                name: "EnablePassword",
                table: "Routers");

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId",
                principalTable: "RouterConfigurations",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults",
                column: "RouterId",
                principalTable: "Routers",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }
    }
}

```

### NCM3\Migrations\20250516142445_AddEnablePassword.cs
```cs
Ôªøusing System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddEnablePassword : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "EnablePassword",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.CreateTable(
                name: "ComplianceRules",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Pattern = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Severity = table.Column<int>(type: "int", nullable: false),
                    DeviceType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ExpectedResult = table.Column<bool>(type: "bit", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CreatedDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    IsActive = table.Column<bool>(type: "bit", nullable: false),
                    Notes = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ComplianceRules", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "ConfigTemplates",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    DeviceType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CreatedDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Version = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ConfigTemplates", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "ComplianceResults",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    RouterId = table.Column<int>(type: "int", nullable: false),
                    ConfigurationId = table.Column<int>(type: "int", nullable: false),
                    RuleId = table.Column<int>(type: "int", nullable: false),
                    Result = table.Column<bool>(type: "bit", nullable: false),
                    IsCompliant = table.Column<bool>(type: "bit", nullable: false),
                    LineNumber = table.Column<int>(type: "int", nullable: true),
                    MatchedContent = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CheckDate = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ComplianceResults", x => x.Id);
                    table.ForeignKey(
                        name: "FK_ComplianceResults_ComplianceRules_RuleId",
                        column: x => x.RuleId,
                        principalTable: "ComplianceRules",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                        column: x => x.ConfigurationId,
                        principalTable: "RouterConfigurations",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_ComplianceResults_Routers_RouterId",
                        column: x => x.RouterId,
                        principalTable: "Routers",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId");

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_RouterId",
                table: "ComplianceResults",
                column: "RouterId");

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_RuleId",
                table: "ComplianceResults",
                column: "RuleId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "ComplianceResults");

            migrationBuilder.DropTable(
                name: "ConfigTemplates");

            migrationBuilder.DropTable(
                name: "ComplianceRules");

            migrationBuilder.DropColumn(
                name: "EnablePassword",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250516142445_AddEnablePassword.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250516142445_AddEnablePassword")]
    partial class AddEnablePassword
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250520030802_AddRouterConfigurationsNavigation.cs
```cs
Ôªøusing Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddRouterConfigurationsNavigation : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}

```

### NCM3\Migrations\20250520030802_AddRouterConfigurationsNavigation.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250520030802_AddRouterConfigurationsNavigation")]
    partial class AddRouterConfigurationsNavigation
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250520085538_AddIsAvailableToRouter.cs
```cs
Ôªøusing Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddIsAvailableToRouter : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<bool>(
                name: "IsAvailable",
                table: "Routers",
                type: "bit",
                nullable: false,
                defaultValue: false);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "IsAvailable",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250520085538_AddIsAvailableToRouter.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250520085538_AddIsAvailableToRouter")]
    partial class AddIsAvailableToRouter
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250523025411_AddRouterGroup.cs
```cs
Ôªøusing Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddRouterGroup : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "Group",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Group",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250523025411_AddRouterGroup.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250523025411_AddRouterGroup")]
    partial class AddRouterGroup
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250524062658_AddBackupTypeAndCommentToRouterConfiguration.cs
```cs
Ôªøusing Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddBackupTypeAndCommentToRouterConfiguration : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "BackupType",
                table: "RouterConfigurations",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "Comment",
                table: "RouterConfigurations",
                type: "nvarchar(max)",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "BackupType",
                table: "RouterConfigurations");

            migrationBuilder.DropColumn(
                name: "Comment",
                table: "RouterConfigurations");
        }
    }
}

```

### NCM3\Migrations\20250524062658_AddBackupTypeAndCommentToRouterConfiguration.Designer.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250524062658_AddBackupTypeAndCommentToRouterConfiguration")]
    partial class AddBackupTypeAndCommentToRouterConfiguration
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("BackupType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Comment")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\NCMDbContextModelSnapshot.cs
```cs
Ôªø// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    partial class NCMDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("BackupType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Comment")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Models\AppSettings.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    /// <summary>
    /// C√†i ƒë·∫∑t chung c·ªßa ·ª©ng d·ª•ng
    /// </summary>
    public class AppSettings
    {
        public string BackupFolder { get; set; } = string.Empty;
        public string ConfigBackupFolder { get; set; } = string.Empty;
        public string LogFolder { get; set; } = string.Empty;
        public string TemplatePath { get; set; } = string.Empty;
        public string ComplianceRulesPath { get; set; } = string.Empty;
        public int MaxBackupsPerRouter { get; set; } = 10;
        public int AutoBackupIntervalHours { get; set; } = 24;
    }
    
    /// <summary>
    /// C√†i ƒë·∫∑t th√¥ng b√°o
    /// </summary>
    public class NotificationSettings
    {
        public bool EnableTelegram { get; set; }
        public string TelegramBotToken { get; set; } = string.Empty;
        public string TelegramChatId { get; set; } = string.Empty;
        public bool EnableWebhook { get; set; }
        public string WebhookUrl { get; set; } = string.Empty;
        public bool NotifyOnConfigChange { get; set; } = true;
        public bool NotifyOnComplianceIssue { get; set; } = true;
        public bool NotifyOnConnectivityChange { get; set; } = true;
    }
    
    /// <summary>
    /// C√†i ƒë·∫∑t t·ª± ƒë·ªông ph√°t hi·ªán thay ƒë·ªïi
    /// </summary>
    public class AutoDetectionSettings
    {
        public bool EnableAutoDetection { get; set; }
        
        [Range(5, 1440, ErrorMessage = "Kho·∫£ng th·ªùi gian ki·ªÉm tra ph·∫£i t·ª´ 5 ƒë·∫øn 1440 ph√∫t")]
        public int CheckIntervalMinutes { get; set; } = 30;
        
        public bool DetectConfigChanges { get; set; } = true;
        public bool DetectConnectivityChanges { get; set; } = true;
        public bool DetectComplianceIssues { get; set; } = true;
    }
    
    /// <summary>
    /// View model cho trang c√†i ƒë·∫∑t
    /// </summary>
    public class SettingsViewModel
    {
        public NotificationSettings NotificationSettings { get; set; } = new NotificationSettings();
        public AutoDetectionSettings AutoDetectionSettings { get; set; } = new AutoDetectionSettings();
        public bool DetectionServiceRunning { get; set; }
        public bool TelegramEnabled { get; set; }
        public string? TestResult { get; set; }
        public bool TestSuccessful { get; set; }
    }
}

```

### NCM3\Models\ChangeDetectionSettings.cs
```cs

```

### NCM3\Models\ComplianceResult.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace NCM3.Models
{
    public class ComplianceResult
    {
        public int Id { get; set; }
        
        [Required]
        public int RouterId { get; set; }
        
        [Required]
        public int ConfigurationId { get; set; }
        
        [Required]
        public int RuleId { get; set; }
        
        [Required]
        [Display(Name = "K·∫øt qu·∫£")]
        public bool Result { get; set; }
        
        [Display(Name = "Tu√¢n th·ªß")]
        public bool IsCompliant { get; set; }
        
        [Display(Name = "D√≤ng")]
        public int? LineNumber { get; set; }
        
        [Display(Name = "N·ªôi dung")]
        public string? MatchedContent { get; set; }
        
        [Display(Name = "Ng√†y ki·ªÉm tra")]
        public DateTime CheckDate { get; set; } = DateTime.Now;
        
        // Navigation properties
        [ForeignKey("RouterId")]
        public virtual Router? Router { get; set; }
        
        [ForeignKey("ConfigurationId")]
        public virtual RouterConfiguration? Configuration { get; set; }
        
        [ForeignKey("RuleId")]
        public virtual ComplianceRule? Rule { get; set; }
    }
} 
```

### NCM3\Models\ComplianceRule.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class ComplianceRule
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "T√™n quy t·∫Øc")]
        public string Name { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Bi·ªÉu th·ª©c t√¨m ki·∫øm")]
        public string Pattern { get; set; } = string.Empty;
        
        [Display(Name = "M√¥ t·∫£")]
        public string? Description { get; set; }
        
        [Display(Name = "M·ª©c ƒë·ªô")]
        public ComplianceSeverity Severity { get; set; } = ComplianceSeverity.Warning;
        
        [Display(Name = "Lo·∫°i thi·∫øt b·ªã")]
        public string? DeviceType { get; set; }
        
        [Display(Name = "K·∫øt qu·∫£ mong ƒë·ª£i")]
        public bool ExpectedResult { get; set; } = true;
        
        [Display(Name = "Ng∆∞·ªùi t·∫°o")]
        public string? CreatedBy { get; set; }
        
        [Display(Name = "Ng√†y t·∫°o")]
        public DateTime CreatedDate { get; set; } = DateTime.Now;
        
        [Display(Name = "K√≠ch ho·∫°t")]
        public bool IsActive { get; set; } = true;
        
        [Display(Name = "Ghi ch√∫")]
        public string? Notes { get; set; }
    }
    
    public enum ComplianceSeverity
    {
        [Display(Name = "Th√¥ng tin")]
        Info = 0,
        
        [Display(Name = "C·∫£nh b√°o")]
        Warning = 1,
        
        [Display(Name = "Nghi√™m tr·ªçng")]
        Critical = 2
    }
} 
```

### NCM3\Models\ConfigTemplate.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class ConfigTemplate
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "T√™n Template")]
        public string Name { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "N·ªôi dung")]
        public string Content { get; set; } = string.Empty;
        
        [Display(Name = "M√¥ t·∫£")]
        public string? Description { get; set; }
        
        [Display(Name = "Lo·∫°i thi·∫øt b·ªã")]
        public string? DeviceType { get; set; }
        
        [Display(Name = "Ng√†y t·∫°o")]
        public DateTime CreatedDate { get; set; } = DateTime.Now;
        
        [Display(Name = "Ng∆∞·ªùi t·∫°o")]
        public string? CreatedBy { get; set; }
        
        [Display(Name = "Phi√™n b·∫£n")]
        public string? Version { get; set; }
    }
} 
```

### NCM3\Models\ErrorViewModel.cs
```cs
namespace NCM3.Models
{
    public class ErrorViewModel
    {
        public string? RequestId { get; set; }

        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);
    }
}

```

### NCM3\Models\NCMDbContext.cs
```cs
using Microsoft.EntityFrameworkCore;

namespace NCM3.Models
{
    public class NCMDbContext : DbContext
    {
        public NCMDbContext(DbContextOptions<NCMDbContext> options) : base(options)
        {
        }
        
        public DbSet<Router> Routers { get; set; } = null!;
        public DbSet<RouterConfiguration> RouterConfigurations { get; set; } = null!;
        public DbSet<ConfigTemplate> ConfigTemplates { get; set; } = null!;
        public DbSet<ComplianceRule> ComplianceRules { get; set; } = null!;
        public DbSet<ComplianceResult> ComplianceResults { get; set; } = null!;
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // C·∫•u h√¨nh cascade delete behavior
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Router)
                .WithMany()
                .HasForeignKey(c => c.RouterId)
                .OnDelete(DeleteBehavior.NoAction);
                
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Configuration)
                .WithMany()
                .HasForeignKey(c => c.ConfigurationId)
                .OnDelete(DeleteBehavior.NoAction);
                
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Rule)
                .WithMany()
                .HasForeignKey(c => c.RuleId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
} 
```

### NCM3\Models\Router.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class Router
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "Hostname")]
        public string Hostname { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "IP Address")]
        public string IpAddress { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Username")]
        public string Username { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Password")]
        [DataType(DataType.Password)]
        public string Password { get; set; } = string.Empty;
        
        [Display(Name = "Enable Password")]
        [DataType(DataType.Password)]
        public string? EnablePassword { get; set; }
        
        [Display(Name = "Model")]
        public string? Model { get; set; }
        
        [Display(Name = "OS Version")]
        public string? OSVersion { get; set; }
        
        [Display(Name = "Last Configuration Backup")]
        public DateTime? LastBackup { get; set; }
        
        [Display(Name = "Status")]
        public string Status { get; set; } = "Unknown";
        
        [Display(Name = "Available")]
        public bool IsAvailable { get; set; } = false;
        
        [Display(Name = "Group")]
        public string? Group { get; set; }

        // Navigation property
        public virtual ICollection<RouterConfiguration> RouterConfigurations { get; set; } = new List<RouterConfiguration>();
    }
} 
```

### NCM3\Models\RouterConfiguration.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class RouterConfiguration
    {
        public int Id { get; set; }
        
        [Required]
        public int RouterId { get; set; }
        
        [Required]
        public DateTime BackupDate { get; set; }
        
        [Required]
        [Display(Name = "Configuration Content")]
        public string Content { get; set; } = string.Empty;
        
        [Display(Name = "Version/Label")]
        public string? Version { get; set; }        
        [Display(Name = "Backup By")]
        public string? BackupBy { get; set; }
        
        [Display(Name = "Backup Type")]
        public string? BackupType { get; set; }
        
        [Display(Name = "Comment")]
        public string? Comment { get; set; }
        
        // Navigation property
        public virtual Router? Router { get; set; }
    }
} 
```

### NCM3\Models\ViewModels\NotificationHistoryViewModel.cs
```cs
using System;
using System.Collections.Generic;

namespace NCM3.Models.ViewModels
{
    public class NotificationLogEntry
    {
        public string Type { get; set; } = string.Empty;
        public string Router { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool Success { get; set; }
        public string Details { get; set; } = string.Empty;
        public string AdditionalInfo { get; set; } = string.Empty;
    }

    public class NotificationHistoryViewModel
    {
        public List<NotificationLogEntry> RecentNotifications { get; set; } = new List<NotificationLogEntry>();
        public int TotalCount { get; set; }
        public string CurrentFilter { get; set; } = "all";
        public int Page { get; set; } = 1;
        public int PageSize { get; set; } = 20;
        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    }
}

```

### NCM3\Services\AmazonS3Service.cs
```cs

```

### NCM3\Services\AutomaticConfigurationChangeDetector.cs
```cs
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Constants;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class AutomaticConfigurationChangeDetector : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<AutomaticConfigurationChangeDetector> _logger;
        private readonly IConfiguration _configuration;
        
        // Kho·∫£ng th·ªùi gian ki·ªÉm tra m·∫∑c ƒë·ªãnh: 30 ph√∫t
        private TimeSpan _checkInterval = TimeSpan.FromMinutes(30);
        
        public AutomaticConfigurationChangeDetector(
            IServiceProvider serviceProvider,
            ILogger<AutomaticConfigurationChangeDetector> logger,
            IConfiguration configuration)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
            _configuration = configuration;
            
            // C·∫≠p nh·∫≠t _checkInterval t·ª´ c·∫•u h√¨nh
            if (int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int minutes) && minutes >= 5)
            {
                _checkInterval = TimeSpan.FromMinutes(minutes);
            }
        }        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("D·ªãch v·ª• AutomaticConfigurationChangeDetector ƒë√£ kh·ªüi ƒë·ªông.");
            
            while (!stoppingToken.IsCancellationRequested)
            {
                // Ki·ªÉm tra xem d·ªãch v·ª• c√≥ ƒë∆∞·ª£c b·∫≠t hay kh√¥ng
                bool enabled = false;
                if (bool.TryParse(_configuration["AutoDetection:Enabled"], out bool isEnabled))
                {
                    enabled = isEnabled;
                }
                
                // C·∫≠p nh·∫≠t _checkInterval t·ª´ c·∫•u h√¨nh
                if (int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int minutes) && minutes >= 5)
                {
                    _checkInterval = TimeSpan.FromMinutes(minutes);
                }
                
                if (enabled)
                {
                    _logger.LogInformation("ƒêang th·ª±c hi·ªán ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh. S·∫Ω ki·ªÉm tra l·∫°i sau {Interval} ph√∫t.",
                        _checkInterval.TotalMinutes);
                    
                    try
                    {
                        var startTime = DateTime.Now;
                        int changesDetected = await CheckForConfigurationChangesAsync();
                        var duration = DateTime.Now - startTime;
                        
                        _logger.LogInformation(
                            "Ho√†n th√†nh ki·ªÉm tra thay ƒë·ªïi, ph√°t hi·ªán {ChangesCount} thay ƒë·ªïi, th·ªùi gian x·ª≠ l√Ω: {Duration:hh\\:mm\\:ss}",
                            changesDetected,
                            duration);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "L·ªói trong qu√° tr√¨nh ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh t·ª± ƒë·ªông");
                    }
                }
                else
                {
                    _logger.LogDebug("D·ªãch v·ª• t·ª± ƒë·ªông ph√°t hi·ªán thay ƒë·ªïi ƒëang t·∫Øt. S·∫Ω ki·ªÉm tra l·∫°i sau {Interval} ph√∫t.",
                        _checkInterval.TotalMinutes);
                }
                
                // ƒê·ª£i ƒë·∫øn l·∫ßn ki·ªÉm tra ti·∫øp theo
                await Task.Delay(_checkInterval, stoppingToken);
            }
        }        private async Task<int> CheckForConfigurationChangesAsync()
        {
            _logger.LogInformation("B·∫Øt ƒë·∫ßu ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh t·ª± ƒë·ªông...");
            int changesDetected = 0;
            
            // Ki·ªÉm tra lo·∫°i ph√°t hi·ªán ƒë∆∞·ª£c b·∫≠t
            bool detectConfigChanges = true;
            bool detectConnectivityChanges = true;
            bool detectComplianceIssues = true;
            
            if (_configuration["AutoDetection:DetectConfigChanges"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectConfigChanges"], out detectConfigChanges);
            }
            
            if (_configuration["AutoDetection:DetectConnectivityChanges"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectConnectivityChanges"], out detectConnectivityChanges);
            }
            
            if (_configuration["AutoDetection:DetectComplianceIssues"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectComplianceIssues"], out detectComplianceIssues);
            }
              using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            var routerService = scope.ServiceProvider.GetRequiredService<RouterService>();
            var connectionService = scope.ServiceProvider.GetRequiredService<RouterConnectionService>();
            var notificationHelper = scope.ServiceProvider.GetRequiredService<NotificationHelper>();
            
            // L·∫•y danh s√°ch router c·∫ßn ki·ªÉm tra
            var routers = await dbContext.Routers
                .Include(r => r.RouterConfigurations)
                .ToListAsync();
                
            _logger.LogInformation("T√¨m th·∫•y {Count} router ƒë·ªÉ ki·ªÉm tra", routers.Count);
            
            foreach (var router in routers)
            {
                try
                {                    // Ki·ªÉm tra k·∫øt n·ªëi n·∫øu ƒë∆∞·ª£c b·∫≠t
                    if (detectConnectivityChanges)
                    {
                        bool isConnected = await connectionService.TestConnectionAsync(router);
                        if (!isConnected)
                        {
                            _logger.LogWarning("Router {RouterName} kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c", router.Hostname);
                            
                            // G·ª≠i th√¥ng b√°o n·∫øu c·∫•u h√¨nh k·∫øt n·ªëi thay ƒë·ªïi                            if (router.IsAvailable) // N·∫øu tr∆∞·ªõc ƒë√≥ v·∫´n ƒëang k·∫øt n·ªëi ƒë∆∞·ª£c
                            {
                                var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                                await telegramService.SendConnectivityAlertAsync(
                                    router.Hostname,
                                    "M·∫•t k·∫øt n·ªëi",
                                    $"Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn router t·∫°i th·ªùi ƒëi·ªÉm {DateTime.Now:dd/MM/yyyy HH:mm:ss}"
                                );
                                changesDetected++;
                            }
                        }
                        else if (!router.IsAvailable) // N·∫øu tr∆∞·ªõc ƒë√≥ kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c, nh∆∞ng gi·ªù ƒë√£ k·∫øt n·ªëi ƒë∆∞·ª£c
                        {
                            _logger.LogInformation("Router {RouterName} ƒë√£ kh√¥i ph·ª•c k·∫øt n·ªëi", router.Hostname);
                              var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                            await telegramService.SendConnectivityAlertAsync(
                                router.Hostname,
                                "ƒê√£ kh√¥i ph·ª•c k·∫øt n·ªëi",
                                $"K·∫øt n·ªëi ƒë·∫øn router ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c t·∫°i th·ªùi ƒëi·ªÉm {DateTime.Now:dd/MM/yyyy HH:mm:ss}"
                            );
                            changesDetected++;
                        }
                        
                        // C·∫≠p nh·∫≠t tr·∫°ng th√°i k·∫øt n·ªëi
                        router.IsAvailable = isConnected;
                        await dbContext.SaveChangesAsync();
                    }
                    
                    // Ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh n·∫øu ƒë∆∞·ª£c b·∫≠t v√† router v·∫´n k·∫øt n·ªëi ƒë∆∞·ª£c
                    if (detectConfigChanges && router.IsAvailable)
                    {
                        // L·∫•y c·∫•u h√¨nh hi·ªán t·∫°i t·ª´ router 
                        var currentConfig = await routerService.GetConfigurationAsync(router);
                        
                        // T√¨m c·∫•u h√¨nh cu·ªëi c√πng trong database
                        var lastConfig = router.RouterConfigurations
                            .OrderByDescending(c => c.BackupDate)
                            .FirstOrDefault();
                            
                        // So s√°nh v√† ph√°t hi·ªán thay ƒë·ªïi
                        var hasChanges = lastConfig == null || lastConfig.Content != currentConfig;
                        
                        if (hasChanges)
                        {
                            _logger.LogInformation("Ph√°t hi·ªán thay ƒë·ªïi c·∫•u h√¨nh tr√™n router {RouterName}", router.Hostname);
                              // L∆∞u c·∫•u h√¨nh m·ªõi
                            var newConfig = new RouterConfiguration
                            {
                                RouterId = router.Id,
                                BackupDate = DateTime.UtcNow,
                                Content = currentConfig,
                                Version = $"Auto_{DateTime.UtcNow:yyyyMMdd_HHmmss}",
                                BackupBy = "AutoDetector",
                                BackupType = BackupTypes.Automatic
                            };
                            
                            dbContext.RouterConfigurations.Add(newConfig);
                            router.LastBackup = newConfig.BackupDate;
                            await dbContext.SaveChangesAsync();
                            
                            // T·∫£i l√™n S3 n·∫øu t√≠nh nƒÉng ƒë∆∞·ª£c k√≠ch ho·∫°t
                            bool enableS3Backup = _configuration.GetValue<bool>("AWS:S3:EnableS3Backup", false);
                            bool backupToS3OnChange = _configuration.GetValue<bool>("AWS:S3:BackupToS3OnChange", false);
                            
                            if (enableS3Backup && backupToS3OnChange)
                            {
                                var s3Service = scope.ServiceProvider.GetRequiredService<IS3BackupService>();
                                try
                                {
                                    // Corrected arguments for UploadBackupAsync
                                    bool s3UploadSuccess = await s3Service.UploadBackupAsync(router.Id, currentConfig, newConfig.Version, BackupTypes.Automatic);
                                    if (s3UploadSuccess)
                                    {
                                        _logger.LogInformation($"ƒê√£ t·∫£i b·∫£n sao l∆∞u t·ª± ƒë·ªông {newConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                                        // Optionally, store S3 key or identifier if the UploadBackupAsync method is modified to return it.
                                        // For now, it returns bool. If you need the key, S3BackupService.UploadBackupAsync must be changed.
                                    }
                                    else
                                    {
                                        _logger.LogWarning($"Kh√¥ng t·∫£i ƒë∆∞·ª£c b·∫£n sao l∆∞u t·ª± ƒë·ªông {newConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogError(ex, $"L·ªói khi t·∫£i b·∫£n sao l∆∞u t·ª± ƒë·ªông {newConfig.Version} c·ªßa router {router.Hostname} l√™n S3.");
                                }
                            }
                            
                            // G·ª≠i th√¥ng b√°o
                            await notificationHelper.SendConfigurationChangeNotificationAsync(
                                router.Hostname,
                                "Ph√°t hi·ªán thay ƒë·ªïi t·ª± ƒë·ªông",
                                lastConfig?.Content ?? string.Empty,
                                currentConfig
                            );
                            
                            // TƒÉng b·ªô ƒë·∫øm thay ƒë·ªïi
                            changesDetected++;
                        }
                        else
                        {
                            _logger.LogDebug("Kh√¥ng c√≥ thay ƒë·ªïi c·∫•u h√¨nh tr√™n router {RouterName}", router.Hostname);
                        }
                    }
                    
                    // TODO: Ki·ªÉm tra tu√¢n th·ªß n·∫øu ƒë∆∞·ª£c b·∫≠t
                    if (detectComplianceIssues && router.IsAvailable)
                    {
                        // ƒêo·∫°n code ki·ªÉm tra tu√¢n th·ªß s·∫Ω ƒë∆∞·ª£c th√™m v√†o sau
                        _logger.LogDebug("Ki·ªÉm tra tu√¢n th·ªß ƒë·ªëi v·ªõi router {RouterName}", router.Hostname);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "L·ªói khi ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh cho router {RouterName}", router.Hostname);
                }
            }            _logger.LogInformation("Ho√†n th√†nh ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh t·ª± ƒë·ªông");
            return changesDetected;
        }
    }
}

```

### NCM3\Services\BackupNotificationHandler.cs
```cs

```

### NCM3\Services\BackupService.cs
```cs

```

### NCM3\Services\ChangeDetectionOrchestrator.cs
```cs

```

### NCM3\Services\ConfigurationManagementService.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using NCM3.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NCM3.Constants;

namespace NCM3.Services
{
    public class ConfigurationManagementService
    {
        private readonly NCMDbContext _context;
        private readonly IDiffer _differ;
        private readonly ISideBySideDiffBuilder _diffBuilder;
        private readonly ILogger<ConfigurationManagementService> _logger;
        private readonly ITelegramNotificationService _telegramService;
        private readonly Microsoft.Extensions.Configuration.IConfiguration _configuration;
        private NotificationHelper? _notificationHelper;

        public ConfigurationManagementService(
            NCMDbContext context,
            ILogger<ConfigurationManagementService> logger,
            ITelegramNotificationService telegramService,
            Microsoft.Extensions.Configuration.IConfiguration configuration)
        {
            _context = context;
            _differ = new Differ();
            _diffBuilder = new SideBySideDiffBuilder(_differ);
            _logger = logger;
            _telegramService = telegramService;
            _configuration = configuration;
        }
        
        // Thi·∫øt l·∫≠p NotificationHelper (ƒë·ªÉ tr√°nh l·ªói circular dependency)
        public void SetNotificationHelper(NotificationHelper notificationHelper)
        {
            _notificationHelper = notificationHelper;
        }
        
        // So s√°nh c·∫•u h√¨nh gi·ªØa c√°c phi√™n b·∫£n
        public async Task<SideBySideDiffModel> CompareConfigurationsAsync(int configId1, int configId2)
        {
            _logger.LogInformation("So s√°nh c·∫•u h√¨nh gi·ªØa ID {ConfigId1} v√† ID {ConfigId2}", configId1, configId2);
            
            var config1 = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId1);
            var config2 = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId2);
            
            if (config1 == null || config2 == null)
            {
                _logger.LogWarning("Kh√¥ng t√¨m th·∫•y m·ªôt trong c√°c c·∫•u h√¨nh ƒë·ªÉ so s√°nh. ConfigId1: {ConfigId1}, ConfigId2: {ConfigId2}", 
                    configId1, configId2);
                return new SideBySideDiffModel();
            }
            
            // Ensure content is not null
            string content1 = config1.Content ?? string.Empty;
            string content2 = config2.Content ?? string.Empty;
            
            var diff = _diffBuilder.BuildDiffModel(content1, content2);
            return diff;
        }
        
        // So s√°nh c·∫•u h√¨nh hi·ªán t·∫°i v·ªõi template
        public async Task<SideBySideDiffModel> CompareWithTemplateAsync(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId);
            var template = await _context.ConfigTemplates.FirstOrDefaultAsync(t => t.Id == templateId);
            
            if (config == null || template == null)
            {
                return new SideBySideDiffModel();
            }
            
            var diff = _diffBuilder.BuildDiffModel(template.Content, config.Content);
            return diff;
        }
        
        // T√¨m ki·∫øm trong c·∫•u h√¨nh
        public async Task<List<SearchResult>> SearchInConfigurationsAsync(string searchTerm, int? routerId = null)
        {
            var results = new List<SearchResult>();
            
            try
            {
                IQueryable<RouterConfiguration> query = _context.RouterConfigurations
                    .Include(c => c.Router);
                
                if (routerId.HasValue)
                {
                    query = query.Where(c => c.RouterId == routerId.Value);
                }
                
                var configurations = await query.ToListAsync();
                
                foreach (var config in configurations)
                {
                    var matches = SearchInConfig(config.Content, searchTerm);
                    
                    if (matches.Any())
                    {
                        string routerName = "Unknown";
                        if (config.Router != null)
                        {
                            routerName = config.Router.Hostname;
                        }
                        
                        results.Add(new SearchResult
                        {
                            RouterId = config.RouterId,
                            RouterName = routerName,
                            ConfigId = config.Id,
                            BackupDate = config.BackupDate,
                            Version = config.Version,
                            Matches = matches
                        });
                    }
                }
            }
            catch (Exception)
            {
                // X·ª≠ l√Ω ngo·∫°i l·ªá
            }
            
            return results;
        }

        private List<Match> SearchInConfig(string content, string searchTerm)
        {
            List<Match> matches = new List<Match>();
            
            try
            {
                Regex regex = new Regex(searchTerm, RegexOptions.IgnoreCase | RegexOptions.Multiline);
                var lines = content.Split('\n');
                
                for (int i = 0; i < lines.Length; i++)
                {
                    var line = lines[i];
                    var regexMatches = regex.Matches(line);
                    
                    if (regexMatches.Count > 0)
                    {
                        matches.Add(new Match
                        {
                            LineNumber = i + 1,
                            LineContent = line,
                            MatchCount = regexMatches.Count
                        });
                    }
                }
            }
            catch (Exception)
            {
                // X·ª≠ l√Ω ngo·∫°i l·ªá
            }
            
            return matches;
        }
        
        // Ki·ªÉm tra tu√¢n th·ªß
        public async Task<List<ComplianceResult>> CheckComplianceAsync(int configId)
        {
            var results = new List<ComplianceResult>();
            
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
            
            if (config == null)
            {
                return results;
            }
            
            var rules = await _context.ComplianceRules.ToListAsync();
            
            // L·ªçc c√°c quy t·∫Øc ph√π h·ª£p v·ªõi lo·∫°i thi·∫øt b·ªã
            var filteredRules = rules.Where(r => r.IsActive && 
                (string.IsNullOrEmpty(r.DeviceType) || 
                 (config.Router != null && r.DeviceType == config.Router.Model))).ToList();
            
            foreach (var rule in filteredRules)
            {
                var complianceResult = new ComplianceResult
                {
                    RouterId = config.RouterId,
                    ConfigurationId = config.Id,
                    RuleId = rule.Id,
                    CheckDate = DateTime.Now
                };
                
                try
                {
                    bool patternFound = false;
                    string? matchedContent = null;
                    int? lineNumber = null;
                    
                    // T√¨m pattern trong c·∫•u h√¨nh
                    var regex = new Regex(rule.Pattern, RegexOptions.IgnoreCase | RegexOptions.Multiline);
                    var match = regex.Match(config.Content);
                    
                    if (match.Success)
                    {
                        patternFound = true;
                        matchedContent = match.Value;
                        
                        // T√≠nh s·ªë d√≤ng
                        var textBeforeMatch = config.Content.Substring(0, match.Index);
                        lineNumber = textBeforeMatch.Count(c => c == '\n') + 1;
                    }
                    
                    complianceResult.Result = patternFound;
                    complianceResult.IsCompliant = (patternFound == rule.ExpectedResult);
                    complianceResult.MatchedContent = matchedContent;
                    complianceResult.LineNumber = lineNumber;
                }
                catch (Exception)
                {
                    complianceResult.Result = false;
                    complianceResult.IsCompliant = false;
                }
                
                results.Add(complianceResult);
            }
            
            return results;
        }

        public async Task<RouterConfiguration> SaveConfigurationAsync(int routerId, string configText)
        {
            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == routerId);

            if (router == null)
            {
                throw new ArgumentException("Router not found");
            }

            var lastConfig = router.RouterConfigurations.OrderByDescending(c => c.BackupDate).FirstOrDefault();
            var hasChanges = lastConfig == null || lastConfig.Content != configText;

            if (hasChanges)
            {
                var newConfig = new RouterConfiguration
                {
                    RouterId = routerId,
                    Content = configText,
                    BackupDate = DateTime.UtcNow,
                    Version = lastConfig != null 
                        ? $"v{int.Parse(lastConfig.Version?.Replace("v", "") ?? "0") + 1}"
                        : "v1"
                };

                _context.RouterConfigurations.Add(newConfig);
                await _context.SaveChangesAsync();

                // S·ª≠ d·ª•ng NotificationHelper n·∫øu ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p
                if (_notificationHelper != null)
                {
                    await _notificationHelper.SendConfigurationChangeNotificationAsync(
                        router.Hostname,
                        lastConfig != null ? "C·∫≠p nh·∫≠t c·∫•u h√¨nh" : "T·∫°o c·∫•u h√¨nh m·ªõi",
                        lastConfig?.Content ?? string.Empty,
                        configText
                    );
                }
                else
                {
                    // S·ª≠ d·ª•ng c√°ch c≈© n·∫øu ch∆∞a thi·∫øt l·∫≠p NotificationHelper
                    var diffDetails = lastConfig != null 
                        ? await GetDiffDetailsAsync(lastConfig.Content, configText)
                        : "C·∫•u h√¨nh m·ªõi ƒë∆∞·ª£c t·∫°o";

                    await _telegramService.SendConfigChangeNotificationAsync(
                        router.Hostname,
                        lastConfig != null ? "C·∫≠p nh·∫≠t c·∫•u h√¨nh" : "T·∫°o c·∫•u h√¨nh m·ªõi",
                        diffDetails
                    );
                }

                return newConfig;
            }

            return lastConfig;
        }

        private Task<string> GetDiffDetailsAsync(string oldConfig, string newConfig)
        {
            var diffBuilder = new InlineDiffBuilder(new Differ());
            var diff = diffBuilder.BuildDiffModel(oldConfig, newConfig);

            // Get the maximum number of diff lines from configuration
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            // Make sure we have a reasonable value
            maxDiffLines = Math.Max(5, maxDiffLines);

            // Get changes by type
            var deletedLines = diff.Lines.Where(l => l.Type == ChangeType.Deleted).ToList();
            var insertedLines = diff.Lines.Where(l => l.Type == ChangeType.Inserted).ToList();
            
            // Count total changes
            int totalChanges = deletedLines.Count + insertedLines.Count;
            
            var changes = new StringBuilder();
            changes.AppendLine($"T·ªïng thay ƒë·ªïi: {totalChanges} d√≤ng ({deletedLines.Count} x√≥a, {insertedLines.Count} th√™m)");
            
            // Limit how many lines we show of each type
            int deletedToShow = Math.Min(deletedLines.Count, maxDiffLines / 2);
            int insertedToShow = Math.Min(insertedLines.Count, maxDiffLines / 2);
            
            // If one type has fewer changes, allow the other type to use more of the quota
            if (deletedToShow < maxDiffLines / 2)
            {
                insertedToShow = Math.Min(insertedLines.Count, maxDiffLines - deletedToShow);
            }
            else if (insertedToShow < maxDiffLines / 2)
            {
                deletedToShow = Math.Min(deletedLines.Count, maxDiffLines - insertedToShow);
            }
            
            // Show deleted lines first
            if (deletedLines.Any())
            {
                changes.AppendLine("\nN·ªôi dung b·ªã x√≥a:");
                foreach (var line in deletedLines.Take(deletedToShow))
                {
                    changes.AppendLine($"- {line.Text}");
                }
                
                if (deletedLines.Count > deletedToShow)
                {
                    changes.AppendLine($"- ... v√† {deletedLines.Count - deletedToShow} d√≤ng x√≥a kh√°c...");
                }
            }
            
            // Then show inserted lines
            if (insertedLines.Any())
            {
                changes.AppendLine("\nN·ªôi dung m·ªõi th√™m v√†o:");
                foreach (var line in insertedLines.Take(insertedToShow))
                {
                    changes.AppendLine($"+ {line.Text}");
                }
                
                if (insertedLines.Count > insertedToShow)
                {
                    changes.AppendLine($"+ ... v√† {insertedLines.Count - insertedToShow} d√≤ng th√™m kh√°c...");
                }
            }

            return Task.FromResult(changes.ToString());
        }
        
        // Th√™m ph∆∞∆°ng th·ª©c c√¥ng khai ƒë·ªÉ so s√°nh c·∫•u h√¨nh t·ª´ b√™n ngo√†i
        public Task<string> GetConfigurationDiffAsync(string oldConfig, string newConfig)
        {
            return GetDiffDetailsAsync(oldConfig, newConfig);
        }
    }

    // L·ªõp k·∫øt qu·∫£ t√¨m ki·∫øm
    public class SearchResult
    {
        public int RouterId { get; set; }
        public string RouterName { get; set; } = string.Empty;
        public int ConfigId { get; set; }
        public DateTime BackupDate { get; set; }
        public string? Version { get; set; }
        public List<Match> Matches { get; set; } = new List<Match>();
    }

    public class Match
    {
        public int LineNumber { get; set; }
        public string LineContent { get; set; } = string.Empty;
        public int MatchCount { get; set; }
    }
} 
```

### NCM3\Services\EncryptionService.cs
```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public interface IEncryptionService
    {
        string Encrypt(string text);
        string Decrypt(string cipherText);
    }

    public class EncryptionService : IEncryptionService
    {
        private readonly byte[] _key;
        private readonly byte[] _iv;

        public EncryptionService(IConfiguration configuration)
        {
            var encryptionKey = configuration["EncryptionKey"];
            
            if (string.IsNullOrEmpty(encryptionKey))
            {
                throw new InvalidOperationException("Encryption key is not configured. Please add an EncryptionKey in appsettings.json");
            }

            // S·ª≠ d·ª•ng key t·ª´ c·∫•u h√¨nh ho·∫∑c t·∫°o key c·ªë ƒë·ªãnh t·ª´ chu·ªói
            using (var deriveBytes = new Rfc2898DeriveBytes(encryptionKey, Encoding.UTF8.GetBytes("NCM3Salt"), 1000))
            {
                _key = deriveBytes.GetBytes(32); // 256 bits
                _iv = deriveBytes.GetBytes(16);  // 128 bits
            }
        }

        public string Encrypt(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            using (Aes aes = Aes.Create())
            {
                aes.Key = _key;
                aes.IV = _iv;

                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter sw = new StreamWriter(cs))
                        {
                            sw.Write(text);
                        }
                    }
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }

        public string Decrypt(string cipherText)
        {
            if (string.IsNullOrEmpty(cipherText))
                return cipherText;

            try
            {
                byte[] buffer = Convert.FromBase64String(cipherText);

                using (Aes aes = Aes.Create())
                {
                    aes.Key = _key;
                    aes.IV = _iv;

                    ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                    using (MemoryStream ms = new MemoryStream(buffer))
                    {
                        using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                        {
                            using (StreamReader sr = new StreamReader(cs))
                            {
                                return sr.ReadToEnd();
                            }
                        }
                    }
                }
            }
            catch
            {
                // N·∫øu kh√¥ng th·ªÉ gi·∫£i m√£ (c√≥ th·ªÉ l√† d·ªØ li·ªáu kh√¥ng ƒë∆∞·ª£c m√£ h√≥a)
                return cipherText;
            }
        }
    }
}

```

### NCM3\Services\NotificationHelper.cs
```cs
using System;
using System.Threading.Tasks;
using NCM3.Models;
using NCM3.Services;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class NotificationHelper
    {        private readonly ITelegramNotificationService _telegramService;
        private readonly ConfigurationManagementService _configService;
        private readonly ILogger<NotificationHelper> _logger;
        private readonly IConfiguration _configuration;
        private readonly IWebhookNotificationService? _webhookService;
        private readonly NotificationLogger? _notificationLogger;
        
        public NotificationHelper(
            ITelegramNotificationService telegramService,
            ConfigurationManagementService configService,
            ILogger<NotificationHelper> logger,
            IConfiguration configuration,
            IWebhookNotificationService? webhookService = null,
            NotificationLogger? notificationLogger = null)
        {
            _telegramService = telegramService;
            _configService = configService;
            _logger = logger;
            _configuration = configuration;
            _webhookService = webhookService;
            _notificationLogger = notificationLogger;
        }
          /// <summary>
        /// G·ª≠i th√¥ng b√°o v·ªÅ s·ª± thay ƒë·ªïi c·∫•u h√¨nh
        /// </summary>
        /// <param name="routerName">T√™n router</param>
        /// <param name="changeType">Lo·∫°i thay ƒë·ªïi (C·∫≠p nh·∫≠t, Sao l∆∞u, ...)</param>
        /// <param name="oldConfig">C·∫•u h√¨nh c≈©</param>
        /// <param name="newConfig">C·∫•u h√¨nh m·ªõi</param>
        /// <returns>Task th·ª±c hi·ªán vi·ªác g·ª≠i th√¥ng b√°o</returns>
        public async Task SendConfigurationChangeNotificationAsync(
            string routerName, 
            string changeType, 
            string oldConfig, 
            string newConfig)
        {
            try
            {
                // T√¨m s·ª± kh√°c bi·ªát gi·ªØa c·∫•u h√¨nh c≈© v√† m·ªõi
                string diffDetails = string.IsNullOrEmpty(oldConfig)
                    ? "C·∫•u h√¨nh m·ªõi ƒë∆∞·ª£c t·∫°o"
                    : await _configService.GetConfigurationDiffAsync(oldConfig, newConfig);
                  // G·ª≠i th√¥ng b√°o qua Telegram n·∫øu ƒë∆∞·ª£c b·∫≠t
                bool telegramEnabled = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) &&
                                      !string.IsNullOrEmpty(_configuration["Telegram:ChatId"]);
                
                bool notifyOnConfigChange = true;
                if (_configuration["Notification:NotifyOnConfigChange"] != null)
                {
                    bool.TryParse(_configuration["Notification:NotifyOnConfigChange"], out notifyOnConfigChange);
                }
                
                if (telegramEnabled && notifyOnConfigChange)
                {
                    await _telegramService.SendConfigChangeNotificationAsync(
                        routerName,
                        changeType,
                        diffDetails
                    );
                }
                
                // G·ª≠i webhook n·∫øu ƒë∆∞·ª£c b·∫≠t
                bool webhookEnabled = _webhookService != null && 
                                     !string.IsNullOrEmpty(_configuration["Notification:WebhookUrl"]);
                
                bool enableWebhook = false;
                if (_configuration["Notification:EnableWebhook"] != null)
                {
                    bool.TryParse(_configuration["Notification:EnableWebhook"], out enableWebhook);
                }
                
                if (webhookEnabled && enableWebhook)
                {
                    var payload = new 
                    {
                        routerName,
                        changeType,
                        diffDetails,
                        timestamp = DateTime.UtcNow
                    };
                    
                    await _webhookService!.SendWebhookNotificationAsync("configuration_change", payload);
                }
                
                _logger.LogInformation(
                    "ƒê√£ g·ª≠i th√¥ng b√°o thay ƒë·ªïi c·∫•u h√¨nh cho router {RouterName}, lo·∫°i thay ƒë·ªïi: {ChangeType}",
                    routerName,
                    changeType);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi g·ª≠i th√¥ng b√°o thay ƒë·ªïi c·∫•u h√¨nh cho router {RouterName}: {Error}",
                    routerName,
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Ki·ªÉm tra s·ª± thay ƒë·ªïi c·∫•u h√¨nh v√† g·ª≠i th√¥ng b√°o n·∫øu c√≥ thay ƒë·ªïi
        /// </summary>
        /// <param name="routerId">ID c·ªßa router</param>
        /// <param name="newConfig">C·∫•u h√¨nh m·ªõi</param>
        /// <param name="changeType">Lo·∫°i thay ƒë·ªïi (m·∫∑c ƒë·ªãnh: C·∫≠p nh·∫≠t c·∫•u h√¨nh)</param>
        /// <returns>True n·∫øu c√≥ thay ƒë·ªïi v√† th√¥ng b√°o ƒë∆∞·ª£c g·ª≠i, False n·∫øu kh√¥ng c√≥ thay ƒë·ªïi</returns>
        public async Task<bool> DetectAndNotifyConfigurationChangeAsync(
            Router router,
            string newConfig,
            string changeType = "C·∫≠p nh·∫≠t c·∫•u h√¨nh")
        {
            if (router == null)
            {
                _logger.LogWarning("Kh√¥ng th·ªÉ ki·ªÉm tra thay ƒë·ªïi c·∫•u h√¨nh: router l√† null");
                return false;
            }
            
            // Ki·ªÉm tra c·∫•u h√¨nh m·ªõi c√≥ thay ƒë·ªïi so v·ªõi c·∫•u h√¨nh c≈© hay kh√¥ng
            var lastConfig = router.RouterConfigurations
                .OrderByDescending(c => c.BackupDate)
                .FirstOrDefault();
                
            var hasChanges = lastConfig == null || lastConfig.Content != newConfig;
            
            if (hasChanges)
            {
                string oldConfig = lastConfig?.Content ?? string.Empty;
                await SendConfigurationChangeNotificationAsync(
                    router.Hostname,
                    changeType,
                    oldConfig,
                    newConfig);
                return true;
            }
            
            return false;
        }
    }
}

```

### NCM3\Services\NotificationLogger.cs
```cs
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NCM3.Models;

namespace NCM3.Services
{
    /// <summary>
    /// D·ªãch v·ª• ghi log chi ti·∫øt cho ho·∫°t ƒë·ªông th√¥ng b√°o
    /// </summary>
    public class NotificationLogger
    {
        private readonly ILogger<NotificationLogger> _logger;
        private readonly IConfiguration _configuration;
        private readonly string _notificationLogPath;
        
        public NotificationLogger(
            ILogger<NotificationLogger> logger,
            IConfiguration configuration)
        {
            _logger = logger;
            _configuration = configuration;
            
            // T·∫°o th∆∞ m·ª•c log n·∫øu c·∫ßn
            var logFolder = _configuration["AppSettings:LogFolder"] ?? "Logs";
            _notificationLogPath = Path.Combine(logFolder, "notifications");
            
            if (!Directory.Exists(_notificationLogPath))
            {
                Directory.CreateDirectory(_notificationLogPath);
            }
        }
        
        /// <summary>
        /// Ghi log th√¥ng b√°o thay ƒë·ªïi c·∫•u h√¨nh
        /// </summary>
        /// <param name="routerName">T√™n router</param>
        /// <param name="changeType">Lo·∫°i thay ƒë·ªïi</param>
        /// <param name="details">Chi ti·∫øt thay ƒë·ªïi</param>
        /// <param name="success">Th√†nh c√¥ng hay th·∫•t b·∫°i</param>
        /// <returns>Task ghi log</returns>
        public async Task LogConfigurationChangeNotificationAsync(
            string routerName, 
            string changeType, 
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "ConfigurationChange",
                    Router = routerName,
                    ChangeType = changeType,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("config_changes", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "ƒê√£ g·ª≠i th√¥ng b√°o thay ƒë·ªïi c·∫•u h√¨nh cho router {RouterName}, lo·∫°i thay ƒë·ªïi: {ChangeType}",
                        routerName,
                        changeType);
                }
                else
                {
                    _logger.LogWarning(
                        "Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o thay ƒë·ªïi c·∫•u h√¨nh cho router {RouterName}, lo·∫°i thay ƒë·ªïi: {ChangeType}",
                        routerName,
                        changeType);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi ghi log th√¥ng b√°o: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Ghi log th√¥ng b√°o k·∫øt n·ªëi
        /// </summary>
        /// <param name="routerName">T√™n router</param>
        /// <param name="status">Tr·∫°ng th√°i k·∫øt n·ªëi</param>
        /// <param name="details">Chi ti·∫øt</param>
        /// <param name="success">Th√†nh c√¥ng hay th·∫•t b·∫°i</param>
        /// <returns>Task ghi log</returns>
        public async Task LogConnectivityNotificationAsync(
            string routerName, 
            string status, 
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "Connectivity",
                    Router = routerName,
                    Status = status,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("connectivity", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "ƒê√£ g·ª≠i th√¥ng b√°o k·∫øt n·ªëi cho router {RouterName}, tr·∫°ng th√°i: {Status}",
                        routerName,
                        status);
                }
                else
                {
                    _logger.LogWarning(
                        "Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o k·∫øt n·ªëi cho router {RouterName}, tr·∫°ng th√°i: {Status}",
                        routerName,
                        status);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi ghi log th√¥ng b√°o: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Ghi log th√¥ng b√°o tu√¢n th·ªß
        /// </summary>
        /// <param name="routerName">T√™n router</param>
        /// <param name="ruleName">T√™n quy t·∫Øc</param>
        /// <param name="severity">M·ª©c ƒë·ªô nghi√™m tr·ªçng</param>
        /// <param name="details">Chi ti·∫øt</param>
        /// <param name="success">Th√†nh c√¥ng hay th·∫•t b·∫°i</param>
        /// <returns>Task ghi log</returns>
        public async Task LogComplianceNotificationAsync(
            string routerName, 
            string ruleName, 
            string severity,
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "Compliance",
                    Router = routerName,
                    Rule = ruleName,
                    Severity = severity,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("compliance", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "ƒê√£ g·ª≠i th√¥ng b√°o tu√¢n th·ªß cho router {RouterName}, quy t·∫Øc: {RuleName}, m·ª©c ƒë·ªô: {Severity}",
                        routerName,
                        ruleName,
                        severity);
                }
                else
                {
                    _logger.LogWarning(
                        "Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o tu√¢n th·ªß cho router {RouterName}, quy t·∫Øc: {RuleName}, m·ª©c ƒë·ªô: {Severity}",
                        routerName,
                        ruleName,
                        severity);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi ghi log th√¥ng b√°o: {Error}",
                    ex.Message);
            }
        }
          private async Task WriteLogEntryAsync(string category, object logEntry)
        {
            try
            {
                string fileName = $"{DateTime.Now:yyyyMMdd}_{category}.log";
                string filePath = Path.Combine(_notificationLogPath, fileName);
                
                string logLine = JsonConvert.SerializeObject(logEntry) + Environment.NewLine;
                
                await File.AppendAllTextAsync(filePath, logLine, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi ghi log v√†o t·ªáp: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// L·∫•y l·ªãch s·ª≠ th√¥ng b√°o g·∫ßn ƒë√¢y
        /// </summary>
        /// <param name="filter">B·ªô l·ªçc: "all", "config", "connectivity", "compliance"</param>
        /// <param name="page">Trang hi·ªán t·∫°i, b·∫Øt ƒë·∫ßu t·ª´ 1</param>
        /// <param name="pageSize">K√≠ch th∆∞·ªõc trang</param>
        /// <returns>Danh s√°ch th√¥ng b√°o v√† th√¥ng tin ph√¢n trang</returns>
        public async Task<Models.ViewModels.NotificationHistoryViewModel> GetNotificationHistoryAsync(
            string filter = "all", 
            int page = 1, 
            int pageSize = 20)
        {
            var result = new Models.ViewModels.NotificationHistoryViewModel
            {
                CurrentFilter = filter,
                Page = page,
                PageSize = pageSize
            };
            
            try
            {
                var allLogs = new List<Models.ViewModels.NotificationLogEntry>();
                string[] filesToSearch = Directory.GetFiles(_notificationLogPath, "*.log")
                    .OrderByDescending(f => f)  // S·∫Øp x·∫øp theo th·ªùi gian t·∫°o gi·∫£m d·∫ßn
                    .Take(7)  // L·∫•y t·ªëi ƒëa log c·ªßa 7 ng√†y g·∫ßn ƒë√¢y
                    .ToArray();
                
                foreach (var file in filesToSearch)
                {
                    string fileName = Path.GetFileNameWithoutExtension(file);
                    
                    // B·ªè qua c√°c file kh√¥ng ph√π h·ª£p v·ªõi b·ªô l·ªçc
                    if (filter != "all")
                    {
                        if (filter == "config" && !fileName.Contains("config_changes")) continue;
                        if (filter == "connectivity" && !fileName.Contains("connectivity")) continue;
                        if (filter == "compliance" && !fileName.Contains("compliance")) continue;
                    }
                    
                    if (File.Exists(file))
                    {
                        var lines = await File.ReadAllLinesAsync(file);
                        foreach (var line in lines)
                        {
                            try
                            {
                                var entry = JsonConvert.DeserializeObject<dynamic>(line);
                                var logEntry = new Models.ViewModels.NotificationLogEntry
                                {
                                    Type = entry.Type.ToString(),
                                    Router = entry.Router.ToString(),
                                    Timestamp = (DateTime)entry.Timestamp,
                                    Success = (bool)entry.Success,
                                    Details = entry.Details.ToString()
                                };
                                
                                if (entry.Type.ToString() == "Compliance")
                                {
                                    logEntry.Status = entry.Severity.ToString();
                                    logEntry.AdditionalInfo = entry.Rule.ToString();
                                }
                                else if (entry.Type.ToString() == "Connectivity")
                                {
                                    logEntry.Status = entry.Status.ToString();
                                }
                                else if (entry.Type.ToString() == "ConfigurationChange")
                                {
                                    logEntry.Status = entry.ChangeType.ToString();
                                }
                                
                                allLogs.Add(logEntry);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(ex, "Kh√¥ng th·ªÉ ph√¢n t√≠ch log entry: {Line}", line);
                            }
                        }
                    }
                }
                
                // S·∫Øp x·∫øp theo th·ªùi gian gi·∫£m d·∫ßn
                var sortedLogs = allLogs
                    .OrderByDescending(l => l.Timestamp)
                    .ToList();
                
                result.TotalCount = sortedLogs.Count;
                
                // L·∫•y d·ªØ li·ªáu theo trang
                result.RecentNotifications = sortedLogs
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .ToList();
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "L·ªói khi l·∫•y l·ªãch s·ª≠ th√¥ng b√°o: {Error}", ex.Message);
                return result;
            }
        }
    }
}

```

### NCM3\Services\RouterConnectionService.cs
```cs
using System;
using System.Threading.Tasks;
using System.Net.Sockets;
using NCM3.Models;
using NCM3.Constants;
using Microsoft.Extensions.Logging;

namespace NCM3.Services
{
    public class RouterConnectionService
    {
        private readonly ILogger<RouterConnectionService> _logger;
        
        public RouterConnectionService(ILogger<RouterConnectionService> logger)
        {
            _logger = logger;
        }
        
        /// <summary>
        /// Ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn router
        /// </summary>
        /// <param name="router">Router c·∫ßn ki·ªÉm tra</param>
        /// <returns>True n·∫øu k·∫øt n·ªëi th√†nh c√¥ng, False n·∫øu kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c</returns>
        public async Task<bool> TestConnectionAsync(Router router)
        {
            if (router == null || string.IsNullOrEmpty(router.IpAddress))
            {
                _logger.LogWarning("Kh√¥ng th·ªÉ ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn router v·ªõi IP r·ªóng ho·∫∑c null");
                return false;
            }
            
            _logger.LogDebug("Ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn router {RouterName} ({IP})", 
                router.Hostname, router.IpAddress);
                
            // Ki·ªÉm tra k·∫øt n·ªëi TCP ƒë·∫øn c·ªïng SSH (m·∫∑c ƒë·ªãnh l√† 22)
            using (var tcpClient = new TcpClient())
            {
                try
                {
                    var connectTask = tcpClient.ConnectAsync(router.IpAddress, DefaultSettings.SSHPort);
                    if (await Task.WhenAny(connectTask, Task.Delay(3000)) == connectTask)
                    {
                        _logger.LogInformation("K·∫øt n·ªëi ƒë·∫øn router {RouterName} ({IP}) th√†nh c√¥ng", 
                            router.Hostname, router.IpAddress);
                        return true;
                    }
                    else
                    {
                        _logger.LogWarning("H·∫øt th·ªùi gian ch·ªù k·∫øt n·ªëi ƒë·∫øn router {RouterName} ({IP})", 
                            router.Hostname, router.IpAddress);
                        return false;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn router {RouterName} ({IP}): {Message}", 
                        router.Hostname, router.IpAddress, ex.Message);
                    return false;
                }
            }
        }
    }
}

```

### NCM3\Services\RouterService.cs
```cs
using System;
using System.Threading.Tasks;
using System.Text;
using System.IO;
using System.Net.Sockets;
using NCM3.Models;
using NCM3.Constants;
using Renci.SshNet;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class RouterService : IDisposable
    {
        private readonly IEncryptionService _encryptionService;
        private readonly NCMDbContext _context;
        private readonly ILogger<RouterService> _logger;
        private readonly IS3BackupService _s3Service;
        private readonly IConfiguration _configuration;
        private bool _disposed;

        public RouterService(
            IEncryptionService encryptionService, 
            NCMDbContext context, 
            ILogger<RouterService> logger,
            IS3BackupService s3Service,
            IConfiguration configuration)
        {
            _encryptionService = encryptionService;
            _context = context;
            _logger = logger;
            _s3Service = s3Service;
            _configuration = configuration;
        }

        public async Task<string> GetConfigurationAsync(Router router)
        {
            try
            {
                // Gi·∫£i m√£ m·∫≠t kh·∫©u tr∆∞·ªõc khi s·ª≠ d·ª•ng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;
                
                // Test if the router's SSH port is reachable before attempting connection
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, DefaultSettings.SSHPort);
                        if (await Task.WhenAny(connectTask, Task.Delay(3000)) != connectTask)
                        {
                            return $"Error: Cannot establish TCP connection to router SSH port ({DefaultSettings.SSHPort}). Check if the device is online and port {DefaultSettings.SSHPort} is accessible.";
                        }
                    }
                    catch (Exception ex)
                    {
                        return $"Error: TCP connection failed - {ex.Message}";
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                try
                {
                client.Connect();
                }
                catch (Exception ex)
                {
                    return $"Error: SSH connection failed - {ex.Message}";
                }
                
                if (client.IsConnected)
                {
                    try
                    {
                        ShellStream shellStream = client.CreateShellStream("vt100", 80, 24, 800, 600, 1024);
                        
                        // Wait for the initial prompt
                        await Task.Delay(2000);
                        
                        // Clear any initial text
                        shellStream.Read();
                        
                        // If enable password is provided, enter privileged mode
                        if (!string.IsNullOrEmpty(decryptedEnablePassword))
                        {
                            shellStream.WriteLine(SSHCommands.Enable);
                            await Task.Delay(1000);
                            shellStream.WriteLine(decryptedEnablePassword);
                            await Task.Delay(1000);
                        }
                        
                        // Execute the show running-config command
                        shellStream.WriteLine(SSHCommands.TerminalLength);
                        await Task.Delay(1000);
                        shellStream.WriteLine(SSHCommands.ShowRunningConfig);
                        await Task.Delay(5000); // Longer wait for configuration to load
                        
                        // Read the output
                        string output = shellStream.Read();
                        client.Disconnect();
                        return output;
                    }
                    catch (Exception ex)
                    {
                        return $"Error during SSH session: {ex.Message}";
                    }
                    finally
                    {
                        if (client.IsConnected)
                        {
                    client.Disconnect();
                        }
                    }
                }
                
                return "Failed to connect to the router.";
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }
        
        // Debug method to test connectivity with detailed logging
        public async Task<string> DebugSshConnectionAsync(Router router)
        {
            StringBuilder log = new StringBuilder();
            
            try
            {
                // Gi·∫£i m√£ m·∫≠t kh·∫©u tr∆∞·ªõc khi s·ª≠ d·ª•ng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;

                log.AppendLine($"[DEBUG] Attempting to connect to {router.IpAddress} with username {router.Username}");
                log.AppendLine($"[DEBUG] Enable password is {(string.IsNullOrEmpty(decryptedEnablePassword) ? "NOT SET" : "SET")}");
                log.AppendLine($"[DEBUG] Using SSH.NET library version: {typeof(Renci.SshNet.SshClient).Assembly.GetName().Version}");
                
                // Test if the port is even reachable
                log.AppendLine("[DEBUG] Testing TCP connectivity to port 22...");
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, 22);
                        if (await Task.WhenAny(connectTask, Task.Delay(5000)) != connectTask)
                        {
                            log.AppendLine("[DEBUG] ERROR: TCP connection timed out - port 22 is unreachable");
                            return log.ToString();
                        }
                        log.AppendLine("[DEBUG] TCP connection successful - port 22 is reachable");
                    }
                    catch (Exception ex)
                    {
                        log.AppendLine($"[DEBUG] ERROR: TCP connection failed - {ex.Message}");
                        return log.ToString();
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                log.AppendLine("[DEBUG] Connection timeout set to 45 seconds with 2 retry attempts");
                log.AppendLine("[DEBUG] Attempting to connect with standard SSH settings");
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                log.AppendLine("[DEBUG] Connecting via SSH...");
                try
                {
                    client.Connect();
                }
                catch (Exception ex)
                {
                    log.AppendLine($"[DEBUG] ERROR: {ex.Message}");
                    log.AppendLine($"[DEBUG] Stack trace: {ex.StackTrace}");
                    
                    if (ex.InnerException != null)
                    {
                        log.AppendLine($"[DEBUG] Inner exception: {ex.InnerException.Message}");
                    }
                    
                    log.AppendLine("[DEBUG] ------------ Cisco-specific troubleshooting ------------");
                    log.AppendLine("[DEBUG] This error typically occurs with Cisco devices when:");
                    log.AppendLine("[DEBUG] 1. The SSH service on the router needs to be reset");
                    log.AppendLine("[DEBUG] 2. The router has restrictions on allowed cipher suites");
                    log.AppendLine("[DEBUG] 3. The router's SSH version is incompatible");
                    log.AppendLine("[DEBUG] 4. There are resource constraints on the router");
                    log.AppendLine("[DEBUG] 5. The router's terminal monitor shows: SSH1: Session disconnected");
                    log.AppendLine("[DEBUG] ");
                    log.AppendLine("[DEBUG] Try the following on the router:");
                    log.AppendLine("[DEBUG] - no ip ssh server");
                    log.AppendLine("[DEBUG] - ip ssh server");
                    log.AppendLine("[DEBUG] - ip ssh version 2");
                    log.AppendLine("[DEBUG] - crypto key generate rsa modulus 2048");
                    log.AppendLine("[DEBUG] ------------ End Cisco troubleshooting tips ------------");
                    
                    return log.ToString();
                }
                
                if (client.IsConnected)
                {
                    log.AppendLine("[DEBUG] Successfully connected via SSH");
                    
                    log.AppendLine("[DEBUG] Creating shell stream");
                    ShellStream shellStream = client.CreateShellStream("vt100", 80, 24, 800, 600, 1024);
                    
                    log.AppendLine("[DEBUG] Waiting for initial prompt (3 seconds)");
                    await Task.Delay(3000);
                    
                    string initialOutput = shellStream.Read();
                    log.AppendLine($"[DEBUG] Initial prompt received: {initialOutput}");
                    
                    // If enable password is provided, enter privileged mode
                    if (!string.IsNullOrEmpty(decryptedEnablePassword))
                    {
                        log.AppendLine("[DEBUG] Sending 'enable' command");
                        shellStream.WriteLine("enable");
                        await Task.Delay(1000);
                        
                        string enablePrompt = shellStream.Read();
                        log.AppendLine($"[DEBUG] Enable prompt response: {enablePrompt}");
                        
                        log.AppendLine("[DEBUG] Sending enable password");
                        shellStream.WriteLine(decryptedEnablePassword);
                        await Task.Delay(1000);
                        
                        string passwordResponse = shellStream.Read();
                        log.AppendLine($"[DEBUG] Password response: {passwordResponse}");
                    }
                    else
                    {
                        log.AppendLine("[DEBUG] No enable password provided - skipping 'enable' command");
                    }
                    
                    // Test a simple command first
                    log.AppendLine("[DEBUG] Sending test command 'terminal length 0'");
                    shellStream.WriteLine("terminal length 0");
                    await Task.Delay(1000);
                    
                    string terminalResponse = shellStream.Read();
                    log.AppendLine($"[DEBUG] Terminal command response: {terminalResponse}");
                    
                    log.AppendLine("[DEBUG] Sending 'show version' command");
                    shellStream.WriteLine("show version");
                    await Task.Delay(3000);
                    
                    string versionOutput = shellStream.Read();
                    log.AppendLine($"[DEBUG] Version output (truncated): {versionOutput.Substring(0, Math.Min(100, versionOutput.Length))}...");
                    
                    log.AppendLine("[DEBUG] Disconnecting");
                    client.Disconnect();
                    log.AppendLine("[DEBUG] Disconnected successfully");
                    
                    return log.ToString();
                }
                else
                {
                    log.AppendLine("[DEBUG] Failed to connect to the router");
                    return log.ToString();
                }
            }
            catch (Exception ex)
            {
                log.AppendLine($"[DEBUG] ERROR: {ex.Message}");
                log.AppendLine($"[DEBUG] Stack trace: {ex.StackTrace}");
                
                if (ex.InnerException != null)
                {
                    log.AppendLine($"[DEBUG] Inner exception: {ex.InnerException.Message}");
                }
                
                return log.ToString();
            }
        }
        
        public async Task<bool> CheckConnectionAsync(Router router)
        {
            try
            {
                // Gi·∫£i m√£ m·∫≠t kh·∫©u tr∆∞·ªõc khi s·ª≠ d·ª•ng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);

                // Test if the router's SSH port is reachable before attempting connection
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, 22);
                        if (await Task.WhenAny(connectTask, Task.Delay(3000)) != connectTask)
                        {
                            router.Status = "Unreachable";
                            return false;
                        }
                    }
                    catch (Exception)
                    {
                        router.Status = "Unreachable";
                        router.IsAvailable = false;
                        return false;
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                try
                {
                client.Connect();
                }
                catch (Exception)
                {
                    router.Status = "Authentication Failed";
                    router.IsAvailable = false;
                    return false;
                }
                
                bool isConnected = client.IsConnected;
                
                if (isConnected)
                {
                    var command = client.CreateCommand("show version");
                    string version = await Task.FromResult(command.Execute());
                    
                    // Parse the output to extract OS version and model information
                    // This is a simplified example - actual parsing would depend on the router's output format
                    if (!string.IsNullOrEmpty(version))
                    {
                        router.Status = "Connected";
                        router.IsAvailable = true;
                        
                        // Extract OS version (this is simplified)
                        if (version.Contains("Version"))
                        {
                            int startIndex = version.IndexOf("Version");
                            if (startIndex > 0)
                            {
                                int endIndex = version.IndexOf(",", startIndex);
                                if (endIndex > startIndex)
                                {
                                    router.OSVersion = version.Substring(startIndex, endIndex - startIndex).Trim();
                                }
                            }
                        }
                        
                        // Extract model information (simplified)
                        if (version.Contains("cisco"))
                        {
                            int startIndex = version.IndexOf("cisco");
                            if (startIndex > 0)
                            {
                                int endIndex = version.IndexOf("\n", startIndex);
                                if (endIndex > startIndex)
                                {
                                    router.Model = version.Substring(startIndex, endIndex - startIndex).Trim();
                                }
                            }
                        }
                    }
                    
                    client.Disconnect();
                    return true;
                }
                
                router.Status = "Disconnected";
                router.IsAvailable = false;
                return false;
            }
            catch (Exception)
            {
                router.Status = "Error";
                router.IsAvailable = false;
                return false;
            }
        }
        
        public async Task<bool> RestoreConfigurationAsync(Router router, string configuration)
        {
            // Validate input
            if (router == null)
            {
                _logger.LogError("Router cannot be null");
                return false;
            }
            
            if (string.IsNullOrWhiteSpace(configuration))
            {
                _logger.LogError("Configuration cannot be empty");
                return false;
            }
            
            // Validate IP address
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogError("Router {RouterName} has no IP address configured", router.Hostname);
                return false;
            }
            
            if (!System.Net.IPAddress.TryParse(router.IpAddress, out var ipAddress))
            {
                _logger.LogError("Router {RouterName} has invalid IP address: {IPAddress}", 
                    router.Hostname, router.IpAddress);
                return false;
            }

            _logger.LogInformation("Starting configuration restore for router {RouterName} at {IPAddress}", 
                router.Hostname, ipAddress.ToString());

            try
            {
                // Gi·∫£i m√£ m·∫≠t kh·∫©u tr∆∞·ªõc khi s·ª≠ d·ª•ng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;
                
                using (var client = new SshClient(router.IpAddress, DefaultSettings.SSHPort, router.Username, decryptedPassword))
                {
                    _logger.LogInformation("Connecting to router {RouterName} at {IPAddress} to restore configuration", 
                        router.Hostname, router.IpAddress);
                    
                    // More generous timeout settings to avoid connection issues
                    client.ConnectionInfo.Timeout = TimeSpan.FromSeconds(45);
                    client.KeepAliveInterval = TimeSpan.FromSeconds(10);
                    
                    try
                    {
                        client.Connect();
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "SSH connection failed to router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                        return false;
                    }
                    
                    if (!client.IsConnected)
                    {
                        _logger.LogError("SSH connection failed - Unable to connect to router {RouterName}", router.Hostname);
                        return false;
                    }

                    // Create SSH shell with appropriate settings
                    using (var shell = client.CreateShellStream("dumb", 80, 24, 800, 600, 1024))
                    {
                        try
                        {
                            // Wait for initial prompt
                            _logger.LogDebug("Waiting for initial router prompt");
                            string output = await ReadUntilPromptAsync(shell, 8000);
                            
                            // Enter privileged mode if enable password is provided
                            if (!string.IsNullOrEmpty(decryptedEnablePassword))
                            {
                                _logger.LogDebug("Attempting to enter privileged mode");
                                shell.WriteLine("enable");
                                await Task.Delay(500);
                                
                                output = await ReadUntilPromptAsync(shell, 3000, new[] { "Password:", "password:" });
                                if (output.Contains("assword:"))
                                {
                                    shell.WriteLine(decryptedEnablePassword);
                                    await Task.Delay(1000);
                                    output = await ReadUntilPromptAsync(shell, 3000);
                                }
                                
                                if (!output.Contains("#"))
                                {
                                    _logger.LogWarning("Failed to enter privileged mode - continuing anyway but restoration may fail");
                                }
                                else
                                {
                                    _logger.LogDebug("Successfully entered privileged mode");
                                }
                            }
                            
                            // Enter configuration mode
                            _logger.LogDebug("Entering configuration mode");
                            shell.WriteLine("configure terminal");
                            await Task.Delay(1000);
                            output = await ReadUntilPromptAsync(shell, 3000);
                            
                            if (!output.Contains("config") && !output.Contains("conf t"))
                            {
                                _logger.LogWarning("Configuration mode prompt not detected, but continuing with restoration");
                            }
                            
                            // Process configuration line by line
                            int configLinesCount = 0;
                            int errorLinesCount = 0;
                            string[] configLines = configuration.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                            
                            _logger.LogInformation("Starting configuration restore with {LineCount} lines", configLines.Length);
                            
                            foreach (string line in configLines)
                            {
                                string trimmedLine = line.Trim();
                                if (string.IsNullOrWhiteSpace(trimmedLine) || trimmedLine.StartsWith("!") || trimmedLine.StartsWith("#"))
                                {
                                    continue; // Skip comments and empty lines
                                }
                                
                                shell.WriteLine(trimmedLine);
                                await Task.Delay(150); // Wait a bit between commands to avoid overwhelming the router
                                configLinesCount++;
                                
                                // Check for errors in router response
                                output = await ReadUntilPromptAsync(shell, 2000, new[] { 
                                    "% Invalid", "% Error", "% Incomplete", "% Ambiguous" 
                                });
                                
                                if (output.Contains("% Invalid") || output.Contains("% Error") || 
                                    output.Contains("% Incomplete") || output.Contains("% Ambiguous"))
                                {
                                    // Log error but continue with other commands
                                    _logger.LogWarning("Error encountered while applying line: {Line} - Response: {Output}", 
                                        trimmedLine, output.Trim());
                                    errorLinesCount++;
                                }
                            }
                            
                            double errorRate = configLinesCount > 0 ? (double)errorLinesCount / configLinesCount * 100 : 0;
                            _logger.LogInformation(
                                "Processed {ConfigLines} configuration lines with {ErrorCount} errors ({ErrorRate:F1}%)", 
                                configLinesCount, errorLinesCount, errorRate);
                            
                            // Exit config mode and save configuration
                            _logger.LogDebug("Exiting configuration mode");
                            shell.WriteLine("end");
                            await Task.Delay(1000);
                            output = await ReadUntilPromptAsync(shell, 3000);
                            
                            _logger.LogDebug("Saving configuration to NVRAM");
                            shell.WriteLine("write memory");
                            await Task.Delay(2000);
                            output = await ReadUntilPromptAsync(shell, 8000);
                            
                            // Check for failure conditions in the output
                            if (output.ToLower().Contains("fail") || output.ToLower().Contains("error") || 
                                output.ToLower().Contains("invalid"))
                            {
                                _logger.LogError("Failed to save configuration to NVRAM for router {RouterName}: {Output}", 
                                    router.Hostname, output.Trim());
                                return false;
                            }
                            
                            // If too many errors occurred, consider the restoration a failure
                            if (errorRate > 50 && configLinesCount > 10)
                            {
                                _logger.LogError(
                                    "Configuration restore had too many errors ({ErrorCount}/{TotalLines}, {ErrorRate:F1}%)", 
                                    errorLinesCount, configLinesCount, errorRate);
                                return false;
                            }
                            
                            _logger.LogInformation("Successfully restored and saved configuration for router {RouterName}", 
                                router.Hostname);
                            return true;
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex, "Error during configuration restore for router {RouterName}: {ErrorMessage}", 
                                router.Hostname, ex.Message);
                            return false;
                        }
                        finally
                        {
                            try
                            {
                                // Ensure we disconnect cleanly
                                if (client.IsConnected)
                                {
                                    _logger.LogDebug("Disconnecting from router {RouterName}", router.Hostname);
                                    client.Disconnect();
                                }
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(ex, "Error while disconnecting from router {RouterName}", router.Hostname);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled exception during configuration restore for router {RouterName}: {ErrorMessage}", 
                    router.Hostname, ex.Message);
                return false;
            }
        }
        
        private async Task<string> ReadUntilPromptAsync(ShellStream shell, int timeout, string[]? errorStrings = null)
        {
            var result = new StringBuilder();
            var startTime = DateTime.Now;
            
            // Define common prompt patterns for different router types
            string[] promptPatterns = new[] { 
                "#",                 // Standard privileged mode prompt
                ">",                 // Standard user mode prompt
                ":",                 // Sometimes seen in prompts
                "Password:",         // Password prompt
                "(config)#",         // Global configuration mode
                "(config-if)#",      // Interface configuration mode
                "(config-line)#",    // Line configuration mode
                "(config-router)#",  // Router protocol configuration
                "(config-dhcp)#",    // DHCP configuration
                "More--",            // Pager prompt
                "[yes/no]:",         // Confirmation prompt
                "[confirm]"          // Another confirmation pattern
            };
            
            _logger.LogDebug("Waiting for router prompt with {TimeoutMs}ms timeout", timeout);
            
            // Keep track of how much data we've received to detect stalled connections
            int lastResultLength = 0;
            int stallCounter = 0;
            
            while ((DateTime.Now - startTime).TotalMilliseconds < timeout)
            {
                if (shell.DataAvailable)
                {
                    string data = shell.Read();
                    if (!string.IsNullOrEmpty(data))
                    {
                        result.Append(data);
                        _logger.LogTrace("Received {DataLength} characters from router", data.Length);
                        
                        // Reset stall counter when we receive data
                        stallCounter = 0;
                        lastResultLength = result.Length;
                    }
                    
                    // Check for error strings if provided
                    if (errorStrings != null)
                    {
                        foreach (var errorString in errorStrings)
                        {
                            if (data.Contains(errorString) || result.ToString().Contains(errorString))
                            {
                                _logger.LogDebug("Detected error string in output: {ErrorString}", errorString);
                                return result.ToString();
                            }
                        }
                    }
                    
                    // Check for common prompt patterns
                    foreach (var pattern in promptPatterns)
                    {
                        if (data.Contains(pattern))
                        {
                            _logger.LogDebug("Detected prompt pattern: {Pattern}", pattern);
                            return result.ToString();
                        }
                    }
                    
                    // Use regex to detect general prompt patterns like hostname# or hostname>
                    // This helps with routers that have custom hostnames in their prompts
                    if (System.Text.RegularExpressions.Regex.IsMatch(data, @"\S+[#>](\s|$)"))
                    {
                        _logger.LogDebug("Detected generic prompt pattern with regex");
                        return result.ToString();
                    }
                }
                else
                {
                    // If the result hasn't changed in a while, we might be at a prompt but didn't match our patterns
                    if (result.Length > 0 && result.Length == lastResultLength)
                    {
                        stallCounter++;
                        if (stallCounter >= 10) // After ~1 second of no new data
                        {
                            _logger.LogDebug("No new data received for ~1 second, assuming prompt is available");
                            return result.ToString();
                        }
                    }
                }
                
                await Task.Delay(100);
            }
            
            _logger.LogWarning("Timeout reached while waiting for prompt. Timeout: {TimeoutMs}ms", timeout);
            _logger.LogWarning("Last received data: {LastData}", 
                result.Length > 0 ? result.ToString().Substring(Math.Max(0, result.Length - 50)) : "No data");
            return result.ToString();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    _context.Dispose();
                }
                _disposed = true;
            }
        }
    }
}
```

### NCM3\Services\S3BackupService.cs
```cs
using System;
using System.IO;
using System.Threading.Tasks;
using Amazon.S3;
using Amazon.S3.Model;
using Amazon.S3.Transfer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace NCM3.Services
{
    public interface IS3BackupService
    {
        Task<bool> UploadBackupAsync(int routerId, string configContent, string version, string backupBy);
        Task<bool> UploadDatabaseBackupAsync(string filePath);
        Task<string> DownloadBackupAsync(string key);
        Task<bool> DeleteBackupAsync(string key);
        Task<ListObjectsV2Response> ListBackupsAsync(string prefix = "");
    }

    public class S3BackupService : IS3BackupService
    {
        private readonly IAmazonS3 _s3Client;
        private readonly ILogger<S3BackupService> _logger;
        private readonly string _bucketName;
        private readonly string _configBackupPrefix;
        private readonly string _databaseBackupPrefix;

        public S3BackupService(
            IAmazonS3 s3Client,
            IConfiguration configuration,
            ILogger<S3BackupService> logger)
        {
            _s3Client = s3Client;
            _logger = logger;
            
            _bucketName = configuration["AWS:S3:BucketName"];
            _configBackupPrefix = configuration["AWS:S3:ConfigBackupPrefix"] ?? "config-backups/";
            _databaseBackupPrefix = configuration["AWS:S3:DatabaseBackupPrefix"] ?? "db-backups/";

            _logger.LogDebug($"S3BackupService initialized. Bucket: '{_bucketName}', ConfigPrefix: '{_configBackupPrefix}', DbPrefix: '{_databaseBackupPrefix}'");

            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("AWS S3 BucketName is not configured in appsettings.json. S3 backups will fail.");
                throw new ArgumentException("AWS S3 BucketName must be configured in appsettings.json");
            }
        }

        public async Task<bool> UploadBackupAsync(int routerId, string configContent, string version, string backupBy)
        {
            _logger.LogInformation("Attempting to upload backup to S3 for RouterId: {RouterId}, Version: {Version}", routerId, version);
            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("S3 BucketName is not configured. Cannot upload backup for RouterId: {RouterId}", routerId);
                return false;
            }

            try
            {
                string timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
                string key = $"{_configBackupPrefix}router_{routerId}/{timestamp}_{version}.config";
                _logger.LogDebug("Generated S3 key for RouterId {RouterId}: {Key}", routerId, key);
                
                using (var stream = new MemoryStream())
                using (var writer = new StreamWriter(stream))
                {
                    writer.Write(configContent);
                    writer.Flush();
                    stream.Position = 0;
                    
                    var request = new PutObjectRequest
                    {
                        BucketName = _bucketName,
                        Key = key,
                        InputStream = stream,
                        ContentType = "text/plain",
                        Metadata = 
                        {
                            ["router-id"] = routerId.ToString(),
                            ["backup-date"] = DateTime.UtcNow.ToString("o"), // ISO 8601 format
                            ["version"] = version,
                            ["backup-by"] = backupBy
                        }
                    };
                    
                    _logger.LogDebug("Sending PutObjectRequest to S3 for key: {Key}", key);
                    var response = await _s3Client.PutObjectAsync(request);
                    _logger.LogInformation("Successfully uploaded router configuration to S3: {Key}. HTTP Status: {StatusCode}, RequestId: {RequestId}", 
                                         key, response.HttpStatusCode, response.ResponseMetadata?.RequestId);
                    return true;
                }
            }
            catch (Amazon.S3.AmazonS3Exception s3Ex)
            {
                _logger.LogError(s3Ex, "AmazonS3Exception during S3 upload for RouterId: {RouterId}. ErrorCode: {ErrorCode}, StatusCode: {StatusCode}, AWSRequestId: {AWSRequestId}, Message: {S3Message}", 
                                 routerId, s3Ex.ErrorCode, s3Ex.StatusCode, s3Ex.RequestId, s3Ex.Message);
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Generic error uploading router configuration to S3 for RouterId: {RouterId}. Message: {ExceptionMessage}", 
                                 routerId, ex.Message);
                return false;
            }
        }

        public async Task<bool> UploadDatabaseBackupAsync(string filePath)
        {
            _logger.LogInformation("Attempting to upload database backup to S3 from path: {FilePath}", filePath);
            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("S3 BucketName is not configured. Cannot upload database backup from: {FilePath}", filePath);
                return false;
            }
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.LogError("Database backup file not found: {FilePath}", filePath);
                    return false;
                }
                
                string fileName = Path.GetFileName(filePath);
                string key = $"{_databaseBackupPrefix}{fileName}";
                _logger.LogDebug("Generated S3 key for database backup {FileName}: {Key}", fileName, key);
                
                // Use TransferUtility for larger files
                var fileTransferUtility = new TransferUtility(_s3Client);
                
                var uploadRequest = new TransferUtilityUploadRequest
                {
                    FilePath = filePath,
                    BucketName = _bucketName,
                    Key = key,
                    // Optional: Add metadata if needed
                    Metadata = 
                    {
                        ["backup-date"] = DateTime.UtcNow.ToString("o")
                    }
                };
                
                _logger.LogDebug("Sending TransferUtilityUploadRequest to S3 for key: {Key}", key);
                await fileTransferUtility.UploadAsync(uploadRequest);
                _logger.LogInformation("Successfully uploaded database backup to S3: {Key}", key);
                return true;
            }
            catch (Amazon.S3.AmazonS3Exception s3Ex)
            {
                 _logger.LogError(s3Ex, "AmazonS3Exception during S3 database backup upload from {FilePath}. ErrorCode: {ErrorCode}, StatusCode: {StatusCode}, AWSRequestId: {AWSRequestId}, Message: {S3Message}", 
                                 filePath, s3Ex.ErrorCode, s3Ex.StatusCode, s3Ex.RequestId, s3Ex.Message);
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Generic error uploading database backup to S3 from {FilePath}: {ExceptionMessage}", 
                                 filePath, ex.Message);
                return false;
            }
        }

        public async Task<string> DownloadBackupAsync(string key)
        {
            try
            {
                var request = new GetObjectRequest
                {
                    BucketName = _bucketName,
                    Key = key
                };
                
                using (var response = await _s3Client.GetObjectAsync(request))
                using (var reader = new StreamReader(response.ResponseStream))
                {
                    return await reader.ReadToEndAsync();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error downloading backup from S3: {Key}, {ErrorMessage}", key, ex.Message);
                throw;
            }
        }

        public async Task<bool> DeleteBackupAsync(string key)
        {
            try
            {
                var request = new DeleteObjectRequest
                {
                    BucketName = _bucketName,
                    Key = key
                };
                
                await _s3Client.DeleteObjectAsync(request);
                _logger.LogInformation("Successfully deleted backup from S3: {Key}", key);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting backup from S3: {Key}, {ErrorMessage}", key, ex.Message);
                return false;
            }
        }

        public async Task<ListObjectsV2Response> ListBackupsAsync(string prefix = "")
        {
            try
            {
                var request = new ListObjectsV2Request
                {
                    BucketName = _bucketName,
                    Prefix = string.IsNullOrEmpty(prefix) ? _configBackupPrefix : prefix,
                    MaxKeys = 1000
                };
                
                return await _s3Client.ListObjectsV2Async(request);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error listing backups from S3: {ErrorMessage}", ex.Message);
                throw;
            }
        }
    }
}
```

### NCM3\Services\TelegramNotificationService.cs
```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Linq;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services
{
    public interface ITelegramNotificationService
    {
        Task SendConfigChangeNotificationAsync(string routerName, string changeType, string details, string priority = "Low");
        Task SendComplianceAlertAsync(string routerName, string ruleName, string severity, string details);
        Task SendConnectivityAlertAsync(string routerName, string status, string details);
        Task SendConfigurationChangedEventAsync(ConfigurationChangedEvent configChangedEvent);
        Task SendDailySummaryAsync();
        void Initialize();
    }    public class TelegramNotificationService : ITelegramNotificationService, IDisposable
    {
        private readonly HttpClient _httpClient;
        private readonly string? _botToken;
        private readonly string? _chatId;
        private readonly ILogger<TelegramNotificationService> _logger;
        private readonly NotificationLogger? _notificationLogger;
        private readonly IConfiguration _configuration;
        
        private System.Timers.Timer? _consolidationTimer;
        private System.Timers.Timer? _dailySummaryTimer;
        private readonly ConcurrentDictionary<string, List<ConfigurationChangedEvent>> _pendingNotifications = new();
        private readonly ConcurrentBag<ConfigurationChangedEvent> _allEvents = new();
        
        private bool _isInitialized = false;        public TelegramNotificationService(
            IConfiguration configuration, 
            HttpClient httpClient, 
            ILogger<TelegramNotificationService> logger,
            NotificationLogger? notificationLogger = null)
        {
            _httpClient = httpClient;
            _configuration = configuration;
            _botToken = configuration["Telegram:BotToken"];
            _chatId = configuration["Telegram:ChatId"];
            _logger = logger;
            _notificationLogger = notificationLogger;
        }public async Task SendConfigChangeNotificationAsync(string routerName, string changeType, string details, string priority = "Low")
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. B·ªè qua g·ª≠i th√¥ng b√°o.");
                
                // Ghi log th√¥ng b√°o
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogConfigurationChangeNotificationAsync(
                        routerName, 
                        changeType, 
                        "B·ªè qua do Telegram ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh", 
                        false);
                }
                
                return; // Skip if Telegram is not configured
            }

            var message = $"üîî *Thay ƒë·ªïi C·∫•u h√¨nh*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Lo·∫°i thay ƒë·ªïi:* {changeType}\n" +
                         $"*M·ª©c ƒë·ªô ∆∞u ti√™n:* {priority}\n" +
                         $"*Chi ti·∫øt:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log th√¥ng b√°o
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    routerName, 
                    changeType, 
                    details, 
                    success);
            }
        }
          public async Task SendComplianceAlertAsync(string routerName, string ruleName, string severity, string details)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. B·ªè qua g·ª≠i th√¥ng b√°o.");
                
                // Ghi log th√¥ng b√°o
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogComplianceNotificationAsync(
                        routerName, 
                        ruleName, 
                        severity,
                        "B·ªè qua do Telegram ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh", 
                        false);
                }
                
                return;
            }

            var message = $"‚ö†Ô∏è *C·∫£nh b√°o tu√¢n th·ªß*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Quy t·∫Øc:* {ruleName}\n" +
                         $"*M·ª©c ƒë·ªô:* {severity}\n" +
                         $"*Chi ti·∫øt:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log th√¥ng b√°o
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogComplianceNotificationAsync(
                    routerName, 
                    ruleName, 
                    severity,
                    details, 
                    success);
            }
        }
          public async Task SendConnectivityAlertAsync(string routerName, string status, string details)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. B·ªè qua g·ª≠i th√¥ng b√°o.");
                
                // Ghi log th√¥ng b√°o
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogConnectivityNotificationAsync(
                        routerName, 
                        status, 
                        "B·ªè qua do Telegram ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh", 
                        false);
                }
                
                return;
            }

            var message = $"üîå *C·∫£nh b√°o k·∫øt n·ªëi*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Tr·∫°ng th√°i:* {status}\n" +
                         $"*Chi ti·∫øt:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log th√¥ng b√°o
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConnectivityNotificationAsync(
                    routerName, 
                    status, 
                    details, 
                    success);
            }
        }      private async Task<bool> SendTelegramMessageAsync(string message)
    {
        try
        {
            var url = $"https://api.telegram.org/bot{_botToken}/sendMessage";
            string? parseMode = _configuration.GetValue<string>("Telegram:NotificationFormat", "MarkdownV2");
            parseMode ??= "MarkdownV2";
            bool enableMarkdown = _configuration.GetValue<bool>("Telegram:EnableMarkdownFormatting", true);
            
            // Format the message according to parse mode
            string formattedMessage = FormatMessage(message, parseMode, enableMarkdown);
            
            // Check if message is too long (Telegram limit is 4096 characters)
            const int telegramMaxMessageLength = 4096;
            
            if (formattedMessage.Length > telegramMaxMessageLength)
            {
                _logger.LogWarning("Message exceeds Telegram's 4096 character limit. Current length: {Length}. Truncating message.", formattedMessage.Length);
                
                // Find a good breaking point - preferably before a code block
                int truncateIndex = telegramMaxMessageLength - 100; // Leave room for the truncation notice
                
                // Try to find a natural break point like a newline
                int lastNewLine = formattedMessage.LastIndexOf('\n', truncateIndex);
                if (lastNewLine > telegramMaxMessageLength / 2)
                {
                    truncateIndex = lastNewLine;
                }
                
                // Truncate and add notice
                string truncatedMessage = formattedMessage.Substring(0, truncateIndex);
                truncatedMessage += "\n\n...[N·ªôi dung b·ªã c·∫Øt ng·∫Øn do qu√° d√†i]...";
                
                formattedMessage = truncatedMessage;
            }
            
            var payload = new
            {
                chat_id = _chatId,
                text = formattedMessage,
                parse_mode = parseMode
            };

            var content = new StringContent(
                JsonConvert.SerializeObject(payload),
                Encoding.UTF8,
                "application/json");

            _logger.LogDebug("Sending Telegram message with parse_mode: {ParseMode}", parseMode);
            _logger.LogTrace("Message content length: {Length}", formattedMessage.Length);

            var response = await _httpClient.PostAsync(url, content);
            
            if (!response.IsSuccessStatusCode)
            {
                var errorResponse = await response.Content.ReadAsStringAsync();
                _logger.LogError("Telegram API error: {StatusCode} {Response}", response.StatusCode, errorResponse);
                return false;
            }

            _logger.LogInformation("Successfully sent Telegram notification");
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending Telegram notification: {Message}", ex.Message);
            return false;
        }
    }
    
    private string FormatMessage(string message, string parseMode, bool enableMarkdown)
    {
        // If we're using HTML format or markdown is disabled, ensure no Markdown formatting is present
        if (!enableMarkdown)
        {
            message = message.Replace("*", "")
                           .Replace("_", "")
                           .Replace("`", "");
            return message;
        }
        
        if (parseMode.Equals("HTML", StringComparison.OrdinalIgnoreCase))
        {
            // Properly convert text formatting to paired HTML tags
            return ConvertMarkdownToHtml(message);
        }
        
        if (parseMode.Equals("MarkdownV2", StringComparison.OrdinalIgnoreCase))
        {
            // Replace code blocks first
            message = message.Replace("```", "ÀêÀêÀê"); // Temporary replacement
            
            // Escape special characters for MarkdownV2
            message = message.Replace("\\", "\\\\") // Must be first
                           .Replace("_", "\\_")
                           .Replace("*", "\\*")
                           .Replace("[", "\\[")
                           .Replace("]", "\\]")
                           .Replace("(", "\\(")
                           .Replace(")", "\\)")
                           .Replace("~", "\\~")
                           .Replace("`", "\\`")
                           .Replace(">", "\\>")
                           .Replace("#", "\\#")
                           .Replace("+", "\\+")
                           .Replace("-", "\\-")
                           .Replace("=", "\\=")
                           .Replace("|", "\\|")
                           .Replace(".", "\\.")
                           .Replace("!", "\\!")
                           .Replace("{", "\\{")
                           .Replace("}", "\\}");

            // Restore code blocks
            message = message.Replace("ÀêÀêÀê", "```");
        }
        
        return message;
    }public void Initialize()
        {
            if (_isInitialized)
            {
                return;
            }
            
            // Set up consolidation timer
            int consolidationInterval = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:ConsolidationIntervalMinutes", 
                _configuration.GetValue<int>("Telegram:ConsolidationIntervalMinutes", 30));
            
            _logger.LogInformation("Setting up notification consolidation timer with interval of {Minutes} minutes", 
                consolidationInterval);
                
            _consolidationTimer = new System.Timers.Timer(consolidationInterval * 60 * 1000); // Convert to milliseconds
            _consolidationTimer.Elapsed += async (sender, e) => await ProcessConsolidatedNotificationsAsync();
            _consolidationTimer.AutoReset = true;
            _consolidationTimer.Start();
            
            // Set up daily summary timer
            bool dailySummaryEnabled = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:DailySummaryEnabled", true);
            
            if (dailySummaryEnabled)
            {
                int dailySummaryHour = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:DailySummaryHour", 
                    _configuration.GetValue<int>("Telegram:DailySummaryHour", 9));
                    
                int dailySummaryMinute = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:DailySummaryMinute",
                    _configuration.GetValue<int>("Telegram:DailySummaryMinute", 0));
                
                _logger.LogInformation("Setting up daily summary timer for {Hour}:{Minute}", 
                    dailySummaryHour, dailySummaryMinute.ToString("00"));
                
                var now = DateTime.Now;
                var summaryTime = new DateTime(now.Year, now.Month, now.Day, dailySummaryHour, dailySummaryMinute, 0);
                
                if (now > summaryTime)
                {
                    summaryTime = summaryTime.AddDays(1);
                }
                
                var timeToNextSummary = summaryTime - now;
                _logger.LogInformation("Next daily summary will run in {Hours} hours and {Minutes} minutes", 
                    timeToNextSummary.Hours, timeToNextSummary.Minutes);
                    
                _dailySummaryTimer = new System.Timers.Timer(timeToNextSummary.TotalMilliseconds);
                _dailySummaryTimer.Elapsed += async (sender, e) => 
                {
                    await SendDailySummaryAsync();
                    _dailySummaryTimer.Interval = 24 * 60 * 60 * 1000; // Set to 24 hours for subsequent runs
                };
                _dailySummaryTimer.AutoReset = true;
                _dailySummaryTimer.Start();
            }
            else
            {
                _logger.LogInformation("Daily summary notifications are disabled");
            }
            
            // Subscribe to the event bus if available
            try
            {
                var eventBus = GetEventBus();
                if (eventBus != null)
                {
                    eventBus.Subscribe<ConfigurationChangedEvent>(async (configChangedEvent) => 
                    {
                        await SendConfigurationChangedEventAsync(configChangedEvent);
                    });
                    _logger.LogInformation("Successfully subscribed to ConfigurationChangedEvent");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to subscribe to event bus: {ErrorMessage}", ex.Message);
            }
            
            _isInitialized = true;
        }
        
        private IEventBus? GetEventBus()
        {
            try
            {
                // Create a service scope to resolve the event bus (which might be registered as singleton)
                var serviceProvider = _httpClient.GetType().Assembly
                    .GetType("Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions")?
                    .GetMethod("GetService")?
                    .MakeGenericMethod(typeof(IServiceProvider))
                    .Invoke(null, new object[] { _httpClient }) as IServiceProvider;
                    
                if (serviceProvider != null)
                {
                    return serviceProvider.GetService(typeof(IEventBus)) as IEventBus;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resolving event bus: {ErrorMessage}", ex.Message);
            }
            
            return null;
        }
          public async Task SendConfigurationChangedEventAsync(ConfigurationChangedEvent configChangedEvent)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. B·ªè qua g·ª≠i th√¥ng b√°o.");
                return;
            }
            
            // Add to all events for summary
            _allEvents.Add(configChangedEvent);
            
            // Check if this is a high-priority notification that should be sent immediately
            var sendImmediatelyFor = _configuration
                .GetSection("ChangeDetection:NotificationSettings:SendImmediatelyForPriorities")
                .Get<List<string>>() ?? new List<string> { "High" };
                
            if (sendImmediatelyFor.Any(p => string.Equals(p, configChangedEvent.Priority, StringComparison.OrdinalIgnoreCase)))
            {
                await SendImmediateNotificationAsync(configChangedEvent);
                return;
            }
            
            // Check if we should consolidate by router group
            bool consolidateByRouterGroup = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:ConsolidateByRouterGroup", true);
            
            // Get router key for grouping notifications
            string routerKey;
            if (consolidateByRouterGroup && !string.IsNullOrEmpty(configChangedEvent.Router.Group))
            {
                // Use router group for consolidation
                routerKey = $"Group:{configChangedEvent.Router.Group}";
                _logger.LogDebug("Using router group '{Group}' for consolidation of router {RouterName}", 
                    configChangedEvent.Router.Group, configChangedEvent.Router.Hostname);
            }
            else
            {
                // Use individual router for consolidation
                routerKey = configChangedEvent.Router.Hostname;
            }
            
            // Add to pending notifications for consolidation
            _pendingNotifications.AddOrUpdate(
                routerKey,
                new List<ConfigurationChangedEvent> { configChangedEvent },
                (_, existingList) => 
                {
                    existingList.Add(configChangedEvent);
                    
                    // Check if we've exceeded the warning threshold
                    int warningThreshold = _configuration.GetValue<int>(
                        "ChangeDetection:NotificationSettings:AlertThresholds:WarningChangesCount", 5);
                    int criticalThreshold = _configuration.GetValue<int>(
                        "ChangeDetection:NotificationSettings:AlertThresholds:CriticalChangesCount", 10);
                    
                    if (existingList.Count == warningThreshold)
                    {
                        // Log a warning about the number of pending changes
                        _logger.LogWarning("Warning threshold reached: {Count} pending changes for {RouterKey}", 
                            existingList.Count, routerKey);
                    }
                    else if (existingList.Count == criticalThreshold)
                    {
                        // Log a critical warning and trigger immediate processing for this router
                        _logger.LogCritical("Critical threshold reached: {Count} pending changes for {RouterKey}. Processing immediately.", 
                            existingList.Count, routerKey);
                            
                        // Schedule immediate processing for this router
                        Task.Run(async () => 
                        {
                            try
                            {
                                await ProcessConsolidatedNotificationsForKeyAsync(routerKey);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "Error processing immediate consolidated notifications for {RouterKey}", routerKey);
                            }
                        });
                    }
                    
                    return existingList;
                });
                
            _logger.LogDebug("Added configuration change for router {RouterName} to pending notifications queue under key {RouterKey}", 
                configChangedEvent.Router.Hostname, routerKey);
        }
        
        private async Task SendImmediateNotificationAsync(ConfigurationChangedEvent configChangedEvent)
        {
            _logger.LogInformation("Sending immediate notification for high-priority change on router {RouterName}", 
                configChangedEvent.Router.Hostname);
                
            bool sendDiffs = _configuration.GetValue<bool>("Telegram:SendDiffs", true);
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            
            string diffDetails = "Change details not available";
            
            if (sendDiffs && !string.IsNullOrEmpty(configChangedEvent.OldContent) && 
                !string.IsNullOrEmpty(configChangedEvent.NewContent))
            {
                diffDetails = GetDiffSummary(configChangedEvent.OldContent, configChangedEvent.NewContent, maxDiffLines);
            }
                
            var message = $"üö® *IMPORTANT Configuration Change*\n\n" +
                         $"*Router:* {configChangedEvent.Router.Hostname}\n" +
                         $"*Detection Method:* {configChangedEvent.DetectionStrategy}\n" +
                         $"*Priority:* {configChangedEvent.Priority}\n" +
                         $"*Time:* {configChangedEvent.Timestamp.ToLocalTime():yyyy-MM-dd HH:mm:ss}\n" +
                         $"*Description:* {configChangedEvent.ChangeDescription}\n\n" +
                         $"*Changes:*\n```\n{diffDetails}\n```";
                         
            await SendTelegramMessageAsync(message);
            
            // Log notification
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    configChangedEvent.Router.Hostname, 
                    "High Priority - " + configChangedEvent.ChangeDescription, 
                    diffDetails, 
                    true);
            }
        }
          private async Task ProcessConsolidatedNotificationsAsync()
        {
            _logger.LogInformation("Processing consolidated notifications");
            
            int count = _pendingNotifications.Count;
            if (count == 0)
            {
                _logger.LogInformation("No pending notifications to process");
                return;
            }
            
            // Process each router's or group's notifications
            foreach (var routerKey in _pendingNotifications.Keys.ToArray())
            {
                await ProcessConsolidatedNotificationsForKeyAsync(routerKey);
            }
        }
        
        private async Task ProcessConsolidatedNotificationsForKeyAsync(string routerKey)
        {
            if (!_pendingNotifications.TryGetValue(routerKey, out var events) || events.Count == 0)
            {
                _logger.LogInformation("No pending notifications to process for {RouterKey}", routerKey);
                return;
            }
            
            _logger.LogInformation("Processing consolidated notifications for {RouterKey} with {Count} events", 
                routerKey, events.Count);
                
            bool sendDiffs = _configuration.GetValue<bool>("Telegram:SendDiffs", true);
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            int maxChangesPerMessage = _configuration.GetValue<int>(
                "ChangeDetection:NotificationSettings:MaxChangesPerConsolidatedMessage", 10);
            
            // Build a consolidated message
            var message = new StringBuilder();
            
            // Check if this is a group or individual router
            bool isGroup = routerKey.StartsWith("Group:", StringComparison.OrdinalIgnoreCase);
            string displayName = isGroup ? routerKey.Substring(6) : routerKey; // Remove "Group:" prefix if present
            
            message.AppendLine($"üìä *Consolidated Configuration Changes*");
            message.AppendLine();
            
            if (isGroup)
            {
                message.AppendLine($"*Router Group:* {displayName}");
                
                // Count unique routers in this group
                var uniqueRouters = events.Select(e => e.Router.Hostname).Distinct().ToList();
                message.AppendLine($"*Affected Routers:* {uniqueRouters.Count}");
                message.AppendLine($"*Routers:* {string.Join(", ", uniqueRouters.Take(5))}{(uniqueRouters.Count > 5 ? $" and {uniqueRouters.Count - 5} more..." : "")}");
            }
            else
            {
                message.AppendLine($"*Router:* {displayName}");
            }
            
            message.AppendLine($"*Number of changes:* {events.Count}");
            message.AppendLine($"*Time period:* {events.Min(e => e.Timestamp).ToLocalTime():HH:mm} - {events.Max(e => e.Timestamp).ToLocalTime():HH:mm}");
            message.AppendLine();
            
            // Group by priority
            var byPriority = events
                .GroupBy(e => e.Priority)
                .OrderBy(g => g.Key == "High" ? 0 : g.Key == "Medium" ? 1 : 2);
                
            message.AppendLine("*Changes by priority:*");
            foreach (var priorityGroup in byPriority)
            {
                string priorityEmoji = priorityGroup.Key == "High" ? "üî¥" : 
                                       priorityGroup.Key == "Medium" ? "üü†" : "üü¢";
                message.AppendLine($"{priorityEmoji} *{priorityGroup.Key}:* {priorityGroup.Count()} changes");
            }
            
            message.AppendLine();
            message.AppendLine("*Most significant changes:*");
            
            // Get the most recent high-priority event, if any
            var mostSignificantEvent = events
                .OrderBy(e => e.Priority == "High" ? 0 : e.Priority == "Medium" ? 1 : 2)
                .ThenByDescending(e => e.Timestamp)
                .FirstOrDefault();
                
            if (mostSignificantEvent != null && sendDiffs)
            {
                string diffDetails = GetDiffSummary(
                    mostSignificantEvent.OldContent, 
                    mostSignificantEvent.NewContent, 
                    maxDiffLines);
                    
                message.AppendLine("```");
                message.AppendLine(diffDetails);
                message.AppendLine("```");
            }
            
            await SendTelegramMessageAsync(message.ToString());
            
            // Log consolidated notification
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    routerKey, 
                    "Consolidated Changes", 
                    $"{events.Count} changes detected between {events.Min(e => e.Timestamp)} and {events.Max(e => e.Timestamp)}", 
                    true);
            }
            
            // Remove processed notifications
            _pendingNotifications.TryRemove(routerKey, out _);
        }
        
        public async Task SendDailySummaryAsync()
        {
            _logger.LogInformation("Generating daily notification summary");
            
            if (_allEvents.IsEmpty)
            {
                _logger.LogInformation("No events to include in the daily summary");
                return;
            }
            
            // Filter events from the last 24 hours
            var last24Hours = DateTime.UtcNow.AddDays(-1);
            var recentEvents = _allEvents.Where(e => e.Timestamp >= last24Hours).ToList();
            
            if (recentEvents.Count == 0)
            {
                _logger.LogInformation("No recent events to include in the daily summary");
                return;
            }
            
            var message = new StringBuilder();
            message.AppendLine($"üìÖ *Daily Configuration Change Summary*");
            message.AppendLine($"*Period:* {last24Hours.ToLocalTime():yyyy-MM-dd HH:mm} - {DateTime.Now:yyyy-MM-dd HH:mm}");
            message.AppendLine();
            
            // Group by router
            var byRouter = recentEvents
                .GroupBy(e => e.Router.Hostname)
                .OrderBy(g => g.Key);
                
            message.AppendLine($"*Total changes:* {recentEvents.Count} across {byRouter.Count()} routers");
            message.AppendLine();
            
            // Group by priority
            var byPriority = recentEvents
                .GroupBy(e => e.Priority)
                .OrderBy(g => g.Key == "High" ? 0 : g.Key == "Medium" ? 1 : 2);
                
            message.AppendLine("*Changes by priority:*");
            foreach (var priorityGroup in byPriority)
            {
                string priorityEmoji = priorityGroup.Key == "High" ? "üî¥" : 
                                     priorityGroup.Key == "Medium" ? "üü†" : "üü¢";
                message.AppendLine($"{priorityEmoji} *{priorityGroup.Key}:* {priorityGroup.Count()} changes");
            }
            
            message.AppendLine();
            message.AppendLine("*Changes by router:*");
            
            foreach (var routerGroup in byRouter)
            {
                message.AppendLine($"‚Ä¢ *{routerGroup.Key}:* {routerGroup.Count()} changes");
                
                // Group by detection strategy
                var byStrategy = routerGroup
                    .GroupBy(e => e.DetectionStrategy)
                    .OrderBy(g => g.Key);
                    
                foreach (var strategyGroup in byStrategy)
                {
                    message.AppendLine($"  - {strategyGroup.Key}: {strategyGroup.Count()} changes");
                }
            }
            
            await SendTelegramMessageAsync(message.ToString());
            
            // Log daily summary
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    "All Routers", 
                    "Daily Summary", 
                    $"{recentEvents.Count} changes across {byRouter.Count()} routers in the last 24 hours", 
                    true);
            }
        }          private string GetDiffSummary(string oldContent, string newContent, int maxLines)
        {
            try
            {
                // Get diff settings from configuration
                bool ignoreWhitespace = _configuration.GetValue<bool>("ChangeDetection:DiffGeneration:IgnoreWhitespace", true);
                bool ignoreCase = _configuration.GetValue<bool>("ChangeDetection:DiffGeneration:IgnoreCase", false);
                
                // Apply filters based on configuration
                bool ignoreCommentChanges = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:FilterRules:IgnoreCommentChanges", true);
                bool ignoreDateTimeChanges = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:FilterRules:IgnoreDateTimeChanges", true);
                
                // More aggressive filtering to reduce message size
                bool compactMode = true; // Always use compact mode to reduce size
                
                // Simple diff implementation - split and compare lines
                var oldLines = FilterLines(oldContent, ignoreWhitespace, ignoreCase, ignoreCommentChanges, ignoreDateTimeChanges);
                var newLines = FilterLines(newContent, ignoreWhitespace, ignoreCase, ignoreCommentChanges, ignoreDateTimeChanges);
                
                var addedLines = newLines.Except(oldLines).ToList();
                var removedLines = oldLines.Except(newLines).ToList();
                
                var result = new StringBuilder();
                
                // Add a small summary
                int totalChanges = addedLines.Count + removedLines.Count;
                result.AppendLine($"T·ªïng thay ƒë·ªïi: {totalChanges} d√≤ng ({removedLines.Count} x√≥a, {addedLines.Count} th√™m)");
                
                if (totalChanges > 0)
                {
                    result.AppendLine();
                    
                    if (compactMode)
                    {
                        // In compact mode, just show limited number of the most significant changes
                        int shownChanges = Math.Min(maxLines, Math.Max(1, totalChanges));
                        
                        // Prioritize important keywords in the changes
                        var prioritizedRemovals = PrioritizeImportantChanges(removedLines);
                        var prioritizedAdditions = PrioritizeImportantChanges(addedLines);
                        
                        // Show most important removed lines first (with - prefix)
                        int removalsToShow = Math.Min(prioritizedRemovals.Count, maxLines / 2);
                        if (removalsToShow > 0)
                        {
                            result.AppendLine("N·ªôi dung b·ªã x√≥a:");
                            foreach (var line in prioritizedRemovals.Take(removalsToShow))
                            {
                                result.AppendLine($"- {line}");
                            }
                            
                            if (removedLines.Count > removalsToShow)
                            {
                                result.AppendLine($"- ... v√† {removedLines.Count - removalsToShow} d√≤ng kh√°c...");
                            }
                        }
                        
                        if (prioritizedAdditions.Any() && prioritizedRemovals.Any())
                        {
                            result.AppendLine();
                        }
                        
                        // Show most important added lines (with + prefix)
                        int additionsToShow = Math.Min(prioritizedAdditions.Count, maxLines / 2);
                        if (additionsToShow > 0)
                        {
                            result.AppendLine("N·ªôi dung m·ªõi th√™m v√†o:");
                            foreach (var line in prioritizedAdditions.Take(additionsToShow))
                            {
                                result.AppendLine($"+ {line}");
                            }
                            
                            if (addedLines.Count > additionsToShow)
                            {
                                result.AppendLine($"+ ... v√† {addedLines.Count - additionsToShow} d√≤ng kh√°c...");
                            }
                        }
                    }
                    else
                    {
                        // Standard mode - shows equal number of removed and added lines
                        // Show removed lines first (with - prefix)
                        foreach (var line in removedLines.Take(maxLines / 2))
                        {
                            result.AppendLine($"- {line}");
                        }
                        
                        if (removedLines.Count > maxLines / 2)
                        {
                            result.AppendLine($"- ... v√† {removedLines.Count - maxLines / 2} d√≤ng x√≥a kh√°c...");
                        }
                        
                        if (removedLines.Any() && addedLines.Any())
                        {
                            result.AppendLine("---");
                        }
                        
                        // Then show added lines (with + prefix)
                        foreach (var line in addedLines.Take(maxLines / 2))
                        {
                            result.AppendLine($"+ {line}");
                        }
                        
                        if (addedLines.Count > maxLines / 2)
                        {
                            result.AppendLine($"+ ... v√† {addedLines.Count - maxLines / 2} d√≤ng th√™m kh√°c...");
                        }
                    }
                }
                else
                {
                    result.AppendLine("Kh√¥ng ph√°t hi·ªán thay ƒë·ªïi");
                }
                
                return result.ToString();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating diff summary: {Message}", ex.Message);
                return "Error generating diff";
            }
        }
        
        private List<string> FilterLines(string content, bool ignoreWhitespace, bool ignoreCase, bool ignoreCommentChanges, bool ignoreDateTimeChanges)
        {
            return content.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(line => {
                    // Apply filters based on configuration
                    if (ignoreWhitespace)
                        line = line.Trim();
                    if (ignoreCase)
                        line = line.ToLowerInvariant();
                    if (ignoreCommentChanges && (line.TrimStart().StartsWith("!") || line.TrimStart().StartsWith("//")))
                        return null; // Skip comment lines
                    if (ignoreDateTimeChanges && (line.Contains("uptime") || line.Contains("Last configuration change")))
                        return null; // Skip timestamp lines
                    return line;
                })
                .Where(line => line != null)
                .ToList();
        }
        
        private List<string> PrioritizeImportantChanges(List<string> lines)
        {
            // Keywords that indicate important configuration changes
            var importantKeywords = new[] {
                "interface", "ip address", "router", "hostname", "enable", "password", 
                "crypto", "access-list", "route", "nat", "firewall", "policy", "vlan", 
                "security", "username", "service", "tunnel"
            };
            
            // Prioritize lines containing important keywords
            var prioritized = lines
                .Select(line => new { 
                    Line = line, 
                    Priority = importantKeywords.Any(k => line.Contains(k, StringComparison.OrdinalIgnoreCase)) ? 0 : 1
                })
                .OrderBy(x => x.Priority)
                .Select(x => x.Line)
                .ToList();
                
            return prioritized;
        }
        
        private string ConvertMarkdownToHtml(string markdown)
        {
            var result = new StringBuilder();
            var chars = markdown.ToCharArray();
            var i = 0;
            var openTags = new Stack<char>();

            while (i < chars.Length)
            {
                switch (chars[i])
                {
                    case '*':
                        if (openTags.Count > 0 && openTags.Peek() == '*')
                        {
                            result.Append("</b>");
                            openTags.Pop();
                        }
                        else
                        {
                            result.Append("<b>");
                            openTags.Push('*');
                        }
                        break;
                    case '_':
                        if (openTags.Count > 0 && openTags.Peek() == '_')
                        {
                            result.Append("</i>");
                            openTags.Pop();
                        }
                        else
                        {
                            result.Append("<i>");
                            openTags.Push('_');
                        }
                        break;
                    case '`':
                        if (i + 2 < chars.Length && chars[i + 1] == '`' && chars[i + 2] == '`')
                        {
                            // Handle code blocks (```
                            if (openTags.Count > 0 && openTags.Peek() == '3')
                            {
                                result.Append("</pre>");
                                openTags.Pop();
                            }
                            else
                            {
                                result.Append("<pre>");
                                openTags.Push('3');
                            }
                            i += 2; // Skip the next two backticks
                        }
                        else
                        {
                            // Handle inline code (`
                            if (openTags.Count > 0 && openTags.Peek() == '`')
                            {
                                result.Append("</code>");
                                openTags.Pop();
                            }
                            else
                            {
                                result.Append("<code>");
                                openTags.Push('`');
                            }
                        }
                        break;
                    default:
                        result.Append(chars[i]);
                        break;
                }
                i++;
            }

            // Close any remaining open tags
            while (openTags.Count > 0)
            {
                var tag = openTags.Pop();
                switch (tag)
                {
                    case '*':
                        result.Append("</b>");
                        break;
                    case '_':
                        result.Append("</i>");
                        break;
                    case '`':
                        result.Append("</code>");
                        break;
                    case '3':
                        result.Append("</pre>");
                        break;
                }
            }

            return result.ToString();
        }
        
        public void Dispose()
        {
            _consolidationTimer?.Stop();
            _consolidationTimer?.Dispose();
            
            _dailySummaryTimer?.Stop();
            _dailySummaryTimer?.Dispose();
        }
    }
}
```

### NCM3\Services\WebhookNotificationService.cs
```cs
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NCM3.Models;

namespace NCM3.Services
{
    public interface IWebhookNotificationService
    {
        Task SendWebhookNotificationAsync(string eventType, object payload);
    }
      public class WebhookNotificationService : IWebhookNotificationService
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<WebhookNotificationService> _logger;
        private readonly IConfiguration _configuration;
        private readonly NotificationLogger? _notificationLogger;
        
        public WebhookNotificationService(
            HttpClient httpClient,
            ILogger<WebhookNotificationService> logger,
            IConfiguration configuration,
            NotificationLogger? notificationLogger = null)
        {
            _httpClient = httpClient;
            _logger = logger;
            _configuration = configuration;
            _notificationLogger = notificationLogger;
        }
          public async Task SendWebhookNotificationAsync(string eventType, object payload)
        {
            var webhookUrl = _configuration["Notification:WebhookUrl"];
            if (string.IsNullOrEmpty(webhookUrl))
            {
                _logger.LogWarning("Webhook kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. B·ªè qua g·ª≠i th√¥ng b√°o.");
                return;
            }
            
            try
            {
                var notificationPayload = new
                {
                    eventType,
                    timestamp = DateTime.UtcNow,
                    data = payload
                };
                
                var content = new StringContent(
                    JsonConvert.SerializeObject(notificationPayload),
                    Encoding.UTF8,
                    "application/json");
                
                var response = await _httpClient.PostAsync(webhookUrl, content);
                response.EnsureSuccessStatusCode();
                
                _logger.LogInformation(
                    "G·ª≠i webhook th√†nh c√¥ng cho s·ª± ki·ªán {EventType}",
                    eventType);
                  // Ghi log th√¥ng b√°o
                if (_notificationLogger != null)
                {
                    // X√°c ƒë·ªãnh lo·∫°i th√¥ng b√°o d·ª±a tr√™n eventType
                    if (eventType == "configuration_change")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var configData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogConfigurationChangeNotificationAsync(
                            configData?.routerName?.ToString() ?? "Unknown",
                            configData?.changeType?.ToString() ?? "Unknown",
                            configData?.diffDetails?.ToString() ?? "No details",
                            true);
                    }
                    else if (eventType == "connectivity_alert")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var connectData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogConnectivityNotificationAsync(
                            connectData?.routerName?.ToString() ?? "Unknown",
                            connectData?.status?.ToString() ?? "Unknown",
                            connectData?.details?.ToString() ?? "No details",
                            true);
                    }
                    else if (eventType == "compliance_alert")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var complianceData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogComplianceNotificationAsync(
                            complianceData?.routerName?.ToString() ?? "Unknown",
                            complianceData?.ruleName?.ToString() ?? "Unknown",
                            complianceData?.severity?.ToString() ?? "Unknown",
                            complianceData?.details?.ToString() ?? "No details",
                            true);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "L·ªói khi g·ª≠i webhook cho s·ª± ki·ªán {EventType}: {Message}",
                    eventType,
                    ex.Message);
                  // Ghi log th√¥ng b√°o
                if (_notificationLogger != null)
                {
                    try
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var data = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        string routerName = data?.routerName?.ToString() ?? "Unknown";
                        
                        if (eventType == "configuration_change")
                        {
                            await _notificationLogger.LogConfigurationChangeNotificationAsync(
                                routerName,
                                data?.changeType?.ToString() ?? "Unknown",
                                $"L·ªói g·ª≠i webhook: {ex.Message}",
                                false);
                        }
                    }
                    catch
                    {
                        // B·ªè qua l·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu payload
                        _logger.LogWarning("Kh√¥ng th·ªÉ ghi log th√¥ng b√°o do ƒë·ªãnh d·∫°ng d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá");
                    }
                }
            }
        }
    }
}

```

### NCM3\Services\ChangeDetection\ChangeDetectionOrchestrator.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Orchestrates multiple configuration change detection strategies
    /// </summary>
    public class ChangeDetectionOrchestrator : BackgroundService
    {        private readonly ILogger<ChangeDetectionOrchestrator> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<IEnumerable<IChangeDetectionStrategy>> _strategiesFactory;
        private readonly IEventBus _eventBus;
        
        public ChangeDetectionOrchestrator(
            ILogger<ChangeDetectionOrchestrator> logger,
            IConfiguration configuration,
            Func<IEnumerable<IChangeDetectionStrategy>> strategiesFactory,
            IEventBus eventBus)
        {
            _logger = logger;
            _configuration = configuration;
            _strategiesFactory = strategiesFactory;
            _eventBus = eventBus;
        }
        
        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            try
            {
                _logger.LogInformation("Starting Change Detection Orchestrator");
                  // Initialize all strategies
                var strategies = _strategiesFactory();
                foreach (var strategy in strategies)
                {
                    try
                    {
                        await strategy.InitializeAsync(stoppingToken);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error initializing strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
                
                // Start all enabled strategies
                foreach (var strategy in strategies)
                {
                    try
                    {
                        if (strategy.IsEnabled)
                        {
                            await strategy.StartDetectionAsync(_eventBus, stoppingToken);
                            _logger.LogInformation("Started change detection strategy: {StrategyName} (Priority: {Priority})",
                                strategy.Name, strategy.Priority);
                        }
                        else
                        {
                            _logger.LogInformation("Strategy {StrategyName} is disabled and will not be started",
                                strategy.Name);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error starting strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
                
                // Keep the service running until cancellation is requested
                while (!stoppingToken.IsCancellationRequested)
                {
                    await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
                }
            }
            catch (OperationCanceledException)
            {
                // Normal cancellation, no need to log an error
                _logger.LogInformation("Change Detection Orchestrator was stopped");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled exception in Change Detection Orchestrator: {ErrorMessage}", ex.Message);
                throw;
            }
            finally
            {                // Clean shutdown - stop all strategies
                var strategies = _strategiesFactory();
                foreach (var strategy in strategies)
                {
                    try
                    {
                        if (strategy.IsEnabled)
                        {
                            await strategy.StopDetectionAsync();
                            _logger.LogInformation("Stopped change detection strategy: {StrategyName}", strategy.Name);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error stopping strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
            }
        }
    }
}

```

### NCM3\Services\ChangeDetection\ChangeDetectionStrategy.cs
```cs

```

### NCM3\Services\ChangeDetection\IChangeDetectionStrategy.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Interface defining the contract for configuration change detection strategies
    /// </summary>
    public interface IChangeDetectionStrategy
    {
        /// <summary>
        /// Name of the strategy
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// Priority level of this detection strategy (lower number = higher priority)
        /// </summary>
        int Priority { get; }
        
        /// <summary>
        /// Whether this strategy is enabled in the configuration
        /// </summary>
        bool IsEnabled { get; }
        
        /// <summary>
        /// Initialize the strategy with any prerequisites
        /// </summary>
        Task InitializeAsync(CancellationToken stoppingToken = default);
        
        /// <summary>
        /// Start the detection process
        /// </summary>
        /// <param name="eventBus">Event bus to publish change events</param>
        /// <param name="stoppingToken">Cancellation token</param>
        Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default);
        
        /// <summary>
        /// Stop the detection process
        /// </summary>
        Task StopDetectionAsync();
        
        /// <summary>
        /// Check a specific router for changes
        /// </summary>
        /// <param name="router">The router to check</param>
        /// <param name="eventBus">Event bus to publish change events</param>
        /// <returns>True if changes were detected, false otherwise</returns>
        Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus);
    }
}
```

### NCM3\Services\ChangeDetection\SNMPPollingStrategy.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;
using System.Net;
using SnmpSharpNet;
using Microsoft.EntityFrameworkCore;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Uses SNMP polling to detect configuration changes on routers
    /// </summary>
    public class SNMPPollingStrategy : IChangeDetectionStrategy
    {
        private readonly ILogger<SNMPPollingStrategy> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<RouterService> _routerServiceFactory;
        private readonly Func<NCMDbContext> _dbContextFactory;
        private readonly Dictionary<int, DateTime> _lastModifiedTimes = new();
        private System.Timers.Timer? _pollingTimer;
        private IEventBus? _eventBus;
        private CancellationToken _stoppingToken;
        
        public string Name => "SNMP Polling";
        public int Priority => 1; // Higher priority than SSH (lower number = higher priority)
        
        public bool IsEnabled
        {
            get
            {
                return _configuration.GetValue<bool>("ChangeDetection:Strategies:SNMPPolling:Enabled", false);
            }
        }
        
        private int PollingIntervalMinutes
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:IntervalMinutes", 5);
            }
        }
          private string OidConfigLastChanged
        {
            get
            {
                return _configuration.GetValue<string>(
                    "ChangeDetection:Strategies:SNMPPolling:OIDConfigLastChanged", 
                    "1.3.6.1.4.1.9.9.43.1.1.1.0") ?? "1.3.6.1.4.1.9.9.43.1.1.1.0";
            }
        }
        
        private string SnmpCommunity
        {
            get
            {
                return _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Community", "public") ?? "public";
            }
        }
          private string SnmpVersionSetting
        {
            get
            {
                return _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Version", "Auto") ?? "Auto";
            }
        }
        
        private int SnmpTimeout
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Timeout", 2000);
            }
        }
        
        private int SnmpRetries
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Retries", 2);
            }
        }
        
        private int SnmpPort
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Port", 161);
            }
        }

        public SNMPPollingStrategy(
            ILogger<SNMPPollingStrategy> logger,
            IConfiguration configuration,
            Func<RouterService> routerServiceFactory,
            Func<NCMDbContext> dbContextFactory)
        {
            _logger = logger;
            _configuration = configuration;
            _routerServiceFactory = routerServiceFactory;
            _dbContextFactory = dbContextFactory;
        }
        
        public Task InitializeAsync(CancellationToken stoppingToken = default)
        {
            _stoppingToken = stoppingToken;
            _logger.LogInformation("Initializing SNMP Polling Strategy");
            
            return Task.CompletedTask;
        }
        
        public Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default)
        {
            if (!IsEnabled)
            {
                _logger.LogInformation("SNMP Polling Strategy is disabled, not starting");
                return Task.CompletedTask;
            }
            
            _eventBus = eventBus;
            _stoppingToken = stoppingToken;
            
            _logger.LogInformation("Starting SNMP Polling Strategy with interval of {IntervalMinutes} minutes", 
                PollingIntervalMinutes);
            
            // Setup timer for polling
            _pollingTimer = new System.Timers.Timer(PollingIntervalMinutes * 60 * 1000); // Convert to milliseconds
            _pollingTimer.Elapsed += OnPollingTimerElapsed;
            _pollingTimer.AutoReset = true;
            _pollingTimer.Start();
            
            // Run an initial check immediately
            Task.Run(RunPollingCycle);
            
            return Task.CompletedTask;
        }
        
        public Task StopDetectionAsync()
        {
            _logger.LogInformation("Stopping SNMP Polling Strategy");
            
            _pollingTimer?.Stop();
            _pollingTimer?.Dispose();
            _pollingTimer = null;
            
            return Task.CompletedTask;
        }
        
        private void OnPollingTimerElapsed(object? sender, ElapsedEventArgs e)
        {
            // Don't start a new polling cycle if the previous one is still running
            if (_pollingTask == null || _pollingTask.IsCompleted)
            {
                _pollingTask = RunPollingCycle();
            }
            else
            {
                _logger.LogWarning("Previous SNMP polling cycle still running, skipping this cycle");
            }
        }
        
        private Task? _pollingTask;
        
        private async Task RunPollingCycle()
        {
            try
            {
                _logger.LogDebug("Running SNMP polling cycle");
                
                if (_stoppingToken.IsCancellationRequested)
                {
                    return;
                }
                
                if (_eventBus == null)
                {
                    _logger.LogError("Event bus not set for SNMP Polling Strategy");
                    return;
                }
                
                // Get all routers
                using var dbContext = _dbContextFactory();
                var routers = await dbContext.Routers.ToListAsync();
                
                foreach (var router in routers)
                {
                    if (_stoppingToken.IsCancellationRequested)
                    {
                        break;
                    }
                    
                    if (!router.IsAvailable)
                    {
                        _logger.LogDebug("Skipping unavailable router: {RouterName}", router.Hostname);
                        continue;
                    }
                    
                    try
                    {
                        await CheckForChangesAsync(router, _eventBus);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error checking for changes on router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SNMP polling cycle: {ErrorMessage}", ex.Message);
            }
        }
        
        public async Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus)
        {
            if (!IsEnabled)
            {
                return false;
            }
              _logger.LogDebug("Checking for changes via SNMP on router {RouterName}", router.Hostname);
            
            // Validate IP address
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogWarning("Router {RouterName} has no IP address configured", router.Hostname);
                return false;
            }
            
            try
            {
                // Try to parse the IP address, which may fail if the IP is invalid
                if (!IPAddress.TryParse(router.IpAddress, out IPAddress? ipAddress))
                {
                    _logger.LogWarning("Router {RouterName} has invalid IP address: {IPAddress}", 
                        router.Hostname, router.IpAddress);
                    return false;
                }
                
                var community = new OctetString(SnmpCommunity);
                var param = new AgentParameters(community);
                var target = new UdpTarget(ipAddress, SnmpPort, SnmpTimeout, SnmpRetries);
                
                try
                {
                    // Create Pdu for SNMP GET
                    var pdu = new Pdu(PduType.Get);
                    var oid = new Oid(OidConfigLastChanged);
                    pdu.VbList.Add(oid);
                      // Determine SNMP version to use based on config
                    string snmpVersion = SnmpVersionSetting?.ToLower() ?? "auto";
                    string versionUsed = "";
                    SnmpPacket? result = null;
                    
                    if (snmpVersion == "v1" || snmpVersion == "1")
                    {
                        // Use SNMPv1
                        param.Version = SnmpSharpNet.SnmpVersion.Ver1;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv1";
                    }
                    else if (snmpVersion == "v2" || snmpVersion == "v2c" || snmpVersion == "2")
                    {
                        // Use SNMPv2c
                        param.Version = SnmpSharpNet.SnmpVersion.Ver2;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv2c";
                    }
                    else // "auto" or any other value
                    {
                        // Try SNMPv2c first, then fallback to SNMPv1 if it fails
                        try
                        {
                            param.Version = SnmpSharpNet.SnmpVersion.Ver2;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv2c";
                        }
                        catch (Exception ex)
                        {
                            _logger.LogInformation("SNMPv2c request failed for router {RouterName}, falling back to SNMPv1: {ErrorMessage}", 
                                router.Hostname, ex.Message);
                            
                            // Reset PDU for new request
                            pdu = new Pdu(PduType.Get);
                            pdu.VbList.Add(oid);
                            
                            param.Version = SnmpSharpNet.SnmpVersion.Ver1;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv1";
                        }
                    }
                    
                    // Process the result based on the actual type returned
                    if (result != null)
                    {
                        string? lastModifiedSnmp = null;
                        bool success = false;
                        
                        if (result is SnmpV2Packet v2Packet && v2Packet.Pdu.ErrorStatus == 0)
                        {
                            foreach (var vb in v2Packet.Pdu.VbList)
                            {
                                if (vb.Oid.ToString() == OidConfigLastChanged)
                                {
                                    lastModifiedSnmp = vb.Value.ToString();
                                    success = true;
                                }
                            }
                        }
                        else if (result is SnmpV1Packet v1Packet && v1Packet.Pdu.ErrorStatus == 0)
                        {
                            foreach (var vb in v1Packet.Pdu.VbList)
                            {
                                if (vb.Oid.ToString() == OidConfigLastChanged)
                                {
                                    lastModifiedSnmp = vb.Value.ToString();
                                    success = true;
                                }
                            }
                        }
                        
                        if (success && lastModifiedSnmp != null)
                        {
                            // The value is in TimeTicks (1/100th seconds since device boot)
                            // We need to convert it to a DateTime
                            if (long.TryParse(lastModifiedSnmp, out long ticks))
                            {
                                // Convert timeticks (in 1/100 seconds) to DateTime
                                var lastModified = DateTime.UtcNow.AddMilliseconds(-(ticks * 10));
                                
                                // Check if we have seen this router before
                                if (_lastModifiedTimes.TryGetValue(router.Id, out var lastRecordedTime))
                                {
                                    if (lastModified > lastRecordedTime)
                                    {
                                        _logger.LogInformation(
                                            "Detected configuration change on router {RouterName} via SNMP ({Version}). " +
                                            "Last modified time: {LastModified}, previous recorded time: {PreviousTime}",
                                            router.Hostname, versionUsed, lastModified, lastRecordedTime);
                                        
                                        // Update last modified time
                                        _lastModifiedTimes[router.Id] = lastModified;
                                        
                                        // Get the current configuration to send the change event
                                        using var routerService = _routerServiceFactory();
                                        var currentConfig = await routerService.GetConfigurationAsync(router);
                                        var lastConfig = router.RouterConfigurations
                                            .OrderByDescending(c => c.BackupDate)
                                            .FirstOrDefault();
                                        
                                        // Only raise event if we have both configs and they're different
                                        if (lastConfig != null && lastConfig.Content != currentConfig)
                                        {
                                            // Determine priority based on config differences
                                            var priority = DeterminePriority(lastConfig.Content, currentConfig);
                                            
                                            var configChangedEvent = new ConfigurationChangedEvent(
                                                router,
                                                lastConfig?.Content ?? string.Empty,
                                                currentConfig,
                                                priority,
                                                Name,
                                                $"Configuration change detected via SNMP polling ({versionUsed})");
                                            
                                            await eventBus.PublishAsync(configChangedEvent);
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // First time seeing this router, just record the time
                                    _lastModifiedTimes[router.Id] = lastModified;
                                    _logger.LogInformation(
                                        "Established baseline SNMP time for router {RouterName} ({Version}): {LastModified}",
                                        router.Hostname, versionUsed, lastModified);
                                }
                            }
                            else if (TryParseUptimeString(lastModifiedSnmp, out var lastModified))
                            {
                                // Check if we have seen this router before
                                if (_lastModifiedTimes.TryGetValue(router.Id, out var lastRecordedTime))
                                {
                                    if (lastModified > lastRecordedTime)
                                    {
                                        _logger.LogInformation(
                                            "Detected configuration change on router {RouterName} via SNMP ({Version}). " +
                                            "Last modified time: {LastModified}, previous recorded time: {PreviousTime}",
                                            router.Hostname, versionUsed, lastModified, lastRecordedTime);
                                        
                                        // Update last modified time
                                        _lastModifiedTimes[router.Id] = lastModified;
                                        
                                        // Get the current configuration to send the change event
                                        using var routerService = _routerServiceFactory();
                                        var currentConfig = await routerService.GetConfigurationAsync(router);
                                        var lastConfig = router.RouterConfigurations
                                            .OrderByDescending(c => c.BackupDate)
                                            .FirstOrDefault();
                                        
                                        // Only raise event if we have both configs and they're different
                                        if (lastConfig != null && lastConfig.Content != currentConfig)
                                        {
                                            // Determine priority based on config differences
                                            var priority = DeterminePriority(lastConfig.Content, currentConfig);
                                            
                                            var configChangedEvent = new ConfigurationChangedEvent(
                                                router,
                                                lastConfig?.Content ?? string.Empty,
                                                currentConfig,
                                                priority,
                                                Name,
                                                $"Configuration change detected via SNMP polling ({versionUsed})");
                                            
                                            await eventBus.PublishAsync(configChangedEvent);
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // First time seeing this router, just record the time
                                    _lastModifiedTimes[router.Id] = lastModified;
                                    _logger.LogInformation(
                                        "Established baseline SNMP time for router {RouterName} ({Version}): {LastModified}",
                                        router.Hostname, versionUsed, lastModified);
                                }
                            }
                            else
                            {
                                _logger.LogWarning("Could not parse SNMP time ticks for router {RouterName}: {Ticks}",
                                    router.Hostname, lastModifiedSnmp);
                            }
                        }
                        else
                        {
                            string errorStatus = "unknown";
                            int errorIndex = -1;
                            
                            if (result is SnmpV2Packet v2P)
                            {
                                errorStatus = v2P.Pdu.ErrorStatus.ToString();
                                errorIndex = v2P.Pdu.ErrorIndex;
                            }
                            else if (result is SnmpV1Packet v1P)
                            {
                                errorStatus = v1P.Pdu.ErrorStatus.ToString();
                                errorIndex = v1P.Pdu.ErrorIndex;
                            }
                            
                            _logger.LogWarning("SNMP GET failed for router {RouterName} using {Version}. Error: {ErrorStatus}, Index: {ErrorIndex}",
                                router.Hostname, versionUsed, errorStatus, errorIndex);
                        }
                    }
                    else
                    {
                        _logger.LogWarning("No SNMP response received from router {RouterName} using {Version}",
                            router.Hostname, versionUsed);
                    }
                }
                finally
                {
                    target.Close();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking SNMP for router {RouterName}: {ErrorMessage}",
                    router.Hostname, ex.Message);
            }
            
            return false;
        }
        
        private string DeterminePriority(string oldConfig, string newConfig)
        {
            // This is a simplified example of priority determination
            // In a real implementation, you would perform more sophisticated analysis
            
            if (ContainsSecurityChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsInterfaceChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsRouteChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            if (ContainsACLChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            return "Low";
        }
        
        private bool ContainsSecurityChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "password", "secret", "key", "enable secret", "crypto", "ssh",
                "authentication", "authorization"
            });
        }
        
        private bool ContainsInterfaceChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "interface", "shutdown", "ip address", "no shutdown", "mtu"
            });
        }
        
        private bool ContainsRouteChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "ip route", "router ospf", "router bgp", "router eigrp", "network"
            });
        }
        
        private bool ContainsACLChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "access-list", "permit", "deny", "ip access-group"
            });
        }
        
        private bool ContainsAnyKeyword(string oldConfig, string newConfig, string[] keywords)
        {
            // Get the diff as a list of line changes
            var diffLines = GetDiffLines(oldConfig, newConfig);
            
            foreach (var line in diffLines)
            {
                foreach (var keyword in keywords)
                {
                    if (line.Contains(keyword, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private List<string> GetDiffLines(string oldConfig, string newConfig)
        {
            // This is a simple diff implementation
            // In a real implementation, you'd use a proper diff algorithm
            var oldLines = oldConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var newLines = newConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            
            var result = new List<string>();
            
            // Just collect lines that are in new but not in old
            foreach (var line in newLines)
            {
                if (!oldLines.Contains(line))
                {
                    result.Add(line);
                }
            }
            
            return result;
        }
        
        private bool TryParseUptimeString(string uptime, out DateTime lastChanged)
        {
            lastChanged = DateTime.MinValue;
            try
            {
                int days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
                var parts = uptime.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                foreach (var part in parts)
                {
                    if (part.EndsWith("d")) int.TryParse(part.TrimEnd('d'), out days);
                    else if (part.EndsWith("h")) int.TryParse(part.TrimEnd('h'), out hours);
                    else if (part.EndsWith("m") && !part.EndsWith("ms")) int.TryParse(part.TrimEnd('m'), out minutes);
                    else if (part.EndsWith("s") && !part.EndsWith("ms")) int.TryParse(part.TrimEnd('s'), out seconds);
                    else if (part.EndsWith("ms")) int.TryParse(part.TrimEnd("ms".ToCharArray()), out milliseconds);
                }
                var span = new TimeSpan(days, hours, minutes, seconds, milliseconds);
                lastChanged = DateTime.UtcNow - span;
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}
```

### NCM3\Services\ChangeDetection\SNMPVerificationService.cs
```cs

```

### NCM3\Services\ChangeDetection\SSHPollingStrategy.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;
using System.Linq;
using Microsoft.EntityFrameworkCore;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Uses SSH polling to detect configuration changes on routers with a lower frequency than SNMP polling
    /// </summary>
    public class SSHPollingStrategy : IChangeDetectionStrategy
    {        private readonly ILogger<SSHPollingStrategy> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<RouterService> _routerServiceFactory;
        private readonly Func<NCMDbContext> _dbContextFactory;
        private readonly Dictionary<int, DateTime> _lastBackupDates = new();
        private readonly Dictionary<int, string> _lastKnownConfigurations = new();
        private System.Timers.Timer? _pollingTimer;
        private IEventBus? _eventBus;
        private CancellationToken _stoppingToken;
        
        public string Name => "SSH Polling";
        public int Priority => 2; // Lower priority than SNMP (higher number = lower priority)
        
        public bool IsEnabled
        {
            get
            {
                return _configuration.GetValue<bool>("ChangeDetection:Strategies:SSHPolling:Enabled", false);
            }
        }
        
        private int PollingIntervalHours
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SSHPolling:IntervalHours", 24);
            }
        }          public SSHPollingStrategy(
            ILogger<SSHPollingStrategy> logger,
            IConfiguration configuration,
            Func<RouterService> routerServiceFactory,
            Func<NCMDbContext> dbContextFactory)
        {
            _logger = logger;
            _configuration = configuration;
            _routerServiceFactory = routerServiceFactory;
            _dbContextFactory = dbContextFactory;
        }
        
        public Task InitializeAsync(CancellationToken stoppingToken = default)
        {
            _stoppingToken = stoppingToken;
            _logger.LogInformation("Initializing SSH Polling Strategy");
            
            return Task.CompletedTask;
        }
        
        public Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default)
        {
            if (!IsEnabled)
            {
                _logger.LogInformation("SSH Polling Strategy is disabled, not starting");
                return Task.CompletedTask;
            }
            
            _eventBus = eventBus;
            _stoppingToken = stoppingToken;
            
            _logger.LogInformation("Starting SSH Polling Strategy with interval of {IntervalHours} hours", 
                PollingIntervalHours);
            
            // Setup timer for polling
            _pollingTimer = new System.Timers.Timer(PollingIntervalHours * 60 * 60 * 1000); // Convert to milliseconds
            _pollingTimer.Elapsed += OnPollingTimerElapsed;
            _pollingTimer.AutoReset = true;
            _pollingTimer.Start();
            
            // Run an initial check immediately
            Task.Run(RunPollingCycle);
            
            return Task.CompletedTask;
        }
        
        public Task StopDetectionAsync()
        {
            _logger.LogInformation("Stopping SSH Polling Strategy");
            
            _pollingTimer?.Stop();
            _pollingTimer?.Dispose();
            _pollingTimer = null;
            
            return Task.CompletedTask;
        }
        
        private void OnPollingTimerElapsed(object? sender, ElapsedEventArgs e)
        {
            // Don't start a new polling cycle if the previous one is still running
            if (_pollingTask == null || _pollingTask.IsCompleted)
            {
                _pollingTask = RunPollingCycle();
            }
            else
            {
                _logger.LogWarning("Previous SSH polling cycle still running, skipping this cycle");
            }
        }
        
        private Task? _pollingTask;
        
        private async Task RunPollingCycle()
        {
            try
            {
                _logger.LogDebug("Running SSH polling cycle");
                
                if (_stoppingToken.IsCancellationRequested)
                {
                    return;
                }
                
                if (_eventBus == null)
                {
                    _logger.LogError("Event bus not set for SSH Polling Strategy");
                    return;
                }                // Get all routers using a scoped DbContext
                using var dbContext = _dbContextFactory();
                var routers = await dbContext.Routers.ToListAsync();
                
                foreach (var router in routers)
                {
                    if (_stoppingToken.IsCancellationRequested)
                    {
                        break;
                    }
                    
                    if (!router.IsAvailable)
                    {
                        _logger.LogDebug("Skipping unavailable router: {RouterName}", router.Hostname);
                        continue;
                    }
                    
                    try
                    {
                        await CheckForChangesAsync(router, _eventBus);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error checking for changes on router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SSH polling cycle: {ErrorMessage}", ex.Message);
            }
        }
        
        public async Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus)
        {
            if (!IsEnabled)
            {
                return false;
            }
            
            _logger.LogDebug("Checking for changes via SSH on router {RouterName}", router.Hostname);
            
            try
            {                // Get the current configuration via SSH using a scoped RouterService
                using var routerService = _routerServiceFactory();
                string currentConfig = await routerService.GetConfigurationAsync(router);
                
                // If it's an error message, skip this router
                if (currentConfig.StartsWith("Error:"))
                {
                    _logger.LogWarning("Unable to retrieve configuration from router {RouterName}: {ErrorMessage}",
                        router.Hostname, currentConfig);
                    return false;
                }
                
                // Check if we have seen this router before
                if (_lastKnownConfigurations.TryGetValue(router.Id, out var lastConfig))
                {
                    // If the configuration has changed
                    if (lastConfig != currentConfig)
                    {
                        _logger.LogInformation(
                            "Detected configuration change on router {RouterName} via SSH polling.",
                            router.Hostname);
                        
                        // Update our cached configuration
                        _lastKnownConfigurations[router.Id] = currentConfig;
                        _lastBackupDates[router.Id] = DateTime.UtcNow;
                        
                        // Determine priority based on config differences
                        var priority = DeterminePriority(lastConfig, currentConfig);
                        
                        var configChangedEvent = new ConfigurationChangedEvent(
                            router,
                            lastConfig,
                            currentConfig,
                            priority,
                            Name,
                            "Configuration change detected via SSH polling");
                        
                        await eventBus.PublishAsync(configChangedEvent);
                        return true;
                    }
                }
                else
                {
                    // First time seeing this router or first run
                    _logger.LogInformation("Initial configuration captured for router {RouterName} via SSH", 
                        router.Hostname);
                    
                    _lastKnownConfigurations[router.Id] = currentConfig;
                    _lastBackupDates[router.Id] = DateTime.UtcNow;
                    
                    // Get the latest configuration from the database for comparison
                    var dbConfig = router.RouterConfigurations
                        .OrderByDescending(c => c.BackupDate)
                        .FirstOrDefault();
                        
                    if (dbConfig != null && dbConfig.Content != currentConfig)
                    {
                        _logger.LogInformation(
                            "Detected difference between database configuration and current configuration for router {RouterName}",
                            router.Hostname);
                            
                        // Determine priority based on config differences
                        var priority = DeterminePriority(dbConfig.Content, currentConfig);
                        
                        var configChangedEvent = new ConfigurationChangedEvent(
                            router,
                            dbConfig.Content,
                            currentConfig,
                            priority,
                            Name,
                            "Configuration change detected during initial SSH poll");
                        
                        await eventBus.PublishAsync(configChangedEvent);
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking SSH for router {RouterName}: {ErrorMessage}",
                    router.Hostname, ex.Message);
            }
            
            return false;
        }
        
        private string DeterminePriority(string oldConfig, string newConfig)
        {
            // Use the same priority determination as SNMP strategy for consistency
            if (ContainsSecurityChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsInterfaceChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsRouteChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            if (ContainsACLChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            return "Low";
        }
        
        private bool ContainsSecurityChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "password", "secret", "key", "enable secret", "crypto", "ssh",
                "authentication", "authorization"
            });
        }
        
        private bool ContainsInterfaceChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "interface", "shutdown", "ip address", "no shutdown", "mtu"
            });
        }
        
        private bool ContainsRouteChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "ip route", "router ospf", "router bgp", "router eigrp", "network"
            });
        }
        
        private bool ContainsACLChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "access-list", "permit", "deny", "ip access-group"
            });
        }
        
        private bool ContainsAnyKeyword(string oldConfig, string newConfig, string[] keywords)
        {
            // Get the diff as a list of line changes
            var diffLines = GetDiffLines(oldConfig, newConfig);
            
            foreach (var line in diffLines)
            {
                foreach (var keyword in keywords)
                {
                    if (line.Contains(keyword, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private List<string> GetDiffLines(string oldConfig, string newConfig)
        {
            // This is a simple diff implementation
            // In a real implementation, you'd use a proper diff algorithm
            var oldLines = oldConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var newLines = newConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            
            var result = new List<string>();
            
            // Just collect lines that are in new but not in old
            foreach (var line in newLines)
            {
                if (!oldLines.Contains(line))
                {
                    result.Add(line);
                }
            }
            
            return result;
        }
    }
}
```

### NCM3\Services\Events\ConfigurationChangedEvent.cs
```cs
using System;
using NCM3.Models;

namespace NCM3.Services.Events
{
    /// <summary>
    /// Event raised when a router's configuration has changed
    /// </summary>
    public class ConfigurationChangedEvent : IEvent
    {
        /// <summary>
        /// When the event occurred
        /// </summary>
        public DateTime Timestamp { get; } = DateTime.UtcNow;
        
        /// <summary>
        /// Unique identifier for the event
        /// </summary>
        public Guid Id { get; } = Guid.NewGuid();
        
        /// <summary>
        /// The router that had its configuration changed
        /// </summary>
        public Router Router { get; }
        
        /// <summary>
        /// The old configuration content
        /// </summary>
        public string OldContent { get; }
        
        /// <summary>
        /// The new configuration content
        /// </summary>
        public string NewContent { get; }
        
        /// <summary>
        /// The priority of this change
        /// </summary>
        public string Priority { get; }
        
        /// <summary>
        /// The strategy that detected the change
        /// </summary>
        public string DetectionStrategy { get; }
        
        /// <summary>
        /// A human-readable description of the change
        /// </summary>
        public string ChangeDescription { get; }
        
        public ConfigurationChangedEvent(
            Router router, 
            string oldContent, 
            string newContent, 
            string priority,
            string detectionStrategy,
            string changeDescription)
        {
            Router = router;
            OldContent = oldContent;
            NewContent = newContent;
            Priority = priority;
            DetectionStrategy = detectionStrategy;
            ChangeDescription = changeDescription;
        }
    }
}
```

### NCM3\Services\Events\EventBus.cs
```cs

```

### NCM3\Services\Events\IEventBus.cs
```cs
using System;
using System.Threading.Tasks;

namespace NCM3.Services.Events
{
    /// <summary>
    /// Base interface for application events
    /// </summary>
    public interface IEvent
    {
        /// <summary>
        /// When the event occurred
        /// </summary>
        DateTime Timestamp { get; }
        
        /// <summary>
        /// Unique identifier for the event
        /// </summary>
        Guid Id { get; }
    }
    
    /// <summary>
    /// The event bus interface
    /// </summary>
    public interface IEventBus
    {
        /// <summary>
        /// Publish an event
        /// </summary>
        Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent;
        
        /// <summary>
        /// Subscribe to events of a specific type
        /// </summary>
        void Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
        
        /// <summary>
        /// Unsubscribe from events of a specific type
        /// </summary>
        void Unsubscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
    }
}
```

### NCM3\Services\Events\InMemoryEventBus.cs
```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace NCM3.Services.Events
{
    /// <summary>
    /// An in-memory implementation of the event bus
    /// </summary>
    public class InMemoryEventBus : IEventBus
    {
        private readonly ILogger<InMemoryEventBus> _logger;
        private readonly ConcurrentDictionary<Type, List<Func<IEvent, Task>>> _handlers = new();

        public InMemoryEventBus(ILogger<InMemoryEventBus> logger)
        {
            _logger = logger;
        }

        /// <summary>
        /// Publish an event to all subscribers
        /// </summary>
        public async Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent
        {
            var eventType = typeof(TEvent);
            _logger.LogDebug("Publishing event of type {EventType} with ID {EventId}", eventType.Name, @event.Id);

            if (!_handlers.TryGetValue(eventType, out var handlers))
            {
                _logger.LogDebug("No handlers registered for event type {EventType}", eventType.Name);
                return;
            }

            var tasks = new List<Task>();
            foreach (var handler in handlers.ToList()) // Create a copy to avoid concurrent modification issues
            {
                try
                {
                    tasks.Add(handler(@event));
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error handling event of type {EventType}: {ErrorMessage}", 
                        eventType.Name, ex.Message);
                }
            }

            // Wait for all handlers to complete
            await Task.WhenAll(tasks);
            _logger.LogDebug("All handlers for event type {EventType} completed", eventType.Name);
        }

        /// <summary>
        /// Subscribe to events of a specific type
        /// </summary>
        public void Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent
        {
            var eventType = typeof(TEvent);
            _logger.LogDebug("Subscribing to event type {EventType}", eventType.Name);

            // Wrap the typed handler in a handler that takes IEvent
            Func<IEvent, Task> wrappedHandler = async (e) => 
            {
                if (e is TEvent typedEvent)
                {
                    await handler(typedEvent);
                }
            };

            _handlers.AddOrUpdate(
                eventType,
                new List<Func<IEvent, Task>> { wrappedHandler },
                (_, existingHandlers) =>
                {
                    existingHandlers.Add(wrappedHandler);
                    return existingHandlers;
                });
        }

        /// <summary>
        /// Unsubscribe from events of a specific type
        /// </summary>
        public void Unsubscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent
        {
            // This is a simplified implementation that doesn't actually remove the handler
            // In a real implementation, we would need to track the wrapped handlers
            _logger.LogWarning("Unsubscribe operation not fully implemented for InMemoryEventBus");
        }
    }
}
```

### NCM3\Validators\ModelValidators.cs
```cs
using System;
using FluentValidation;
using NCM3.Models;

namespace NCM3.Validators
{
    public class RouterValidator : AbstractValidator<Router>
    {
        public RouterValidator()
        {
            RuleFor(x => x.Hostname)
                .NotEmpty().WithMessage("T√™n Hostname kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
                .MaximumLength(100).WithMessage("T√™n Hostname kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 100 k√Ω t·ª±")
                .Matches("^[a-zA-Z0-9.-]+$").WithMessage("T√™n Hostname ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ c√°i, s·ªë, d·∫•u ch·∫•m v√† d·∫•u g·∫°ch ngang");
                
            RuleFor(x => x.IpAddress)
                .NotEmpty().WithMessage("ƒê·ªãa ch·ªâ IP kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
                .Matches(@"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                .WithMessage("ƒê·ªãa ch·ªâ IP kh√¥ng h·ª£p l·ªá");
                
            RuleFor(x => x.Username)
                .NotEmpty().WithMessage("T√™n ƒëƒÉng nh·∫≠p kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
                .MaximumLength(50).WithMessage("T√™n ƒëƒÉng nh·∫≠p kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 50 k√Ω t·ª±");
                
            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
        }
    }
    
    public class RouterConfigurationValidator : AbstractValidator<RouterConfiguration>
    {
        public RouterConfigurationValidator()
        {
            RuleFor(x => x.RouterId)
                .GreaterThan(0).WithMessage("RouterId ph·∫£i l·ªõn h∆°n 0");
                
            RuleFor(x => x.BackupDate)
                .NotEmpty().WithMessage("Ng√†y sao l∆∞u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
                
            RuleFor(x => x.Content)
                .NotEmpty().WithMessage("N·ªôi dung c·∫•u h√¨nh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
        }
    }
    
    public class ComplianceRuleValidator : AbstractValidator<ComplianceRule>
    {
        public ComplianceRuleValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("T√™n quy t·∫Øc kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
                .MaximumLength(100).WithMessage("T√™n quy t·∫Øc kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 100 k√Ω t·ª±");
                
            RuleFor(x => x.Pattern)
                .NotEmpty().WithMessage("Bi·ªÉu th·ª©c t√¨m ki·∫øm kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
        }
    }
    
    public class ConfigTemplateValidator : AbstractValidator<ConfigTemplate>
    {
        public ConfigTemplateValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("T√™n template kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
                .MaximumLength(100).WithMessage("T√™n template kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 100 k√Ω t·ª±");
                
            RuleFor(x => x.Content)
                .NotEmpty().WithMessage("N·ªôi dung template kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
        }
    }
}

```

### NCM3\wwwroot\js\site.js
```js
Ôªø// Please see documentation at https://learn.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.

```

### Tests\MSTestSettings.cs
```cs
Ôªø[assembly: Parallelize(Scope = ExecutionScope.MethodLevel)]

```

### Tests\SNMPPollingStrategyTests.cs
```cs

```

### Tests\TelegramNotificationServiceTests.cs
```cs
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using Moq.Protected;
using NCM3.Services;
using System.Threading;

namespace NCM3.Tests
{
    [TestClass]
    public class TelegramNotificationServiceTests
    {
        private IConfiguration _config;
        private Mock<ILogger<TelegramNotificationService>> _loggerMock;
        private Mock<HttpMessageHandler> _handlerMock;
        private HttpClient _httpClient;
        private TelegramNotificationService _service;

        [TestInitialize]
        public void Setup()
        {
            var inMemorySettings = new Dictionary<string, string> {
                {"Telegram:BotToken", "test_bot_token"},
                {"Telegram:ChatId", "test_chat_id"},
                {"Telegram:NotificationFormat", "MarkdownV2"},
                {"Telegram:EnableMarkdownFormatting", "true"}
            };

            _config = new ConfigurationBuilder()
                .AddInMemoryCollection(inMemorySettings)
                .Build();

            _loggerMock = new Mock<ILogger<TelegramNotificationService>>();
            _handlerMock = new Mock<HttpMessageHandler>();
            _httpClient = new HttpClient(_handlerMock.Object);

            // Setup handler mock
            _handlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>()
                )
                .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.OK));

            _service = new TelegramNotificationService(_config, _httpClient, _loggerMock.Object);
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithMarkdownV2_ShouldEscapeSpecialCharacters()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "Testing * special _ characters + [ ] ( )";

            // Act
            await _service.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithCodeBlock_ShouldPreserveFormatting()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "```\nThis is a code block\n```";

            // Act
            await _service.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithHtmlMode_ShouldConvertToHtmlTags()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "*bold text* and _italic text_ and ```code block```";

            // Set HTML mode
            var htmlConfig = new ConfigurationBuilder()
                .AddInMemoryCollection(new Dictionary<string, string> {
                    {"Telegram:BotToken", "test_bot_token"},
                    {"Telegram:ChatId", "test_chat_id"},
                    {"Telegram:NotificationFormat", "HTML"},
                    {"Telegram:EnableMarkdownFormatting", "true"}
                })
                .Build();

            var serviceWithHtml = new TelegramNotificationService(htmlConfig, _httpClient, _loggerMock.Object);

            // Act
            await serviceWithHtml.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }
    }
}

```

### Tests\Test1.cs
```cs
Ôªønamespace NCM3.Tests;

[TestClass]
public sealed class Test1
{
    [TestMethod]
    public void TestMethod1()
    {
    }
}

```
