# ==================================================
# Path: E:\NCM3
# Detected tech: csharp, docker, javascript
# ==================================================

## DIRECTORY STRUCTURE
```
NCM3/
├── .git/
├── .vs/
├── Backups/
│   └── NCM3_Backup_20250523_130036.bak
├── ComplianceRules/
├── ConfigBackups/
├── Logs/
├── NCM3/
│   ├── Constants/
│   │   └── AppConstants.cs
│   ├── Controllers/
│   │   ├── ConfigManagementController.cs
│   │   ├── HomeController.cs
│   │   ├── RestoreController.cs
│   │   ├── RoutersController.cs
│   │   ├── SNMPTestController.cs
│   │   └── SettingsController.cs
│   ├── Extensions/
│   │   ├── AppSettingsExtensions.cs
│   │   ├── LoggingExtensions.cs
│   │   └── ServiceCollectionExtensions.cs
│   ├── Middleware/
│   │   ├── GlobalExceptionHandlerMiddleware.cs
│   │   └── GlobalExceptionHandlerMiddlewareExtensions.cs
│   ├── Migrations/
│   │   ├── 20250516021914_InitialCreate.Designer.cs
│   │   ├── 20250516021914_InitialCreate.cs
│   │   ├── 20250516140127_AddEnablePasswordColumn.cs
│   │   ├── 20250516142445_AddEnablePassword.Designer.cs
│   │   ├── 20250516142445_AddEnablePassword.cs
│   │   ├── 20250520030802_AddRouterConfigurationsNavigation.Designer.cs
│   │   ├── 20250520030802_AddRouterConfigurationsNavigation.cs
│   │   ├── 20250520085538_AddIsAvailableToRouter.Designer.cs
│   │   ├── 20250520085538_AddIsAvailableToRouter.cs
│   │   ├── 20250523025411_AddRouterGroup.Designer.cs
│   │   ├── 20250523025411_AddRouterGroup.cs
│   │   ├── 20250524062658_AddBackupTypeAndCommentToRouterConfiguration.Designer.cs
│   │   ├── 20250524062658_AddBackupTypeAndCommentToRouterConfiguration.cs
│   │   └── NCMDbContextModelSnapshot.cs
│   ├── Models/
│   │   ├── ViewModels/
│   │   │   └── NotificationHistoryViewModel.cs
│   │   ├── AppSettings.cs
│   │   ├── ChangeDetectionSettings.cs
│   │   ├── ComplianceResult.cs
│   │   ├── ComplianceRule.cs
│   │   ├── ConfigTemplate.cs
│   │   ├── ErrorViewModel.cs
│   │   ├── NCMDbContext.cs
│   │   ├── Router.cs
│   │   └── RouterConfiguration.cs
│   ├── Properties/
│   │   └── launchSettings.json
│   ├── Services/
│   │   ├── ChangeDetection/
│   │   │   ├── ChangeDetectionOrchestrator.cs
│   │   │   ├── ChangeDetectionStrategy.cs
│   │   │   ├── IChangeDetectionStrategy.cs
│   │   │   ├── SNMPPollingStrategy.cs
│   │   │   ├── SNMPPollingStrategy.cs.bak
│   │   │   ├── SNMPVerificationService.cs
│   │   │   └── SSHPollingStrategy.cs
│   │   ├── Events/
│   │   │   ├── ConfigurationChangedEvent.cs
│   │   │   ├── EventBus.cs
│   │   │   ├── IEventBus.cs
│   │   │   └── InMemoryEventBus.cs
│   │   ├── AmazonS3Service.cs
│   │   ├── AutomaticConfigurationChangeDetector.cs
│   │   ├── BackupNotificationHandler.cs
│   │   ├── BackupService.cs
│   │   ├── ChangeDetectionOrchestrator.cs
│   │   ├── ConfigurationManagementService.cs
│   │   ├── EncryptionService.cs
│   │   ├── NotificationHelper.cs
│   │   ├── NotificationLogger.cs
│   │   ├── RouterConnectionService.cs
│   │   ├── RouterService.cs
│   │   ├── S3BackupService.cs
│   │   ├── TelegramNotificationService.cs
│   │   └── WebhookNotificationService.cs
│   ├── Validators/
│   │   └── ModelValidators.cs
│   ├── Views/
│   │   ├── ConfigManagement/
│   │   │   ├── Compare.cshtml
│   │   │   ├── CompareSelection.cshtml
│   │   │   ├── CompareWithTemplate.cshtml
│   │   │   ├── CompareWithTemplateSelection.cshtml
│   │   │   ├── ComplianceRules.cshtml
│   │   │   ├── CreateRule.cshtml
│   │   │   ├── CreateTemplate.cshtml
│   │   │   ├── Search.cshtml
│   │   │   ├── SearchResults.cshtml
│   │   │   ├── Templates.cshtml
│   │   │   └── UnifiedCompareWithTemplate.cshtml
│   │   ├── Home/
│   │   │   ├── Index.cshtml
│   │   │   ├── Privacy.cshtml
│   │   │   └── Restore.cshtml
│   │   ├── Routers/
│   │   │   ├── ConfigurationHistory.cshtml
│   │   │   ├── Create.cshtml
│   │   │   ├── DebugSsh.cshtml
│   │   │   ├── Delete.cshtml
│   │   │   ├── Details.cshtml
│   │   │   ├── Edit.cshtml
│   │   │   ├── Index.cshtml
│   │   │   └── ViewConfiguration.cshtml
│   │   ├── Settings/
│   │   │   ├── Index.cshtml
│   │   │   └── NotificationHistory.cshtml
│   │   ├── Shared/
│   │   │   ├── Error.cshtml
│   │   │   ├── _Layout.cshtml
│   │   │   ├── _Layout.cshtml.css
│   │   │   └── _ValidationScriptsPartial.cshtml
│   │   ├── _ViewImports.cshtml
│   │   └── _ViewStart.cshtml
│   ├── bin/
│   ├── logs/
│   ├── obj/
│   ├── wwwroot/
│   │   ├── css/
│   │   │   └── site.css
│   │   ├── js/
│   │   │   └── site.js
│   │   ├── lib/
│   │   └── favicon.ico
│   ├── NCM3.csproj
│   ├── NCM3.csproj.user
│   ├── Program.cs
│   ├── SNMPTimeTester.cs
│   ├── appsettings.Development.json
│   ├── appsettings.json
│   ├── ncm.db
│   └── run-project.bat
├── Templates/
├── Tests/
│   ├── TestResults/
│   │   ├── Deploy_sang5 20250523T110633_30656/
│   │   │   ├── In/
│   │   │   │   └── DESKTOP-4CMFFTN/
│   │   │   └── Out/
│   │   ├── Deploy_sang5 20250523T111122_22204/
│   │   │   ├── In/
│   │   │   │   └── DESKTOP-4CMFFTN/
│   │   │   └── Out/
│   │   ├── Deploy_sang5 20250523T111318_21324/
│   │   │   ├── In/
│   │   │   │   └── DESKTOP-4CMFFTN/
│   │   │   └── Out/
│   │   ├── Deploy_sang5 20250523T111403_13224/
│   │   │   ├── In/
│   │   │   │   └── DESKTOP-4CMFFTN/
│   │   │   └── Out/
│   │   └── Deploy_sang5 20250523T111518_21848/
│   │       ├── In/
│   │       │   └── DESKTOP-4CMFFTN/
│   │       └── Out/
│   ├── bin/
│   ├── obj/
│   ├── MSTestSettings.cs
│   ├── NCM3.Tests.csproj
│   ├── SNMPPollingStrategyTests.cs
│   ├── TelegramNotificationServiceTests.cs
│   └── Test1.cs
├── .env.example
├── Dockerfile
├── NCM3.sln
├── backup-database.bat
├── backup-scheduler.ps1
├── cleanup-backups.ps1
└── docker-compose.yml
```

## FILE CONTENTS

### NCM3\Program.cs
```cs
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Middleware;
using NCM3.Extensions;
using Microsoft.Extensions.Logging;
using Serilog.Extensions.Logging;
using FluentValidation;
using NCM3.Validators;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Amazon.S3;
using Amazon.Extensions.NETCore.Setup;
using Amazon.Runtime;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllersWithViews();

// Configure CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("DefaultPolicy", policy =>
    {
        policy.WithOrigins("https://localhost:5001", "https://localhost:5000") 
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

// Add health checks
builder.Services.AddHealthChecks();

// Add DB context - using SQL Server
builder.Services.AddDbContext<NCMDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// Add services
builder.Services.AddScoped<RouterService>();
builder.Services.AddScoped<RouterConnectionService>();
builder.Services.AddScoped<ConfigurationManagementService>();
builder.Services.AddHttpClient();
builder.Services.AddScoped<ITelegramNotificationService, TelegramNotificationService>();
builder.Services.AddScoped<IWebhookNotificationService, WebhookNotificationService>();
builder.Services.AddSingleton<IEncryptionService, EncryptionService>();
builder.Services.AddScoped<NotificationHelper>();
builder.Services.AddScoped<NotificationLogger>();

// Add AWS S3 services
var awsOptions = builder.Configuration.GetAWSOptions();
// Ensure credentials are explicitly configured from appsettings.json
var accessKey = builder.Configuration["AWS:AccessKeyId"];
var secretKey = builder.Configuration["AWS:SecretAccessKey"];
if (!string.IsNullOrEmpty(accessKey) && !string.IsNullOrEmpty(secretKey))
{
    // Always set credentials explicitly to ensure they're used
    awsOptions.Credentials = new BasicAWSCredentials(accessKey, secretKey);
    Console.WriteLine($"AWS Credentials configured explicitly from appsettings.json");
}
else
{
    Console.WriteLine("Warning: AWS credentials not found in appsettings.json");
}

// Đảm bảo Region được thiết lập
if (awsOptions.Region == null && !string.IsNullOrEmpty(builder.Configuration["AWS:Region"]))
{
    awsOptions.Region = Amazon.RegionEndpoint.GetBySystemName(builder.Configuration["AWS:Region"]);
    Console.WriteLine($"AWS Region set to: {awsOptions.Region?.SystemName}");
}

builder.Services.AddDefaultAWSOptions(awsOptions);
builder.Services.AddAWSService<IAmazonS3>();
builder.Services.AddScoped<IS3BackupService, S3BackupService>();

// Add change detection services
builder.Services.AddChangeDetectionServices();

// Thêm dịch vụ tự động phát hiện thay đổi cấu hình
builder.Services.AddHostedService<AutomaticConfigurationChangeDetector>();

// Thêm dịch vụ xử lý thông báo
builder.Services.AddNotificationServices();

// Thêm File Logger
builder.Services.AddFileLogger(builder.Configuration);

// Cấu hình thư mục sao lưu
builder.Services.ConfigureBackupFolders(builder.Configuration);

// Đăng ký FluentValidation
builder.Services.AddValidatorsFromAssemblyContaining<RouterValidator>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
else
{
    // Trong môi trường phát triển, sử dụng middleware xử lý ngoại lệ toàn cục
    app.UseGlobalExceptionHandler();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

// Thêm CORS
app.UseCors("DefaultPolicy");

// Thêm Security Headers
app.Use(async (context, next) =>
{
    // Các security headers cơ bản
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Append("X-Frame-Options", "SAMEORIGIN");
    context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Append("Referrer-Policy", "strict-origin-when-cross-origin");
    
    // Content-Security-Policy đã được cập nhật để cho phép các nguồn tài nguyên cần thiết
    context.Response.Headers.Append("Content-Security-Policy", 
        "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
        "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; " + 
        "font-src 'self' https://cdn.jsdelivr.net; " + 
        "img-src 'self' data: https:; " +
        "connect-src 'self';"
    );
    
    await next();
});

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

// Map health check endpoint
app.MapHealthChecks("/health");

app.Run();

```

### NCM3\SNMPTimeTester.cs
```cs

```

### NCM3\Constants\AppConstants.cs
```cs
namespace NCM3.Constants
{
    public static class RouterStatus
    {
        public const string Unknown = "Unknown";
        public const string Connected = "Connected";
        public const string Disconnected = "Disconnected";
        public const string Error = "Error";
        public const string ConfigBackupSuccessful = "ConfigBackupSuccessful";
        public const string ConfigBackupFailed = "ConfigBackupFailed";
    }
    
    public static class BackupTypes
    {
        public const string Manual = "Manual";
        public const string Scheduled = "Scheduled";
        public const string PreChange = "PreChange";
        public const string PostChange = "PostChange";
        public const string Automatic = "Automatic"; // Added
    }
    
    public static class DefaultSettings
    {
        public const int SSHPort = 22;
        public const int SSHTimeout = 45; // seconds
        public const int SSHRetryAttempts = 2;
        public const int SSHKeepAliveInterval = 60; // seconds
    }
    
    public static class SSHCommands
    {
        public const string TerminalLength = "terminal length 0";
        public const string ShowRunningConfig = "show running-config";
        public const string Enable = "enable";
    }
    
    public static class NotificationMessages
    {
        public const string ConfigChangeTitle = "🔔 Thay đổi Cấu hình";
        public const string ComplianceCheckTitle = "⚠️ Kiểm tra tuân thủ";
        public const string RouterConnectivityTitle = "🔌 Kết nối thiết bị";
    }
}

```

### NCM3\Controllers\ConfigManagementController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.EntityFrameworkCore;
using DiffPlex.DiffBuilder.Model;
using NCM3.Models;
using NCM3.Services;

namespace NCM3.Controllers
{
    public class ConfigManagementController : Controller
    {
        private readonly NCMDbContext _context;
        private readonly ConfigurationManagementService _configService;

        public ConfigManagementController(NCMDbContext context, ConfigurationManagementService configService)
        {
            _context = context;
            _configService = configService;
        }

        // GET: ConfigManagement/CompareSelection/{routerId}
        public async Task<IActionResult> CompareSelection(int? routerId)
        {
            if (routerId == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(routerId);
            if (router == null)
            {
                return NotFound();
            }

            var configs = await _context.RouterConfigurations
                .Where(c => c.RouterId == routerId)
                .OrderByDescending(c => c.BackupDate)
                .ToListAsync();

            ViewBag.Router = router;
            ViewBag.ConfigList = new SelectList(configs, "Id", "Version");

            return View();
        }

        // POST: ConfigManagement/Compare
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Compare(int configId1, int configId2)
        {
            var config1 = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId1);
                
            var config2 = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId2);

            if (config1 == null || config2 == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareConfigurationsAsync(configId1, configId2);

            ViewBag.Config1 = config1;
            ViewBag.Config2 = config2;
            ViewBag.FullConfig1 = config1.Content;
            ViewBag.FullConfig2 = config2.Content;
            
            return View(diff);
        }
        
        // GET: ConfigManagement/UnifiedCompareWithTemplate/{configId}/{templateId}
        [HttpGet]
        public async Task<IActionResult> UnifiedCompareWithTemplate(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            var template = await _context.ConfigTemplates.FindAsync(templateId);

            if (config == null || template == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareWithTemplateAsync(configId, templateId);

            ViewBag.Config = config;
            ViewBag.Template = template;
            ViewBag.FullConfig = config.Content;
            ViewBag.FullTemplate = template.Content;
            
            return View(diff);
        }

        // GET: ConfigManagement/Search
        public IActionResult Search()
        {
            ViewBag.Routers = new SelectList(_context.Routers, "Id", "Hostname");
            return View();
        }

        // POST: ConfigManagement/SearchResults
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> SearchResults(string searchTerm, int? routerId = null)
        {
            if (string.IsNullOrEmpty(searchTerm))
            {
                return RedirectToAction(nameof(Search));
            }

            var results = await _configService.SearchInConfigurationsAsync(searchTerm, routerId);
            
            ViewBag.SearchTerm = searchTerm;
            if (routerId.HasValue)
            {
                ViewBag.Router = await _context.Routers.FindAsync(routerId);
            }
            
            return View(results);
        }

        // GET: ConfigManagement/Templates
        public async Task<IActionResult> Templates()
        {
            return View(await _context.ConfigTemplates.ToListAsync());
        }
        
        // GET: ConfigManagement/CreateTemplate
        public IActionResult CreateTemplate()
        {
            return View();
        }
        
        // POST: ConfigManagement/CreateTemplate
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateTemplate([Bind("Name,Content,Description,DeviceType")] ConfigTemplate template)
        {
            if (ModelState.IsValid)
            {
                template.CreatedDate = DateTime.Now;
                template.CreatedBy = "System"; // Sau này sẽ là người dùng đăng nhập
                template.Version = "1.0";
                
                _context.Add(template);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Templates));
            }
            return View(template);
        }
        
        // GET: ConfigManagement/EditTemplate/5
        public async Task<IActionResult> EditTemplate(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var template = await _context.ConfigTemplates.FindAsync(id);
            if (template == null)
            {
                return NotFound();
            }
            
            return View(template);
        }
        
        // POST: ConfigManagement/EditTemplate/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditTemplate(int id, [Bind("Id,Name,Content,Description,DeviceType,CreatedDate,CreatedBy")] ConfigTemplate template)
        {
            if (id != template.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    // Cập nhật phiên bản
                    if (!string.IsNullOrEmpty(template.Version))
                    {
                        var versionParts = template.Version.Split('.');
                        if (versionParts.Length >= 2 && int.TryParse(versionParts[1], out int minorVersion))
                        {
                            template.Version = $"{versionParts[0]}.{minorVersion + 1}";
                        }
                    }
                    else
                    {
                        template.Version = "1.0";
                    }
                    
                    _context.Update(template);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!TemplateExists(template.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(Templates));
            }
            return View(template);
        }
        
        // GET: ConfigManagement/DeleteTemplate/5
        public async Task<IActionResult> DeleteTemplate(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var template = await _context.ConfigTemplates
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (template == null)
            {
                return NotFound();
            }

            return View(template);
        }
        
        // POST: ConfigManagement/DeleteTemplateConfirmed/5
        [HttpPost, ActionName("DeleteTemplate")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteTemplateConfirmed(int id)
        {
            var template = await _context.ConfigTemplates.FindAsync(id);
            if (template != null)
            {
                _context.ConfigTemplates.Remove(template);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(Templates));
        }
        
        // GET: ConfigManagement/CompareWithTemplate/{configId}
        public async Task<IActionResult> CompareWithTemplateSelection(int? configId)
        {
            if (configId == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            if (config == null)
            {
                return NotFound();
            }

            var templates = await _context.ConfigTemplates.ToListAsync();
            if (!templates.Any())
            {
                TempData["Message"] = "Không có template nào. Vui lòng tạo template trước.";
                return RedirectToAction("Templates");
            }

            ViewBag.Config = config;
            ViewBag.Templates = new SelectList(templates, "Id", "Name");

            return View();
        }
        
        // POST: ConfigManagement/CompareWithTemplate
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CompareWithTemplate(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            var template = await _context.ConfigTemplates.FindAsync(templateId);

            if (config == null || template == null)
            {
                return NotFound();
            }

            var diff = await _configService.CompareWithTemplateAsync(configId, templateId);

            ViewBag.Config = config;
            ViewBag.Template = template;
            
            return View(diff);
        }

        // GET: ConfigManagement/ComplianceRules
        public async Task<IActionResult> ComplianceRules()
        {
            return View(await _context.ComplianceRules.ToListAsync());
        }
        
        // GET: ConfigManagement/CreateRule
        public IActionResult CreateRule()
        {
            return View();
        }
        
        // POST: ConfigManagement/CreateRule
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateRule([Bind("Name,Pattern,Description,Severity,DeviceType,ExpectedResult,Notes")] ComplianceRule rule)
        {
            if (ModelState.IsValid)
            {
                rule.CreatedDate = DateTime.Now;
                rule.CreatedBy = "System"; // Sau này sẽ là người dùng đăng nhập
                rule.IsActive = true;
                
                _context.Add(rule);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(ComplianceRules));
            }
            return View(rule);
        }
        
        // GET: ConfigManagement/EditRule/5
        public async Task<IActionResult> EditRule(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var rule = await _context.ComplianceRules.FindAsync(id);
            if (rule == null)
            {
                return NotFound();
            }
            
            return View(rule);
        }
        
        // POST: ConfigManagement/EditRule/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditRule(int id, [Bind("Id,Name,Pattern,Description,Severity,DeviceType,ExpectedResult,CreatedBy,CreatedDate,IsActive,Notes")] ComplianceRule rule)
        {
            if (id != rule.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    _context.Update(rule);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!RuleExists(rule.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(ComplianceRules));
            }
            return View(rule);
        }
        
        // GET: ConfigManagement/DeleteRule/5
        public async Task<IActionResult> DeleteRule(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var rule = await _context.ComplianceRules
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (rule == null)
            {
                return NotFound();
            }

            return View(rule);
        }
        
        // POST: ConfigManagement/DeleteRule/5
        [HttpPost, ActionName("DeleteRule")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteRuleConfirmed(int id)
        {
            var rule = await _context.ComplianceRules.FindAsync(id);
            if (rule != null)
            {
                _context.ComplianceRules.Remove(rule);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(ComplianceRules));
        }
        
        // GET: ConfigManagement/CheckCompliance/{configId}
        public async Task<IActionResult> CheckCompliance(int? configId)
        {
            if (configId == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
                
            if (config == null)
            {
                return NotFound();
            }

            var results = await _configService.CheckComplianceAsync(config.Id);
            
            // Lưu kết quả vào database nếu cần
            _context.ComplianceResults.AddRange(results);
            await _context.SaveChangesAsync();
            
            ViewBag.Config = config;
            ViewBag.Router = config.Router;
            
            // Lấy thông tin các quy tắc
            var ruleIds = results.Select(r => r.RuleId).ToList();
            var rules = await _context.ComplianceRules
                .Where(r => ruleIds.Contains(r.Id))
                .ToDictionaryAsync(r => r.Id);
            
            ViewBag.Rules = rules;
            
            return View(results);
        }
        
        private bool TemplateExists(int id)
        {
            return _context.ConfigTemplates.Any(e => e.Id == id);
        }
        
        private bool RuleExists(int id)
        {
            return _context.ComplianceRules.Any(e => e.Id == id);
        }
    }
}
```

### NCM3\Controllers\HomeController.cs
```cs
using System.Diagnostics;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;

namespace NCM3.Controllers
{    public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;
        private readonly NCMDbContext _context;

        public HomeController(ILogger<HomeController> logger, NCMDbContext context)
        {
            _logger = logger;
            _context = context;
        }

        public IActionResult Index()
        {
            // Check if there are routers in the system
            if (_context.Routers.Any())
            {
                return View();
            }
            
            // If no routers exist, redirect to routers page to add one
            return RedirectToAction("Index", "Routers");
        }

        public IActionResult Privacy()
        {
            return View();
        }        // GET: /Home/Restore
        public IActionResult Restore()
        {
            return View();
        }

        // GET: /Home/GetRouters
        [HttpGet]
        public async Task<IActionResult> GetRouters()
        {
            try
            {
                var routers = await _context.Routers                .AsNoTracking()
                .OrderBy(r => r.Hostname)
                .Select(r => new { r.Id, r.Hostname, r.IpAddress, r.IsAvailable })
                .ToListAsync();

                return Json(routers);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Lỗi khi tải danh sách router");
                return Json(new { error = "Không thể tải danh sách router: " + ex.Message });
            }
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
    }
}

```

### NCM3\Controllers\RestoreController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services;
using System.IO;

namespace NCM3.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class RestoreController : ControllerBase
    {
        private readonly ILogger<RestoreController> _logger;
        private readonly NCMDbContext _context;
        private readonly RouterService _routerService;

        public RestoreController(ILogger<RestoreController> logger, NCMDbContext context, RouterService routerService)
        {
            _logger = logger;
            _context = context;
            _routerService = routerService;
        }

        // GET: api/restore/router/{id}/backups
        [HttpGet("router/{id}/backups")]
        public async Task<IActionResult> GetRouterBackups(int id)
        {
            _logger.LogInformation("Getting backup list for router with ID {RouterId}", id);
            
            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                _logger.LogWarning("Router with ID {RouterId} not found", id);
                return NotFound(new { success = false, message = "Router không tồn tại" });
            }

            var backups = await _context.RouterConfigurations
                .Where(c => c.RouterId == id)
                .OrderByDescending(c => c.BackupDate)
                .Select(c => new {
                    c.Id,
                    c.BackupDate,
                    c.BackupType,
                    ConfigSize = c.Content.Length,
                    c.Comment
                })
                .ToListAsync();

            _logger.LogInformation("Retrieved {BackupCount} backups for router {RouterName}", backups.Count, router.Hostname);
            
            return Ok(new { 
                success = true, 
                router = new { router.Id, router.Hostname, router.IpAddress },
                backups 
            });
        }

        // GET: api/restore/backup/{id}
        [HttpGet("backup/{id}")]
        public async Task<IActionResult> GetBackupDetail(int id)
        {
            _logger.LogInformation("Getting details for backup with ID {BackupId}", id);
            
            var backup = await _context.RouterConfigurations.FindAsync(id);
            if (backup == null)
            {
                _logger.LogWarning("Backup with ID {BackupId} not found", id);
                return NotFound(new { success = false, message = "Bản sao lưu không tồn tại" });
            }

            var router = await _context.Routers.FindAsync(backup.RouterId);
            if (router == null)
            {
                _logger.LogWarning("Associated router for backup ID {BackupId} not found", id);
                return NotFound(new { success = false, message = "Router không tồn tại" });
            }

            _logger.LogInformation("Retrieved details for backup {BackupId} of router {RouterName}", 
                id, router.Hostname);
            
            return Ok(new { 
                success = true, 
                backup = new {
                    backup.Id,
                    backup.BackupDate,
                    backup.BackupType,
                    backup.Content,
                    backup.Comment,
                    Router = new { router.Id, router.Hostname, router.IpAddress }
                }
            });
        }

        // POST: api/restore/router/{id}
        [HttpPost("router/{id}")]
        public async Task<IActionResult> RestoreRouter(int id, [FromBody] RestoreRequest request)
        {
            _logger.LogInformation("Received restore request for router ID {RouterId} with backup ID {BackupId}",
                id, request?.BackupId);
                
            if (request == null || request.BackupId <= 0)
            {
                _logger.LogWarning("Invalid restore request received for router {RouterId}", id);
                return BadRequest(new { success = false, message = "Yêu cầu không hợp lệ" });
            }

            // Fetch router with configurations included
            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == id);

            if (router == null)
            {
                _logger.LogWarning("Router with ID {RouterId} not found", id);
                return NotFound(new { success = false, message = "Router không tồn tại" });
            }

            // Get the specific backup to restore
            var backup = await _context.RouterConfigurations.FindAsync(request.BackupId);
            if (backup == null || backup.RouterId != id)
            {
                _logger.LogWarning("Backup {BackupId} not found or doesn't belong to router {RouterName}", 
                    request.BackupId, router.Hostname);
                return NotFound(new { 
                    success = false, 
                    message = "Bản sao lưu không tồn tại hoặc không thuộc về router này" 
                });
            }

            // Validate IP address before proceeding
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogError("Router {RouterName} (ID: {RouterId}) has no IP address configured", 
                    router.Hostname, router.Id);
                return BadRequest(new { 
                    success = false, 
                    message = $"Router {router.Hostname} không có địa chỉ IP" 
                });
            }

            if (!System.Net.IPAddress.TryParse(router.IpAddress, out var ipAddress))
            {
                _logger.LogError("Router {RouterName} has invalid IP address: {IPAddress}", 
                    router.Hostname, router.IpAddress);
                return BadRequest(new { 
                    success = false, 
                    message = $"Router {router.Hostname} có địa chỉ IP không hợp lệ: {router.IpAddress}" 
                });
            }

            try
            {
                // Create a backup of the current configuration if requested
                if (request.CreateBackupBeforeRestore)
                {
                    try
                    {
                        _logger.LogInformation("Creating pre-restore backup for router {RouterName}", router.Hostname);
                        
                        // Get the current configuration before restoring
                        string currentConfig = await _routerService.GetConfigurationAsync(router);
                        
                        // Check if the configuration retrieval failed
                        if (string.IsNullOrEmpty(currentConfig) || currentConfig.StartsWith("Error:"))
                        {
                            _logger.LogWarning("Could not create pre-restore backup for router {RouterName}: {ErrorMessage}", 
                                router.Hostname, currentConfig ?? "No configuration received");
                            
                            // Continue with restore anyway, but inform the user
                            _logger.LogInformation("Continuing with restore operation despite backup failure");
                        }
                        else
                        {
                            // Create a backup of the current configuration
                            var currentBackup = new RouterConfiguration
                            {
                                RouterId = router.Id,
                                BackupDate = DateTime.UtcNow,
                                BackupType = "Pre-Restore",
                                Content = currentConfig,
                                BackupBy = User.Identity?.Name ?? "System",
                                Comment = "Bản sao lưu tự động trước khi khôi phục"
                            };
                            
                            _context.RouterConfigurations.Add(currentBackup);
                            await _context.SaveChangesAsync();
                            _logger.LogInformation("Successfully created pre-restore backup (ID: {BackupId}) for router {RouterName}", 
                                currentBackup.Id, router.Hostname);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Failed to create pre-restore backup for router {RouterName}", router.Hostname);
                        // Continue with restore anyway since this is just a precaution
                    }
                }
                
                // Log the actual restoration attempt
                _logger.LogInformation("Attempting to restore configuration to router {RouterName} ({IPAddress}) from backup created on {BackupDate}", 
                    router.Hostname, ipAddress.ToString(), backup.BackupDate);

                // Perform the actual restoration
                bool success = await _routerService.RestoreConfigurationAsync(router, backup.Content);
                
                if (success)
                {
                    _logger.LogInformation("Successfully restored configuration for router {RouterName} from backup {BackupId}", 
                        router.Hostname, backup.Id);
                    
                    // Record the restoration in the database
                    var restoreRecord = new RouterConfiguration
                    {
                        RouterId = router.Id,
                        BackupDate = DateTime.UtcNow,
                        BackupType = "Restore",
                        Content = backup.Content,
                        BackupBy = User.Identity?.Name ?? "System",
                        Comment = $"Khôi phục từ bản sao lưu ngày {backup.BackupDate:yyyy-MM-dd HH:mm:ss}"
                    };
                    
                    _context.RouterConfigurations.Add(restoreRecord);
                    await _context.SaveChangesAsync();
                    
                    _logger.LogInformation("Created restore record (ID: {RecordId}) for router {RouterName}", 
                        restoreRecord.Id, router.Hostname);
                    
                    return Ok(new { 
                        success = true, 
                        message = $"Đã khôi phục cấu hình thành công cho router {router.Hostname}" 
                    });
                }
                else
                {
                    _logger.LogError("Failed to restore configuration for router {RouterName} from backup {BackupId}", 
                        router.Hostname, backup.Id);
                    
                    return BadRequest(new { 
                        success = false, 
                        message = $"Không thể khôi phục cấu hình cho router {router.Hostname}" 
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while restoring configuration for router {RouterName}: {Error}",
                    router.Hostname, ex.Message);
                
                return StatusCode(500, new { 
                    success = false, 
                    message = $"Lỗi khi khôi phục cấu hình: {ex.Message}" 
                });
            }
        }
    }

    public class RestoreRequest
    {
        public int BackupId { get; set; }
        public bool CreateBackupBeforeRestore { get; set; } = true;
    }
}

```

### NCM3\Controllers\RoutersController.cs
```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Constants;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration; // Added for S3 settings

namespace NCM3.Controllers
{
    public class RoutersController : Controller
    {
        private readonly NCMDbContext _context;
        private readonly RouterService _routerService;
        private readonly IEncryptionService _encryptionService;
        private readonly ConfigurationManagementService _configService;
        private readonly ITelegramNotificationService _telegramService;
        private readonly NotificationHelper _notificationHelper;
        private readonly ILogger<RoutersController> _logger;
        private readonly IS3BackupService _s3Service; // Added for S3 backup
        private readonly IConfiguration _configuration; // Added for S3 settings

        public RoutersController(NCMDbContext context, 
                              RouterService routerService, 
                              IEncryptionService encryptionService,
                              ConfigurationManagementService configService,
                              ITelegramNotificationService telegramService,
                              NotificationHelper notificationHelper,
                              ILogger<RoutersController> logger,
                              IS3BackupService s3BackupService, // Added
                              IConfiguration configuration) // Added
        {
            _context = context;
            _routerService = routerService;
            _encryptionService = encryptionService;
            _configService = configService;
            _telegramService = telegramService;
            _notificationHelper = notificationHelper;
            _logger = logger;
            _s3Service = s3BackupService; // Added
            _configuration = configuration; // Added
        }

        // GET: Routers
        public async Task<IActionResult> Index()
        {
            return View(await _context.Routers.ToListAsync());
        }

        // GET: Routers/Details/5
        public async Task<IActionResult> Details(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            return View(router);
        }

        // GET: Routers/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Routers/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create([Bind("Id,Hostname,IpAddress,Username,Password,EnablePassword,Model,OSVersion")] Router router)
        {
            if (ModelState.IsValid)
            {
                // Mã hóa mật khẩu trước khi lưu vào database
                router.Password = _encryptionService.Encrypt(router.Password);
                if (!string.IsNullOrEmpty(router.EnablePassword))
                {
                    router.EnablePassword = _encryptionService.Encrypt(router.EnablePassword);
                }
                
                router.Status = RouterStatus.Unknown;
                router.IsAvailable = false; // Set default availability status to false
                _context.Add(router);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Index));
            }
            return View(router);
        }

        // GET: Routers/Edit/5
        public async Task<IActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }
            return View(router);
        }

        // POST: Routers/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, [Bind("Id,Hostname,IpAddress,Username,Password,EnablePassword,Model,OSVersion,Status,IsAvailable")] Router router)
        {
            if (id != router.Id)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    // Check if password was left blank (meaning keep the existing one)
                    var existingRouter = await _context.Routers.AsNoTracking().FirstOrDefaultAsync(r => r.Id == id);
                    if (existingRouter != null)
                    {
                        if (string.IsNullOrEmpty(router.Password))
                        {
                            router.Password = existingRouter.Password;
                        }
                        else
                        {
                            // Mã hóa mật khẩu mới
                            router.Password = _encryptionService.Encrypt(router.Password);
                        }
                        
                        if (string.IsNullOrEmpty(router.EnablePassword))
                        {
                            router.EnablePassword = existingRouter.EnablePassword;
                        }
                        else if (!string.IsNullOrEmpty(router.EnablePassword))
                        {
                            // Mã hóa enable password mới
                            router.EnablePassword = _encryptionService.Encrypt(router.EnablePassword);
                        }
                    }
                    
                    _context.Update(router);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!RouterExists(router.Id))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(Index));
            }
            return View(router);
        }

        // GET: Routers/Delete/5
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            return View(router);
        }

        // POST: Routers/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var router = await _context.Routers.FindAsync(id);
            if (router != null)
            {
                _context.Routers.Remove(router);
                await _context.SaveChangesAsync();
            }
            
            return RedirectToAction(nameof(Index));
        }

        // GET: Routers/TestConnection/5
        public async Task<IActionResult> TestConnection(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }

            bool isConnected = await _routerService.CheckConnectionAsync(router);
            
            // Update the router status in the database
            _context.Update(router);
            await _context.SaveChangesAsync();
            
            return RedirectToAction(nameof(Details), new { id = router.Id });
        }

        // GET: Routers/BackupConfiguration/5
        public async Task<IActionResult> BackupConfiguration(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == id);
                
            if (router == null)
            {
                return NotFound();
            }

            try
            {
                string configContent = await _routerService.GetConfigurationAsync(router);
                
                // Create a new configuration backup
                var routerConfig = new RouterConfiguration
                {
                    RouterId = router.Id,
                    BackupDate = DateTime.UtcNow, 
                    Content = configContent, // Use the fetched config content
                    Version = $"Manual_{DateTime.UtcNow:yyyyMMdd_HHmmss}", // Changed prefix to Manual
                    BackupBy = User?.Identity?.Name ?? "System", // Get current user or default to System
                    BackupType = BackupTypes.Manual 
                };
                
                _context.RouterConfigurations.Add(routerConfig);
                
                router.LastBackup = routerConfig.BackupDate;
                _context.Update(router);
                
                await _context.SaveChangesAsync();

                // Upload to S3 if enabled
                bool enableS3Backup = _configuration.GetValue<bool>("AWS:S3:EnableS3Backup", false);
                if (enableS3Backup)
                {
                    try
                    {
                        bool s3UploadSuccess = await _s3Service.UploadBackupAsync(router.Id, configContent, routerConfig.Version, routerConfig.BackupBy);
                        if (s3UploadSuccess)
                        {
                            _logger.LogInformation($"Đã tải bản sao lưu thủ công {routerConfig.Version} của router {router.Hostname} lên S3.");
                        }
                        else
                        {
                            _logger.LogWarning($"Không tải được bản sao lưu thủ công {routerConfig.Version} của router {router.Hostname} lên S3.");
                            // Optionally, add a TempData message for the user if S3 upload fails
                            // TempData["WarningMessage"] = "Đã sao lưu cục bộ thành công, nhưng không thể tải lên S3.";
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"Lỗi khi tải bản sao lưu thủ công {routerConfig.Version} của router {router.Hostname} lên S3.");
                        // Optionally, add a TempData message for the user
                        // TempData["WarningMessage"] = "Đã sao lưu cục bộ thành công, nhưng đã xảy ra lỗi khi tải lên S3.";
                    }
                }
                
                // Kiểm tra và gửi thông báo nếu có thay đổi
                await _notificationHelper.DetectAndNotifyConfigurationChangeAsync(
                    router,
                    configContent, // Use the fetched config content
                    "Sao lưu cấu hình thủ công"
                );
                
                _logger.LogInformation("Đã sao lưu cấu hình cho router {RouterName}", router.Hostname);
                TempData["SuccessMessage"] = "Đã sao lưu cấu hình thành công.";
                
                return RedirectToAction(nameof(ConfigurationHistory), new { id = router.Id });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Lỗi khi sao lưu cấu hình router {RouterId}: {Message}", id, ex.Message);
                TempData["ErrorMessage"] = $"Lỗi khi sao lưu cấu hình: {ex.Message}";
                return RedirectToAction(nameof(Details), new { id = router.Id });
            }
        }

        // GET: Routers/ConfigurationHistory/5
        public async Task<IActionResult> ConfigurationHistory(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }

            var configs = await _context.RouterConfigurations
                .Where(c => c.RouterId == id)
                .OrderByDescending(c => c.BackupDate)
                .ToListAsync();
                
            ViewBag.Router = router;
            
            return View(configs);
        }

        // GET: Routers/ViewConfiguration/5
        public async Task<IActionResult> ViewConfiguration(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(m => m.Id == id);
                
            if (config == null)
            {
                return NotFound();
            }

            return View(config);
        }

        // GET: Routers/DebugSsh/5
        public async Task<IActionResult> DebugSsh(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var router = await _context.Routers.FindAsync(id);
            if (router == null)
            {
                return NotFound();
            }
            
            ViewBag.Router = router;
            ViewBag.DebugLog = await _routerService.DebugSshConnectionAsync(router);
            
            return View();
        }

        private bool RouterExists(int id)
        {
            return _context.Routers.Any(e => e.Id == id);
        }
    }
}
```

### NCM3\Controllers\SettingsController.cs
```cs
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services;
using System.IO;
using System.Text;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace NCM3.Controllers
{
    public class SettingsController : Controller
    {        private readonly ILogger<SettingsController> _logger;
        private readonly IConfiguration _configuration;
        private readonly ITelegramNotificationService _telegramService;
        private readonly IWebhookNotificationService _webhookService;
        private readonly string _appSettingsFilePath;
        private readonly NotificationLogger? _notificationLogger;
        
        public SettingsController(
            ILogger<SettingsController> logger,
            IConfiguration configuration,
            ITelegramNotificationService telegramService,
            IWebhookNotificationService webhookService,
            NotificationLogger? notificationLogger = null)
        {
            _logger = logger;
            _configuration = configuration;
            _telegramService = telegramService;
            _webhookService = webhookService;
            _notificationLogger = notificationLogger;
            
            // Lấy đường dẫn tới tệp appsettings.json
            _appSettingsFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "appsettings.json");
        }
        
        public IActionResult Index()
        {
            var viewModel = new SettingsViewModel
            {
                NotificationSettings = new NotificationSettings
                {
                    TelegramBotToken = _configuration["Telegram:BotToken"] ?? string.Empty,
                    TelegramChatId = _configuration["Telegram:ChatId"] ?? string.Empty,
                    EnableTelegram = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) && 
                                    !string.IsNullOrEmpty(_configuration["Telegram:ChatId"]),
                    WebhookUrl = _configuration["Notification:WebhookUrl"] ?? string.Empty,
                    EnableWebhook = bool.TryParse(_configuration["Notification:EnableWebhook"], out bool enableWebhook) && enableWebhook,
                    NotifyOnConfigChange = !bool.TryParse(_configuration["Notification:NotifyOnConfigChange"], out bool notifyConfig) || notifyConfig,
                    NotifyOnComplianceIssue = !bool.TryParse(_configuration["Notification:NotifyOnComplianceIssue"], out bool notifyCompliance) || notifyCompliance,
                    NotifyOnConnectivityChange = !bool.TryParse(_configuration["Notification:NotifyOnConnectivityChange"], out bool notifyConn) || notifyConn
                },
                
                AutoDetectionSettings = new AutoDetectionSettings
                {
                    EnableAutoDetection = bool.TryParse(_configuration["AutoDetection:Enabled"], out bool enabled) && enabled,
                    CheckIntervalMinutes = int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int interval) 
                        ? interval 
                        : 30,
                    DetectConfigChanges = !bool.TryParse(_configuration["AutoDetection:DetectConfigChanges"], out bool detectConfig) || detectConfig,
                    DetectConnectivityChanges = !bool.TryParse(_configuration["AutoDetection:DetectConnectivityChanges"], out bool detectConn) || detectConn,
                    DetectComplianceIssues = !bool.TryParse(_configuration["AutoDetection:DetectComplianceIssues"], out bool detectComp) || detectComp
                },
                
                // Kiểm tra trạng thái dịch vụ
                DetectionServiceRunning = bool.TryParse(_configuration["AutoDetection:Enabled"], out bool serviceRunning) && serviceRunning,
                TelegramEnabled = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) && 
                                  !string.IsNullOrEmpty(_configuration["Telegram:ChatId"])
            };
            
            return View(viewModel);
        }
          public async Task<IActionResult> SaveNotificationSettings(NotificationSettings model)
        {
            if (!ModelState.IsValid)
            {
                return RedirectToAction(nameof(Index));
            }
            
            try
            {
                // Đọc tệp cấu hình
                var json = await System.IO.File.ReadAllTextAsync(_appSettingsFilePath);
                var jsonObj = JObject.Parse(json);
                
                // Cập nhật cấu hình Telegram
                if (jsonObj["Telegram"] == null)
                {
                    jsonObj["Telegram"] = new JObject();
                }
                
                if (jsonObj["Telegram"] != null)
                {
                    jsonObj["Telegram"]["BotToken"] = model.EnableTelegram ? model.TelegramBotToken : string.Empty;
                    jsonObj["Telegram"]["ChatId"] = model.EnableTelegram ? model.TelegramChatId : string.Empty;
                }
                
                // Cập nhật cấu hình Notification
                if (jsonObj["Notification"] == null)
                {
                    jsonObj["Notification"] = new JObject();
                }
                
                if (jsonObj["Notification"] != null)
                {
                    jsonObj["Notification"]["EnableWebhook"] = model.EnableWebhook.ToString().ToLower();
                    jsonObj["Notification"]["WebhookUrl"] = model.WebhookUrl;
                    jsonObj["Notification"]["NotifyOnConfigChange"] = model.NotifyOnConfigChange.ToString().ToLower();
                    jsonObj["Notification"]["NotifyOnComplianceIssue"] = model.NotifyOnComplianceIssue.ToString().ToLower();
                    jsonObj["Notification"]["NotifyOnConnectivityChange"] = model.NotifyOnConnectivityChange.ToString().ToLower();
                }
                
                // Ghi lại tệp cấu hình
                await System.IO.File.WriteAllTextAsync(_appSettingsFilePath, jsonObj.ToString(Formatting.Indented));
                
                _logger.LogInformation("Đã cập nhật thiết lập thông báo");
                TempData["SuccessMessage"] = "Đã lưu thiết lập thông báo thành công";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Lỗi khi lưu thiết lập thông báo: {Error}", ex.Message);
                TempData["ErrorMessage"] = $"Lỗi khi lưu thiết lập: {ex.Message}";
            }
            
            return RedirectToAction(nameof(Index));
        }
        
        [HttpPost]
        public async Task<IActionResult> SaveAutoDetectionSettings(AutoDetectionSettings model)
        {
            if (!ModelState.IsValid)
            {
                return RedirectToAction(nameof(Index));
            }
            
            try
            {
                // Đọc tệp cấu hình
                var json = await System.IO.File.ReadAllTextAsync(_appSettingsFilePath);
                var jsonObj = JObject.Parse(json);
                
                // Cập nhật cấu hình AutoDetection
                if (jsonObj["AutoDetection"] == null)
                {
                    jsonObj["AutoDetection"] = new JObject();
                }
                
                jsonObj["AutoDetection"]["Enabled"] = model.EnableAutoDetection.ToString().ToLower();
                jsonObj["AutoDetection"]["CheckIntervalMinutes"] = model.CheckIntervalMinutes.ToString();
                jsonObj["AutoDetection"]["DetectConfigChanges"] = model.DetectConfigChanges.ToString().ToLower();
                jsonObj["AutoDetection"]["DetectConnectivityChanges"] = model.DetectConnectivityChanges.ToString().ToLower();
                jsonObj["AutoDetection"]["DetectComplianceIssues"] = model.DetectComplianceIssues.ToString().ToLower();
                
                // Ghi lại tệp cấu hình
                await System.IO.File.WriteAllTextAsync(_appSettingsFilePath, jsonObj.ToString(Formatting.Indented));
                
                _logger.LogInformation("Đã cập nhật thiết lập tự động phát hiện");
                TempData["SuccessMessage"] = "Đã lưu thiết lập tự động phát hiện thành công";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Lỗi khi lưu thiết lập tự động phát hiện: {Error}", ex.Message);
                TempData["ErrorMessage"] = $"Lỗi khi lưu thiết lập: {ex.Message}";
            }
            
            return RedirectToAction(nameof(Index));
        }          [HttpPost]
        public async Task<IActionResult> TestTelegramConnection()
        {
            var viewModel = new SettingsViewModel();
            
            try
            {
                // Create a long test message to verify truncation works
                var longTestMessage = "Thông báo này chỉ để xác nhận kết nối thành công giữa NCM3 và Telegram.\n\n" + 
                                     GenerateLongTestMessage();
                
                await _telegramService.SendConfigChangeNotificationAsync(
                    "Kiểm tra kết nối",
                    "Thử nghiệm",
                    longTestMessage);
                
                viewModel.TestResult = "Kết nối thành công! Đã gửi tin nhắn kiểm tra đến Telegram. Kiểm tra xem tin nhắn có hiển thị đúng và không bị lỗi.";
                viewModel.TestSuccessful = true;
                
                _logger.LogInformation("Kiểm tra kết nối Telegram thành công");
                TempData["TestResult"] = viewModel.TestResult;
                TempData["TestSuccessful"] = true;
            }
            catch (Exception ex)
            {
                viewModel.TestResult = $"Lỗi kết nối: {ex.Message}";
                viewModel.TestSuccessful = false;
                
                _logger.LogError(ex, "Lỗi kiểm tra kết nối Telegram: {Error}", ex.Message);
                TempData["TestResult"] = viewModel.TestResult;
                TempData["TestSuccessful"] = false;
            }
            
            return RedirectToAction(nameof(Index));
        }
        
        // Helper method to generate a long message for testing
        private string GenerateLongTestMessage()
        {
            var result = new StringBuilder();
            result.AppendLine("Đây là một tin nhắn dài để kiểm tra chức năng xử lý tin nhắn dài trong Telegram:");
            result.AppendLine();
            result.AppendLine("```");
            
            // Generate fake router config changes
            for (int i = 1; i <= 100; i++)
            {
                if (i % 2 == 0)
                {
                    result.AppendLine($"+ interface GigabitEthernet0/{i}");
                    result.AppendLine($"+  description Added connection to Server{i}");
                    result.AppendLine($"+  ip address 192.168.{i}.1 255.255.255.0");
                    result.AppendLine($"+  no shutdown");
                }
                else
                {
                    result.AppendLine($"- interface GigabitEthernet0/{i}");
                    result.AppendLine($"-  description Old connection to Switch{i}");
                    result.AppendLine($"-  ip address 10.0.{i}.1 255.255.255.0");
                    result.AppendLine($"-  shutdown");
                }
            }
            
            result.AppendLine("```");
            return result.ToString();
        }
        
        /// <summary>
        /// Hiển thị lịch sử thông báo
        /// </summary>
        public async Task<IActionResult> NotificationHistory(string filter = "all", int page = 1, int pageSize = 20)
        {
            if (_notificationLogger == null)
            {
                return View(new Models.ViewModels.NotificationHistoryViewModel());
            }
            
            var model = await _notificationLogger.GetNotificationHistoryAsync(filter, page, pageSize);
            return View(model);
        }
    }
}

```

### NCM3\Controllers\SNMPTestController.cs
```cs
using System;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using SnmpSharpNet;

namespace NCM3.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class SNMPTestController : ControllerBase
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<SNMPTestController> _logger;

        public SNMPTestController(IConfiguration configuration, ILogger<SNMPTestController> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        [HttpPost]
        public IActionResult TestSNMPCredentials([FromBody] SNMPTestRequest request)
        {
            if (string.IsNullOrEmpty(request.IpAddress))
            {
                return BadRequest(new { success = false, message = "IP Address is required" });
            }            if (string.IsNullOrEmpty(request.Community))
            {
                // Use default community if none provided
                request.Community = _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Community", "public");
            }

            if (string.IsNullOrEmpty(request.Version))
            {
                // Use default version if none provided
                request.Version = _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Version", "Auto");
            }            try
            {                // Validate IP address format
                if (!IPAddress.TryParse(request.IpAddress, out IPAddress? ipAddressResult) || ipAddressResult == null)
                {
                    return BadRequest(new { 
                        success = false, 
                        message = $"Invalid IP address format: {request.IpAddress}" 
                    });
                }
                
                IPAddress ipAddress = ipAddressResult;
                
                var community = new OctetString(request.Community);
                var param = new AgentParameters(community);
                
                // Get SNMP settings from config
                int port = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Port", 161);
                int timeout = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Timeout", 2000);
                int retries = _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Retries", 0);
                
                var target = new UdpTarget(ipAddress, port, timeout, retries);
                
                try
                {
                    // Create Pdu for SNMP GET
                    var pdu = new Pdu(PduType.Get);                    // Use system description OID (common on all SNMP devices)
                    var oid = new Oid("1.3.6.1.2.1.1.1.0"); // sysDescr.0
                    pdu.VbList.Add(oid);
                      // Determine SNMP version to use
                    SnmpPacket? result = null;
                    string snmpVersion = request.Version?.ToLower() ?? "auto";
                    string versionUsed = "";
                    
                    if (snmpVersion == "v1" || snmpVersion == "1")
                    {
                        // Use SNMPv1
                        param.Version = SnmpVersion.Ver1;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv1";
                    }
                    else if (snmpVersion == "v2" || snmpVersion == "v2c" || snmpVersion == "2")
                    {
                        // Use SNMPv2c
                        param.Version = SnmpVersion.Ver2;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv2c";
                    }
                    else // "auto" or any other value
                    {
                        // Try SNMPv2c first, then fallback to SNMPv1 if it fails
                        try
                        {
                            param.Version = SnmpVersion.Ver2;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv2c";
                        }
                        catch (Exception ex)
                        {
                            _logger.LogInformation("SNMPv2c request failed, falling back to SNMPv1: {ErrorMessage}", ex.Message);
                            
                            // Reset PDU for new request
                            pdu = new Pdu(PduType.Get);
                            pdu.VbList.Add(oid);
                            
                            param.Version = SnmpVersion.Ver1;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv1";
                        }
                    }
                    
                    // Process the result based on the actual type returned
                    if (result != null)
                    {
                        if (result is SnmpV2Packet v2Packet && v2Packet.Pdu.ErrorStatus == 0)
                        {
                            var sysdescr = v2Packet.Pdu.VbList[0].Value.ToString();
                            return Ok(new { 
                                success = true, 
                                message = $"SNMP test successful using {versionUsed}", 
                                sysDescr = sysdescr,
                                version = versionUsed
                            });
                        }
                        else if (result is SnmpV1Packet v1Packet && v1Packet.Pdu.ErrorStatus == 0)
                        {
                            var sysdescr = v1Packet.Pdu.VbList[0].Value.ToString();
                            return Ok(new { 
                                success = true, 
                                message = $"SNMP test successful using {versionUsed}", 
                                sysDescr = sysdescr,
                                version = versionUsed
                            });
                        }
                        else
                        {
                            // Handle case where we got a response but with an error
                            string errorStatus = "unknown";
                            int errorIndex = -1;
                            
                            if (result is SnmpV2Packet v2P)
                            {
                                errorStatus = v2P.Pdu.ErrorStatus.ToString();
                                errorIndex = v2P.Pdu.ErrorIndex;
                            }
                            else if (result is SnmpV1Packet v1P)
                            {
                                errorStatus = v1P.Pdu.ErrorStatus.ToString();
                                errorIndex = v1P.Pdu.ErrorIndex;
                            }
                            
                            return BadRequest(new { 
                                success = false, 
                                message = $"SNMP GET failed using {versionUsed}. Error: {errorStatus}, Index: {errorIndex}", 
                                version = versionUsed
                            });
                        }
                    }
                    else
                    {
                        return BadRequest(new { 
                            success = false, 
                            message = $"No response received from SNMP request using {versionUsed}"
                        });
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error testing SNMP for IP {IPAddress}: {ErrorMessage}",
                        request.IpAddress, ex.Message);
                    
                    return BadRequest(new { 
                        success = false, 
                        message = $"Error: {ex.Message}" 
                    });
                }
                finally
                {
                    target.Close();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SNMP test: {ErrorMessage}", ex.Message);
                return BadRequest(new { 
                    success = false, 
                    message = $"Error: {ex.Message}" 
                });
            }
        }
    }    public class SNMPTestRequest
    {
        public string? IpAddress { get; set; }
        public string? Community { get; set; }
        public string? Version { get; set; }
    }
}

```

### NCM3\Extensions\AppSettingsExtensions.cs
```cs
using System;
using System.IO;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace NCM3.Extensions
{
    public static class AppSettingsExtensions
    {
        public static IServiceCollection ConfigureBackupFolders(this IServiceCollection services, IConfiguration configuration)
        {
            // Lấy đường dẫn thư mục từ cấu hình
            var backupFolder = configuration["AppSettings:BackupFolder"];
            var configBackupFolder = configuration["AppSettings:ConfigBackupFolder"];
            var logFolder = configuration["AppSettings:LogFolder"];
            var templatePath = configuration["AppSettings:TemplatePath"];
            var complianceRulesPath = configuration["AppSettings:ComplianceRulesPath"];
            
            // Tạo các thư mục nếu chúng chưa tồn tại
            CreateDirectoryIfNotExists(backupFolder);
            CreateDirectoryIfNotExists(configBackupFolder);
            CreateDirectoryIfNotExists(logFolder);
            CreateDirectoryIfNotExists(templatePath);
            CreateDirectoryIfNotExists(complianceRulesPath);
            
            return services;
        }
        
        private static void CreateDirectoryIfNotExists(string path)
        {
            if (!string.IsNullOrEmpty(path) && !Directory.Exists(path))
            {
                try
                {
                    Directory.CreateDirectory(path);
                }
                catch (Exception ex)
                {
                    // Log lỗi nếu không thể tạo thư mục
                    Console.WriteLine($"Không thể tạo thư mục {path}: {ex.Message}");
                }
            }
        }
    }
}

```

### NCM3\Extensions\LoggingExtensions.cs
```cs
using System;
using Microsoft.Extensions.Logging;
using System.IO;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;

namespace NCM3.Extensions
{
    public static class LoggingExtensions
    {
        public static IServiceCollection AddFileLogger(this IServiceCollection services, IConfiguration configuration)
        {
            // Đảm bảo thư mục logs tồn tại
            var logsPath = Path.Combine(Directory.GetCurrentDirectory(), "logs");
            if (!Directory.Exists(logsPath))
            {
                Directory.CreateDirectory(logsPath);
            }

            services.AddLogging(builder =>
            {
                builder.AddConfiguration(configuration.GetSection("Logging"));
                builder.AddConsole();
                builder.AddDebug();
                
                // Thêm file logger nếu đã cấu hình đường dẫn
                var logFilePath = configuration["Logging:File:Path"];
                if (!string.IsNullOrEmpty(logFilePath))
                {
                    builder.AddFile(configuration.GetSection("Logging:File"));
                }
            });

            return services;
        }
    }
}

```

### NCM3\Extensions\ServiceCollectionExtensions.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using NCM3.Services;
using NCM3.Services.Events;
using NCM3.Services.ChangeDetection;
using NCM3.Models;

namespace NCM3.Extensions
{
    public static class ServiceCollectionExtensions
    {
        public static void AddNotificationServices(this IServiceCollection services)
        {
            // Register a hosted service that will handle the circular dependency initialization
            services.AddHostedService<NotificationInitializerService>();
        }          public static void AddChangeDetectionServices(this IServiceCollection services)
        {
            // Register the event bus as a singleton
            services.AddSingleton<IEventBus, InMemoryEventBus>();
            
            // Create factory for RouterService to avoid scoping issues
            services.AddSingleton<Func<RouterService>>(serviceProvider => () => 
            {
                // Create a scope to resolve the scoped RouterService
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<RouterService>();
            });
            
            // Create factory for DbContext to avoid scoping issues
            services.AddSingleton<Func<NCMDbContext>>(serviceProvider => () => 
            {
                // Create a scope to resolve the scoped DbContext
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            });
            
            // Register change detection strategies with factory dependencies
            services.AddSingleton<SNMPPollingStrategy>(serviceProvider => 
            {
                var logger = serviceProvider.GetRequiredService<ILogger<SNMPPollingStrategy>>();
                var configuration = serviceProvider.GetRequiredService<IConfiguration>();
                var routerServiceFactory = serviceProvider.GetRequiredService<Func<RouterService>>();
                var dbContextFactory = serviceProvider.GetRequiredService<Func<NCMDbContext>>();
                
                return new SNMPPollingStrategy(logger, configuration, routerServiceFactory, dbContextFactory);
            });
            
            services.AddSingleton<SSHPollingStrategy>(serviceProvider => 
            {
                var logger = serviceProvider.GetRequiredService<ILogger<SSHPollingStrategy>>();
                var configuration = serviceProvider.GetRequiredService<IConfiguration>();
                var routerServiceFactory = serviceProvider.GetRequiredService<Func<RouterService>>();
                var dbContextFactory = serviceProvider.GetRequiredService<Func<NCMDbContext>>();
                
                return new SSHPollingStrategy(logger, configuration, routerServiceFactory, dbContextFactory);
            });
            
            // Create a singleton factory that will provide the strategies
            services.AddSingleton<Func<IEnumerable<IChangeDetectionStrategy>>>(serviceProvider => () =>
            {
                var strategies = new List<IChangeDetectionStrategy>
                {
                    serviceProvider.GetRequiredService<SNMPPollingStrategy>(),
                    serviceProvider.GetRequiredService<SSHPollingStrategy>()
                };
                
                return strategies;
            });
            
            // Register the orchestrator as a hosted service
            services.AddHostedService<ChangeDetectionOrchestrator>();
        }

        public static IServiceCollection AddCustomServices(this IServiceCollection services)
        {
            services.AddScoped<NCMDbContext>();
            services.AddSingleton<Func<NCMDbContext>>(serviceProvider => () =>
            {
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            });

            services.AddScoped<RouterService>();
            services.AddSingleton<Func<RouterService>>(serviceProvider => () =>
            {
                var scope = serviceProvider.CreateScope();
                return scope.ServiceProvider.GetRequiredService<RouterService>();
            });

            services.AddScoped<IChangeDetectionStrategy, SNMPPollingStrategy>();
            services.AddScoped<IChangeDetectionStrategy, SSHPollingStrategy>();
            services.AddSingleton<ChangeDetectionOrchestrator>();

            return services;
        }
    }    // This hosted service will run after all services are built and initialize the circular dependency
    public class NotificationInitializerService : Microsoft.Extensions.Hosting.IHostedService
    {
        private readonly IServiceProvider _serviceProvider;

        public NotificationInitializerService(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            // Create a scope to resolve scoped services
            using (var scope = _serviceProvider.CreateScope())
            {
                var configService = scope.ServiceProvider.GetRequiredService<ConfigurationManagementService>();
                var notificationHelper = scope.ServiceProvider.GetRequiredService<NotificationHelper>();
                var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                
                // Set up the circular dependency
                configService.SetNotificationHelper(notificationHelper);
                
                // Initialize the Telegram notification service
                telegramService.Initialize();
            }
            
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }
}

```

### NCM3\Middleware\GlobalExceptionHandlerMiddleware.cs
```cs
using System;
using System.Net;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

namespace NCM3.Middleware
{
    public class GlobalExceptionHandlerMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<GlobalExceptionHandlerMiddleware> _logger;

        public GlobalExceptionHandlerMiddleware(RequestDelegate next, ILogger<GlobalExceptionHandlerMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                await HandleExceptionAsync(context, ex);
            }
        }

        private Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            _logger.LogError(exception, $"Lỗi xảy ra: {exception.Message}");
            
            context.Response.ContentType = "application/json";
            
            var statusCode = HttpStatusCode.InternalServerError;
            var message = "Đã xảy ra lỗi không mong muốn. Vui lòng thử lại sau hoặc liên hệ quản trị viên.";

            // Có thể xử lý các loại lỗi cụ thể ở đây
            if (exception is UnauthorizedAccessException)
            {
                statusCode = HttpStatusCode.Unauthorized;
                message = "Bạn không có quyền thực hiện hành động này.";
            }
            else if (exception is ArgumentException || exception is ArgumentNullException)
            {
                statusCode = HttpStatusCode.BadRequest;
                message = exception.Message;
            }
            else if (exception is TimeoutException)
            {
                statusCode = HttpStatusCode.RequestTimeout;
                message = "Yêu cầu đã hết thời gian chờ. Vui lòng thử lại sau.";
            }
            
            context.Response.StatusCode = (int)statusCode;
            
            // Khi yêu cầu là API, trả về JSON
            if (context.Request.Headers["Accept"].ToString().Contains("application/json"))
            {
                var result = JsonSerializer.Serialize(new { error = message });
                return context.Response.WriteAsync(result);
            }
            
            // Khi yêu cầu là từ trình duyệt, chuyển hướng đến trang lỗi
            context.Response.Redirect($"/Home/Error?message={WebUtility.UrlEncode(message)}");
            return Task.CompletedTask;
        }
    }
}

```

### NCM3\Middleware\GlobalExceptionHandlerMiddlewareExtensions.cs
```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

namespace NCM3.Middleware
{
    // Extension method để thêm middleware này một cách dễ dàng
    public static class GlobalExceptionHandlerMiddlewareExtensions
    {
        public static IApplicationBuilder UseGlobalExceptionHandler(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<GlobalExceptionHandlerMiddleware>();
        }
    }
}

```

### NCM3\Migrations\20250516021914_InitialCreate.cs
```cs
﻿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Routers",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Hostname = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    IpAddress = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Username = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Password = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Model = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    OSVersion = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    LastBackup = table.Column<DateTime>(type: "datetime2", nullable: true),
                    Status = table.Column<string>(type: "nvarchar(max)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Routers", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "RouterConfigurations",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    RouterId = table.Column<int>(type: "int", nullable: false),
                    BackupDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Version = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    BackupBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RouterConfigurations", x => x.Id);
                    table.ForeignKey(
                        name: "FK_RouterConfigurations_Routers_RouterId",
                        column: x => x.RouterId,
                        principalTable: "Routers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_RouterConfigurations_RouterId",
                table: "RouterConfigurations",
                column: "RouterId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "RouterConfigurations");

            migrationBuilder.DropTable(
                name: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250516021914_InitialCreate.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250516021914_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250516140127_AddEnablePasswordColumn.cs
```cs
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddEnablePasswordColumn : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults");

            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults");

            migrationBuilder.AddColumn<string>(
                name: "EnablePassword",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId",
                principalTable: "RouterConfigurations",
                principalColumn: "Id");

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults",
                column: "RouterId",
                principalTable: "Routers",
                principalColumn: "Id");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults");

            migrationBuilder.DropForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults");

            migrationBuilder.DropColumn(
                name: "EnablePassword",
                table: "Routers");

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId",
                principalTable: "RouterConfigurations",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);

            migrationBuilder.AddForeignKey(
                name: "FK_ComplianceResults_Routers_RouterId",
                table: "ComplianceResults",
                column: "RouterId",
                principalTable: "Routers",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }
    }
}

```

### NCM3\Migrations\20250516142445_AddEnablePassword.cs
```cs
﻿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddEnablePassword : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "EnablePassword",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.CreateTable(
                name: "ComplianceRules",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Pattern = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Severity = table.Column<int>(type: "int", nullable: false),
                    DeviceType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ExpectedResult = table.Column<bool>(type: "bit", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CreatedDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    IsActive = table.Column<bool>(type: "bit", nullable: false),
                    Notes = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ComplianceRules", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "ConfigTemplates",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    DeviceType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CreatedDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Version = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ConfigTemplates", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "ComplianceResults",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    RouterId = table.Column<int>(type: "int", nullable: false),
                    ConfigurationId = table.Column<int>(type: "int", nullable: false),
                    RuleId = table.Column<int>(type: "int", nullable: false),
                    Result = table.Column<bool>(type: "bit", nullable: false),
                    IsCompliant = table.Column<bool>(type: "bit", nullable: false),
                    LineNumber = table.Column<int>(type: "int", nullable: true),
                    MatchedContent = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CheckDate = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ComplianceResults", x => x.Id);
                    table.ForeignKey(
                        name: "FK_ComplianceResults_ComplianceRules_RuleId",
                        column: x => x.RuleId,
                        principalTable: "ComplianceRules",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_ComplianceResults_RouterConfigurations_ConfigurationId",
                        column: x => x.ConfigurationId,
                        principalTable: "RouterConfigurations",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_ComplianceResults_Routers_RouterId",
                        column: x => x.RouterId,
                        principalTable: "Routers",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_ConfigurationId",
                table: "ComplianceResults",
                column: "ConfigurationId");

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_RouterId",
                table: "ComplianceResults",
                column: "RouterId");

            migrationBuilder.CreateIndex(
                name: "IX_ComplianceResults_RuleId",
                table: "ComplianceResults",
                column: "RuleId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "ComplianceResults");

            migrationBuilder.DropTable(
                name: "ConfigTemplates");

            migrationBuilder.DropTable(
                name: "ComplianceRules");

            migrationBuilder.DropColumn(
                name: "EnablePassword",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250516142445_AddEnablePassword.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250516142445_AddEnablePassword")]
    partial class AddEnablePassword
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250520030802_AddRouterConfigurationsNavigation.cs
```cs
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddRouterConfigurationsNavigation : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}

```

### NCM3\Migrations\20250520030802_AddRouterConfigurationsNavigation.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250520030802_AddRouterConfigurationsNavigation")]
    partial class AddRouterConfigurationsNavigation
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250520085538_AddIsAvailableToRouter.cs
```cs
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddIsAvailableToRouter : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<bool>(
                name: "IsAvailable",
                table: "Routers",
                type: "bit",
                nullable: false,
                defaultValue: false);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "IsAvailable",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250520085538_AddIsAvailableToRouter.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250520085538_AddIsAvailableToRouter")]
    partial class AddIsAvailableToRouter
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250523025411_AddRouterGroup.cs
```cs
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddRouterGroup : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "Group",
                table: "Routers",
                type: "nvarchar(max)",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Group",
                table: "Routers");
        }
    }
}

```

### NCM3\Migrations\20250523025411_AddRouterGroup.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250523025411_AddRouterGroup")]
    partial class AddRouterGroup
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\20250524062658_AddBackupTypeAndCommentToRouterConfiguration.cs
```cs
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NCM3.Migrations
{
    /// <inheritdoc />
    public partial class AddBackupTypeAndCommentToRouterConfiguration : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "BackupType",
                table: "RouterConfigurations",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "Comment",
                table: "RouterConfigurations",
                type: "nvarchar(max)",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "BackupType",
                table: "RouterConfigurations");

            migrationBuilder.DropColumn(
                name: "Comment",
                table: "RouterConfigurations");
        }
    }
}

```

### NCM3\Migrations\20250524062658_AddBackupTypeAndCommentToRouterConfiguration.Designer.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    [Migration("20250524062658_AddBackupTypeAndCommentToRouterConfiguration")]
    partial class AddBackupTypeAndCommentToRouterConfiguration
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("BackupType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Comment")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Migrations\NCMDbContextModelSnapshot.cs
```cs
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NCM3.Models;

#nullable disable

namespace NCM3.Migrations
{
    [DbContext(typeof(NCMDbContext))]
    partial class NCMDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CheckDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("ConfigurationId")
                        .HasColumnType("int");

                    b.Property<bool>("IsCompliant")
                        .HasColumnType("bit");

                    b.Property<int?>("LineNumber")
                        .HasColumnType("int");

                    b.Property<string>("MatchedContent")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("Result")
                        .HasColumnType("bit");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<int>("RuleId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ConfigurationId");

                    b.HasIndex("RouterId");

                    b.HasIndex("RuleId");

                    b.ToTable("ComplianceResults");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceRule", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("ExpectedResult")
                        .HasColumnType("bit");

                    b.Property<bool>("IsActive")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Pattern")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Severity")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("ComplianceRules");
                });

            modelBuilder.Entity("NCM3.Models.ConfigTemplate", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DeviceType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("ConfigTemplates");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("EnablePassword")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Group")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Hostname")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("IpAddress")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("IsAvailable")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("LastBackup")
                        .HasColumnType("datetime2");

                    b.Property<string>("Model")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("OSVersion")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Password")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Routers");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("BackupBy")
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("BackupDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("BackupType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Comment")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("RouterId")
                        .HasColumnType("int");

                    b.Property<string>("Version")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("RouterId");

                    b.ToTable("RouterConfigurations");
                });

            modelBuilder.Entity("NCM3.Models.ComplianceResult", b =>
                {
                    b.HasOne("NCM3.Models.RouterConfiguration", "Configuration")
                        .WithMany()
                        .HasForeignKey("ConfigurationId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany()
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.NoAction)
                        .IsRequired();

                    b.HasOne("NCM3.Models.ComplianceRule", "Rule")
                        .WithMany()
                        .HasForeignKey("RuleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Configuration");

                    b.Navigation("Router");

                    b.Navigation("Rule");
                });

            modelBuilder.Entity("NCM3.Models.RouterConfiguration", b =>
                {
                    b.HasOne("NCM3.Models.Router", "Router")
                        .WithMany("RouterConfigurations")
                        .HasForeignKey("RouterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Router");
                });

            modelBuilder.Entity("NCM3.Models.Router", b =>
                {
                    b.Navigation("RouterConfigurations");
                });
#pragma warning restore 612, 618
        }
    }
}

```

### NCM3\Models\AppSettings.cs
```cs
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    /// <summary>
    /// Cài đặt chung của ứng dụng
    /// </summary>
    public class AppSettings
    {
        public string BackupFolder { get; set; } = string.Empty;
        public string ConfigBackupFolder { get; set; } = string.Empty;
        public string LogFolder { get; set; } = string.Empty;
        public string TemplatePath { get; set; } = string.Empty;
        public string ComplianceRulesPath { get; set; } = string.Empty;
        public int MaxBackupsPerRouter { get; set; } = 10;
        public int AutoBackupIntervalHours { get; set; } = 24;
    }
    
    /// <summary>
    /// Cài đặt thông báo
    /// </summary>
    public class NotificationSettings
    {
        public bool EnableTelegram { get; set; }
        public string TelegramBotToken { get; set; } = string.Empty;
        public string TelegramChatId { get; set; } = string.Empty;
        public bool EnableWebhook { get; set; }
        public string WebhookUrl { get; set; } = string.Empty;
        public bool NotifyOnConfigChange { get; set; } = true;
        public bool NotifyOnComplianceIssue { get; set; } = true;
        public bool NotifyOnConnectivityChange { get; set; } = true;
    }
    
    /// <summary>
    /// Cài đặt tự động phát hiện thay đổi
    /// </summary>
    public class AutoDetectionSettings
    {
        public bool EnableAutoDetection { get; set; }
        
        [Range(5, 1440, ErrorMessage = "Khoảng thời gian kiểm tra phải từ 5 đến 1440 phút")]
        public int CheckIntervalMinutes { get; set; } = 30;
        
        public bool DetectConfigChanges { get; set; } = true;
        public bool DetectConnectivityChanges { get; set; } = true;
        public bool DetectComplianceIssues { get; set; } = true;
    }
    
    /// <summary>
    /// View model cho trang cài đặt
    /// </summary>
    public class SettingsViewModel
    {
        public NotificationSettings NotificationSettings { get; set; } = new NotificationSettings();
        public AutoDetectionSettings AutoDetectionSettings { get; set; } = new AutoDetectionSettings();
        public bool DetectionServiceRunning { get; set; }
        public bool TelegramEnabled { get; set; }
        public string? TestResult { get; set; }
        public bool TestSuccessful { get; set; }
    }
}

```

### NCM3\Models\ChangeDetectionSettings.cs
```cs

```

### NCM3\Models\ComplianceResult.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace NCM3.Models
{
    public class ComplianceResult
    {
        public int Id { get; set; }
        
        [Required]
        public int RouterId { get; set; }
        
        [Required]
        public int ConfigurationId { get; set; }
        
        [Required]
        public int RuleId { get; set; }
        
        [Required]
        [Display(Name = "Kết quả")]
        public bool Result { get; set; }
        
        [Display(Name = "Tuân thủ")]
        public bool IsCompliant { get; set; }
        
        [Display(Name = "Dòng")]
        public int? LineNumber { get; set; }
        
        [Display(Name = "Nội dung")]
        public string? MatchedContent { get; set; }
        
        [Display(Name = "Ngày kiểm tra")]
        public DateTime CheckDate { get; set; } = DateTime.Now;
        
        // Navigation properties
        [ForeignKey("RouterId")]
        public virtual Router? Router { get; set; }
        
        [ForeignKey("ConfigurationId")]
        public virtual RouterConfiguration? Configuration { get; set; }
        
        [ForeignKey("RuleId")]
        public virtual ComplianceRule? Rule { get; set; }
    }
} 
```

### NCM3\Models\ComplianceRule.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class ComplianceRule
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "Tên quy tắc")]
        public string Name { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Biểu thức tìm kiếm")]
        public string Pattern { get; set; } = string.Empty;
        
        [Display(Name = "Mô tả")]
        public string? Description { get; set; }
        
        [Display(Name = "Mức độ")]
        public ComplianceSeverity Severity { get; set; } = ComplianceSeverity.Warning;
        
        [Display(Name = "Loại thiết bị")]
        public string? DeviceType { get; set; }
        
        [Display(Name = "Kết quả mong đợi")]
        public bool ExpectedResult { get; set; } = true;
        
        [Display(Name = "Người tạo")]
        public string? CreatedBy { get; set; }
        
        [Display(Name = "Ngày tạo")]
        public DateTime CreatedDate { get; set; } = DateTime.Now;
        
        [Display(Name = "Kích hoạt")]
        public bool IsActive { get; set; } = true;
        
        [Display(Name = "Ghi chú")]
        public string? Notes { get; set; }
    }
    
    public enum ComplianceSeverity
    {
        [Display(Name = "Thông tin")]
        Info = 0,
        
        [Display(Name = "Cảnh báo")]
        Warning = 1,
        
        [Display(Name = "Nghiêm trọng")]
        Critical = 2
    }
} 
```

### NCM3\Models\ConfigTemplate.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class ConfigTemplate
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "Tên Template")]
        public string Name { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Nội dung")]
        public string Content { get; set; } = string.Empty;
        
        [Display(Name = "Mô tả")]
        public string? Description { get; set; }
        
        [Display(Name = "Loại thiết bị")]
        public string? DeviceType { get; set; }
        
        [Display(Name = "Ngày tạo")]
        public DateTime CreatedDate { get; set; } = DateTime.Now;
        
        [Display(Name = "Người tạo")]
        public string? CreatedBy { get; set; }
        
        [Display(Name = "Phiên bản")]
        public string? Version { get; set; }
    }
} 
```

### NCM3\Models\ErrorViewModel.cs
```cs
namespace NCM3.Models
{
    public class ErrorViewModel
    {
        public string? RequestId { get; set; }

        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);
    }
}

```

### NCM3\Models\NCMDbContext.cs
```cs
using Microsoft.EntityFrameworkCore;

namespace NCM3.Models
{
    public class NCMDbContext : DbContext
    {
        public NCMDbContext(DbContextOptions<NCMDbContext> options) : base(options)
        {
        }
        
        public DbSet<Router> Routers { get; set; } = null!;
        public DbSet<RouterConfiguration> RouterConfigurations { get; set; } = null!;
        public DbSet<ConfigTemplate> ConfigTemplates { get; set; } = null!;
        public DbSet<ComplianceRule> ComplianceRules { get; set; } = null!;
        public DbSet<ComplianceResult> ComplianceResults { get; set; } = null!;
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Cấu hình cascade delete behavior
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Router)
                .WithMany()
                .HasForeignKey(c => c.RouterId)
                .OnDelete(DeleteBehavior.NoAction);
                
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Configuration)
                .WithMany()
                .HasForeignKey(c => c.ConfigurationId)
                .OnDelete(DeleteBehavior.NoAction);
                
            modelBuilder.Entity<ComplianceResult>()
                .HasOne(c => c.Rule)
                .WithMany()
                .HasForeignKey(c => c.RuleId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
} 
```

### NCM3\Models\Router.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class Router
    {
        public int Id { get; set; }
        
        [Required]
        [Display(Name = "Hostname")]
        public string Hostname { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "IP Address")]
        public string IpAddress { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Username")]
        public string Username { get; set; } = string.Empty;
        
        [Required]
        [Display(Name = "Password")]
        [DataType(DataType.Password)]
        public string Password { get; set; } = string.Empty;
        
        [Display(Name = "Enable Password")]
        [DataType(DataType.Password)]
        public string? EnablePassword { get; set; }
        
        [Display(Name = "Model")]
        public string? Model { get; set; }
        
        [Display(Name = "OS Version")]
        public string? OSVersion { get; set; }
        
        [Display(Name = "Last Configuration Backup")]
        public DateTime? LastBackup { get; set; }
        
        [Display(Name = "Status")]
        public string Status { get; set; } = "Unknown";
        
        [Display(Name = "Available")]
        public bool IsAvailable { get; set; } = false;
        
        [Display(Name = "Group")]
        public string? Group { get; set; }

        // Navigation property
        public virtual ICollection<RouterConfiguration> RouterConfigurations { get; set; } = new List<RouterConfiguration>();
    }
} 
```

### NCM3\Models\RouterConfiguration.cs
```cs
using System;
using System.ComponentModel.DataAnnotations;

namespace NCM3.Models
{
    public class RouterConfiguration
    {
        public int Id { get; set; }
        
        [Required]
        public int RouterId { get; set; }
        
        [Required]
        public DateTime BackupDate { get; set; }
        
        [Required]
        [Display(Name = "Configuration Content")]
        public string Content { get; set; } = string.Empty;
        
        [Display(Name = "Version/Label")]
        public string? Version { get; set; }        
        [Display(Name = "Backup By")]
        public string? BackupBy { get; set; }
        
        [Display(Name = "Backup Type")]
        public string? BackupType { get; set; }
        
        [Display(Name = "Comment")]
        public string? Comment { get; set; }
        
        // Navigation property
        public virtual Router? Router { get; set; }
    }
} 
```

### NCM3\Models\ViewModels\NotificationHistoryViewModel.cs
```cs
using System;
using System.Collections.Generic;

namespace NCM3.Models.ViewModels
{
    public class NotificationLogEntry
    {
        public string Type { get; set; } = string.Empty;
        public string Router { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool Success { get; set; }
        public string Details { get; set; } = string.Empty;
        public string AdditionalInfo { get; set; } = string.Empty;
    }

    public class NotificationHistoryViewModel
    {
        public List<NotificationLogEntry> RecentNotifications { get; set; } = new List<NotificationLogEntry>();
        public int TotalCount { get; set; }
        public string CurrentFilter { get; set; } = "all";
        public int Page { get; set; } = 1;
        public int PageSize { get; set; } = 20;
        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    }
}

```

### NCM3\Services\AmazonS3Service.cs
```cs

```

### NCM3\Services\AutomaticConfigurationChangeDetector.cs
```cs
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.EntityFrameworkCore;
using NCM3.Models;
using NCM3.Services;
using NCM3.Constants;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class AutomaticConfigurationChangeDetector : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<AutomaticConfigurationChangeDetector> _logger;
        private readonly IConfiguration _configuration;
        
        // Khoảng thời gian kiểm tra mặc định: 30 phút
        private TimeSpan _checkInterval = TimeSpan.FromMinutes(30);
        
        public AutomaticConfigurationChangeDetector(
            IServiceProvider serviceProvider,
            ILogger<AutomaticConfigurationChangeDetector> logger,
            IConfiguration configuration)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
            _configuration = configuration;
            
            // Cập nhật _checkInterval từ cấu hình
            if (int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int minutes) && minutes >= 5)
            {
                _checkInterval = TimeSpan.FromMinutes(minutes);
            }
        }        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Dịch vụ AutomaticConfigurationChangeDetector đã khởi động.");
            
            while (!stoppingToken.IsCancellationRequested)
            {
                // Kiểm tra xem dịch vụ có được bật hay không
                bool enabled = false;
                if (bool.TryParse(_configuration["AutoDetection:Enabled"], out bool isEnabled))
                {
                    enabled = isEnabled;
                }
                
                // Cập nhật _checkInterval từ cấu hình
                if (int.TryParse(_configuration["AutoDetection:CheckIntervalMinutes"], out int minutes) && minutes >= 5)
                {
                    _checkInterval = TimeSpan.FromMinutes(minutes);
                }
                
                if (enabled)
                {
                    _logger.LogInformation("Đang thực hiện kiểm tra thay đổi cấu hình. Sẽ kiểm tra lại sau {Interval} phút.",
                        _checkInterval.TotalMinutes);
                    
                    try
                    {
                        var startTime = DateTime.Now;
                        int changesDetected = await CheckForConfigurationChangesAsync();
                        var duration = DateTime.Now - startTime;
                        
                        _logger.LogInformation(
                            "Hoàn thành kiểm tra thay đổi, phát hiện {ChangesCount} thay đổi, thời gian xử lý: {Duration:hh\\:mm\\:ss}",
                            changesDetected,
                            duration);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Lỗi trong quá trình kiểm tra thay đổi cấu hình tự động");
                    }
                }
                else
                {
                    _logger.LogDebug("Dịch vụ tự động phát hiện thay đổi đang tắt. Sẽ kiểm tra lại sau {Interval} phút.",
                        _checkInterval.TotalMinutes);
                }
                
                // Đợi đến lần kiểm tra tiếp theo
                await Task.Delay(_checkInterval, stoppingToken);
            }
        }        private async Task<int> CheckForConfigurationChangesAsync()
        {
            _logger.LogInformation("Bắt đầu kiểm tra thay đổi cấu hình tự động...");
            int changesDetected = 0;
            
            // Kiểm tra loại phát hiện được bật
            bool detectConfigChanges = true;
            bool detectConnectivityChanges = true;
            bool detectComplianceIssues = true;
            
            if (_configuration["AutoDetection:DetectConfigChanges"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectConfigChanges"], out detectConfigChanges);
            }
            
            if (_configuration["AutoDetection:DetectConnectivityChanges"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectConnectivityChanges"], out detectConnectivityChanges);
            }
            
            if (_configuration["AutoDetection:DetectComplianceIssues"] != null)
            {
                bool.TryParse(_configuration["AutoDetection:DetectComplianceIssues"], out detectComplianceIssues);
            }
              using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<NCMDbContext>();
            var routerService = scope.ServiceProvider.GetRequiredService<RouterService>();
            var connectionService = scope.ServiceProvider.GetRequiredService<RouterConnectionService>();
            var notificationHelper = scope.ServiceProvider.GetRequiredService<NotificationHelper>();
            
            // Lấy danh sách router cần kiểm tra
            var routers = await dbContext.Routers
                .Include(r => r.RouterConfigurations)
                .ToListAsync();
                
            _logger.LogInformation("Tìm thấy {Count} router để kiểm tra", routers.Count);
            
            foreach (var router in routers)
            {
                try
                {                    // Kiểm tra kết nối nếu được bật
                    if (detectConnectivityChanges)
                    {
                        bool isConnected = await connectionService.TestConnectionAsync(router);
                        if (!isConnected)
                        {
                            _logger.LogWarning("Router {RouterName} không kết nối được", router.Hostname);
                            
                            // Gửi thông báo nếu cấu hình kết nối thay đổi                            if (router.IsAvailable) // Nếu trước đó vẫn đang kết nối được
                            {
                                var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                                await telegramService.SendConnectivityAlertAsync(
                                    router.Hostname,
                                    "Mất kết nối",
                                    $"Không thể kết nối đến router tại thời điểm {DateTime.Now:dd/MM/yyyy HH:mm:ss}"
                                );
                                changesDetected++;
                            }
                        }
                        else if (!router.IsAvailable) // Nếu trước đó không kết nối được, nhưng giờ đã kết nối được
                        {
                            _logger.LogInformation("Router {RouterName} đã khôi phục kết nối", router.Hostname);
                              var telegramService = scope.ServiceProvider.GetRequiredService<ITelegramNotificationService>();
                            await telegramService.SendConnectivityAlertAsync(
                                router.Hostname,
                                "Đã khôi phục kết nối",
                                $"Kết nối đến router đã được khôi phục tại thời điểm {DateTime.Now:dd/MM/yyyy HH:mm:ss}"
                            );
                            changesDetected++;
                        }
                        
                        // Cập nhật trạng thái kết nối
                        router.IsAvailable = isConnected;
                        await dbContext.SaveChangesAsync();
                    }
                    
                    // Kiểm tra thay đổi cấu hình nếu được bật và router vẫn kết nối được
                    if (detectConfigChanges && router.IsAvailable)
                    {
                        // Lấy cấu hình hiện tại từ router 
                        var currentConfig = await routerService.GetConfigurationAsync(router);
                        
                        // Tìm cấu hình cuối cùng trong database
                        var lastConfig = router.RouterConfigurations
                            .OrderByDescending(c => c.BackupDate)
                            .FirstOrDefault();
                            
                        // So sánh và phát hiện thay đổi
                        var hasChanges = lastConfig == null || lastConfig.Content != currentConfig;
                        
                        if (hasChanges)
                        {
                            _logger.LogInformation("Phát hiện thay đổi cấu hình trên router {RouterName}", router.Hostname);
                              // Lưu cấu hình mới
                            var newConfig = new RouterConfiguration
                            {
                                RouterId = router.Id,
                                BackupDate = DateTime.UtcNow,
                                Content = currentConfig,
                                Version = $"Auto_{DateTime.UtcNow:yyyyMMdd_HHmmss}",
                                BackupBy = "AutoDetector",
                                BackupType = BackupTypes.Automatic
                            };
                            
                            dbContext.RouterConfigurations.Add(newConfig);
                            router.LastBackup = newConfig.BackupDate;
                            await dbContext.SaveChangesAsync();
                            
                            // Tải lên S3 nếu tính năng được kích hoạt
                            bool enableS3Backup = _configuration.GetValue<bool>("AWS:S3:EnableS3Backup", false);
                            bool backupToS3OnChange = _configuration.GetValue<bool>("AWS:S3:BackupToS3OnChange", false);
                            
                            if (enableS3Backup && backupToS3OnChange)
                            {
                                var s3Service = scope.ServiceProvider.GetRequiredService<IS3BackupService>();
                                try
                                {
                                    // Corrected arguments for UploadBackupAsync
                                    bool s3UploadSuccess = await s3Service.UploadBackupAsync(router.Id, currentConfig, newConfig.Version, BackupTypes.Automatic);
                                    if (s3UploadSuccess)
                                    {
                                        _logger.LogInformation($"Đã tải bản sao lưu tự động {newConfig.Version} của router {router.Hostname} lên S3.");
                                        // Optionally, store S3 key or identifier if the UploadBackupAsync method is modified to return it.
                                        // For now, it returns bool. If you need the key, S3BackupService.UploadBackupAsync must be changed.
                                    }
                                    else
                                    {
                                        _logger.LogWarning($"Không tải được bản sao lưu tự động {newConfig.Version} của router {router.Hostname} lên S3.");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogError(ex, $"Lỗi khi tải bản sao lưu tự động {newConfig.Version} của router {router.Hostname} lên S3.");
                                }
                            }
                            
                            // Gửi thông báo
                            await notificationHelper.SendConfigurationChangeNotificationAsync(
                                router.Hostname,
                                "Phát hiện thay đổi tự động",
                                lastConfig?.Content ?? string.Empty,
                                currentConfig
                            );
                            
                            // Tăng bộ đếm thay đổi
                            changesDetected++;
                        }
                        else
                        {
                            _logger.LogDebug("Không có thay đổi cấu hình trên router {RouterName}", router.Hostname);
                        }
                    }
                    
                    // TODO: Kiểm tra tuân thủ nếu được bật
                    if (detectComplianceIssues && router.IsAvailable)
                    {
                        // Đoạn code kiểm tra tuân thủ sẽ được thêm vào sau
                        _logger.LogDebug("Kiểm tra tuân thủ đối với router {RouterName}", router.Hostname);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Lỗi khi kiểm tra thay đổi cấu hình cho router {RouterName}", router.Hostname);
                }
            }            _logger.LogInformation("Hoàn thành kiểm tra thay đổi cấu hình tự động");
            return changesDetected;
        }
    }
}

```

### NCM3\Services\BackupNotificationHandler.cs
```cs

```

### NCM3\Services\BackupService.cs
```cs

```

### NCM3\Services\ChangeDetectionOrchestrator.cs
```cs

```

### NCM3\Services\ConfigurationManagementService.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using NCM3.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NCM3.Constants;

namespace NCM3.Services
{
    public class ConfigurationManagementService
    {
        private readonly NCMDbContext _context;
        private readonly IDiffer _differ;
        private readonly ISideBySideDiffBuilder _diffBuilder;
        private readonly ILogger<ConfigurationManagementService> _logger;
        private readonly ITelegramNotificationService _telegramService;
        private readonly Microsoft.Extensions.Configuration.IConfiguration _configuration;
        private NotificationHelper? _notificationHelper;

        public ConfigurationManagementService(
            NCMDbContext context,
            ILogger<ConfigurationManagementService> logger,
            ITelegramNotificationService telegramService,
            Microsoft.Extensions.Configuration.IConfiguration configuration)
        {
            _context = context;
            _differ = new Differ();
            _diffBuilder = new SideBySideDiffBuilder(_differ);
            _logger = logger;
            _telegramService = telegramService;
            _configuration = configuration;
        }
        
        // Thiết lập NotificationHelper (để tránh lỗi circular dependency)
        public void SetNotificationHelper(NotificationHelper notificationHelper)
        {
            _notificationHelper = notificationHelper;
        }
        
        // So sánh cấu hình giữa các phiên bản
        public async Task<SideBySideDiffModel> CompareConfigurationsAsync(int configId1, int configId2)
        {
            _logger.LogInformation("So sánh cấu hình giữa ID {ConfigId1} và ID {ConfigId2}", configId1, configId2);
            
            var config1 = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId1);
            var config2 = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId2);
            
            if (config1 == null || config2 == null)
            {
                _logger.LogWarning("Không tìm thấy một trong các cấu hình để so sánh. ConfigId1: {ConfigId1}, ConfigId2: {ConfigId2}", 
                    configId1, configId2);
                return new SideBySideDiffModel();
            }
            
            // Ensure content is not null
            string content1 = config1.Content ?? string.Empty;
            string content2 = config2.Content ?? string.Empty;
            
            var diff = _diffBuilder.BuildDiffModel(content1, content2);
            return diff;
        }
        
        // So sánh cấu hình hiện tại với template
        public async Task<SideBySideDiffModel> CompareWithTemplateAsync(int configId, int templateId)
        {
            var config = await _context.RouterConfigurations.FirstOrDefaultAsync(c => c.Id == configId);
            var template = await _context.ConfigTemplates.FirstOrDefaultAsync(t => t.Id == templateId);
            
            if (config == null || template == null)
            {
                return new SideBySideDiffModel();
            }
            
            var diff = _diffBuilder.BuildDiffModel(template.Content, config.Content);
            return diff;
        }
        
        // Tìm kiếm trong cấu hình
        public async Task<List<SearchResult>> SearchInConfigurationsAsync(string searchTerm, int? routerId = null)
        {
            var results = new List<SearchResult>();
            
            try
            {
                IQueryable<RouterConfiguration> query = _context.RouterConfigurations
                    .Include(c => c.Router);
                
                if (routerId.HasValue)
                {
                    query = query.Where(c => c.RouterId == routerId.Value);
                }
                
                var configurations = await query.ToListAsync();
                
                foreach (var config in configurations)
                {
                    var matches = SearchInConfig(config.Content, searchTerm);
                    
                    if (matches.Any())
                    {
                        string routerName = "Unknown";
                        if (config.Router != null)
                        {
                            routerName = config.Router.Hostname;
                        }
                        
                        results.Add(new SearchResult
                        {
                            RouterId = config.RouterId,
                            RouterName = routerName,
                            ConfigId = config.Id,
                            BackupDate = config.BackupDate,
                            Version = config.Version,
                            Matches = matches
                        });
                    }
                }
            }
            catch (Exception)
            {
                // Xử lý ngoại lệ
            }
            
            return results;
        }

        private List<Match> SearchInConfig(string content, string searchTerm)
        {
            List<Match> matches = new List<Match>();
            
            try
            {
                Regex regex = new Regex(searchTerm, RegexOptions.IgnoreCase | RegexOptions.Multiline);
                var lines = content.Split('\n');
                
                for (int i = 0; i < lines.Length; i++)
                {
                    var line = lines[i];
                    var regexMatches = regex.Matches(line);
                    
                    if (regexMatches.Count > 0)
                    {
                        matches.Add(new Match
                        {
                            LineNumber = i + 1,
                            LineContent = line,
                            MatchCount = regexMatches.Count
                        });
                    }
                }
            }
            catch (Exception)
            {
                // Xử lý ngoại lệ
            }
            
            return matches;
        }
        
        // Kiểm tra tuân thủ
        public async Task<List<ComplianceResult>> CheckComplianceAsync(int configId)
        {
            var results = new List<ComplianceResult>();
            
            var config = await _context.RouterConfigurations
                .Include(c => c.Router)
                .FirstOrDefaultAsync(c => c.Id == configId);
            
            if (config == null)
            {
                return results;
            }
            
            var rules = await _context.ComplianceRules.ToListAsync();
            
            // Lọc các quy tắc phù hợp với loại thiết bị
            var filteredRules = rules.Where(r => r.IsActive && 
                (string.IsNullOrEmpty(r.DeviceType) || 
                 (config.Router != null && r.DeviceType == config.Router.Model))).ToList();
            
            foreach (var rule in filteredRules)
            {
                var complianceResult = new ComplianceResult
                {
                    RouterId = config.RouterId,
                    ConfigurationId = config.Id,
                    RuleId = rule.Id,
                    CheckDate = DateTime.Now
                };
                
                try
                {
                    bool patternFound = false;
                    string? matchedContent = null;
                    int? lineNumber = null;
                    
                    // Tìm pattern trong cấu hình
                    var regex = new Regex(rule.Pattern, RegexOptions.IgnoreCase | RegexOptions.Multiline);
                    var match = regex.Match(config.Content);
                    
                    if (match.Success)
                    {
                        patternFound = true;
                        matchedContent = match.Value;
                        
                        // Tính số dòng
                        var textBeforeMatch = config.Content.Substring(0, match.Index);
                        lineNumber = textBeforeMatch.Count(c => c == '\n') + 1;
                    }
                    
                    complianceResult.Result = patternFound;
                    complianceResult.IsCompliant = (patternFound == rule.ExpectedResult);
                    complianceResult.MatchedContent = matchedContent;
                    complianceResult.LineNumber = lineNumber;
                }
                catch (Exception)
                {
                    complianceResult.Result = false;
                    complianceResult.IsCompliant = false;
                }
                
                results.Add(complianceResult);
            }
            
            return results;
        }

        public async Task<RouterConfiguration> SaveConfigurationAsync(int routerId, string configText)
        {
            var router = await _context.Routers
                .Include(r => r.RouterConfigurations)
                .FirstOrDefaultAsync(r => r.Id == routerId);

            if (router == null)
            {
                throw new ArgumentException("Router not found");
            }

            var lastConfig = router.RouterConfigurations.OrderByDescending(c => c.BackupDate).FirstOrDefault();
            var hasChanges = lastConfig == null || lastConfig.Content != configText;

            if (hasChanges)
            {
                var newConfig = new RouterConfiguration
                {
                    RouterId = routerId,
                    Content = configText,
                    BackupDate = DateTime.UtcNow,
                    Version = lastConfig != null 
                        ? $"v{int.Parse(lastConfig.Version?.Replace("v", "") ?? "0") + 1}"
                        : "v1"
                };

                _context.RouterConfigurations.Add(newConfig);
                await _context.SaveChangesAsync();

                // Sử dụng NotificationHelper nếu đã được thiết lập
                if (_notificationHelper != null)
                {
                    await _notificationHelper.SendConfigurationChangeNotificationAsync(
                        router.Hostname,
                        lastConfig != null ? "Cập nhật cấu hình" : "Tạo cấu hình mới",
                        lastConfig?.Content ?? string.Empty,
                        configText
                    );
                }
                else
                {
                    // Sử dụng cách cũ nếu chưa thiết lập NotificationHelper
                    var diffDetails = lastConfig != null 
                        ? await GetDiffDetailsAsync(lastConfig.Content, configText)
                        : "Cấu hình mới được tạo";

                    await _telegramService.SendConfigChangeNotificationAsync(
                        router.Hostname,
                        lastConfig != null ? "Cập nhật cấu hình" : "Tạo cấu hình mới",
                        diffDetails
                    );
                }

                return newConfig;
            }

            return lastConfig;
        }

        private Task<string> GetDiffDetailsAsync(string oldConfig, string newConfig)
        {
            var diffBuilder = new InlineDiffBuilder(new Differ());
            var diff = diffBuilder.BuildDiffModel(oldConfig, newConfig);

            // Get the maximum number of diff lines from configuration
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            // Make sure we have a reasonable value
            maxDiffLines = Math.Max(5, maxDiffLines);

            // Get changes by type
            var deletedLines = diff.Lines.Where(l => l.Type == ChangeType.Deleted).ToList();
            var insertedLines = diff.Lines.Where(l => l.Type == ChangeType.Inserted).ToList();
            
            // Count total changes
            int totalChanges = deletedLines.Count + insertedLines.Count;
            
            var changes = new StringBuilder();
            changes.AppendLine($"Tổng thay đổi: {totalChanges} dòng ({deletedLines.Count} xóa, {insertedLines.Count} thêm)");
            
            // Limit how many lines we show of each type
            int deletedToShow = Math.Min(deletedLines.Count, maxDiffLines / 2);
            int insertedToShow = Math.Min(insertedLines.Count, maxDiffLines / 2);
            
            // If one type has fewer changes, allow the other type to use more of the quota
            if (deletedToShow < maxDiffLines / 2)
            {
                insertedToShow = Math.Min(insertedLines.Count, maxDiffLines - deletedToShow);
            }
            else if (insertedToShow < maxDiffLines / 2)
            {
                deletedToShow = Math.Min(deletedLines.Count, maxDiffLines - insertedToShow);
            }
            
            // Show deleted lines first
            if (deletedLines.Any())
            {
                changes.AppendLine("\nNội dung bị xóa:");
                foreach (var line in deletedLines.Take(deletedToShow))
                {
                    changes.AppendLine($"- {line.Text}");
                }
                
                if (deletedLines.Count > deletedToShow)
                {
                    changes.AppendLine($"- ... và {deletedLines.Count - deletedToShow} dòng xóa khác...");
                }
            }
            
            // Then show inserted lines
            if (insertedLines.Any())
            {
                changes.AppendLine("\nNội dung mới thêm vào:");
                foreach (var line in insertedLines.Take(insertedToShow))
                {
                    changes.AppendLine($"+ {line.Text}");
                }
                
                if (insertedLines.Count > insertedToShow)
                {
                    changes.AppendLine($"+ ... và {insertedLines.Count - insertedToShow} dòng thêm khác...");
                }
            }

            return Task.FromResult(changes.ToString());
        }
        
        // Thêm phương thức công khai để so sánh cấu hình từ bên ngoài
        public Task<string> GetConfigurationDiffAsync(string oldConfig, string newConfig)
        {
            return GetDiffDetailsAsync(oldConfig, newConfig);
        }
    }

    // Lớp kết quả tìm kiếm
    public class SearchResult
    {
        public int RouterId { get; set; }
        public string RouterName { get; set; } = string.Empty;
        public int ConfigId { get; set; }
        public DateTime BackupDate { get; set; }
        public string? Version { get; set; }
        public List<Match> Matches { get; set; } = new List<Match>();
    }

    public class Match
    {
        public int LineNumber { get; set; }
        public string LineContent { get; set; } = string.Empty;
        public int MatchCount { get; set; }
    }
} 
```

### NCM3\Services\EncryptionService.cs
```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public interface IEncryptionService
    {
        string Encrypt(string text);
        string Decrypt(string cipherText);
    }

    public class EncryptionService : IEncryptionService
    {
        private readonly byte[] _key;
        private readonly byte[] _iv;

        public EncryptionService(IConfiguration configuration)
        {
            var encryptionKey = configuration["EncryptionKey"];
            
            if (string.IsNullOrEmpty(encryptionKey))
            {
                throw new InvalidOperationException("Encryption key is not configured. Please add an EncryptionKey in appsettings.json");
            }

            // Sử dụng key từ cấu hình hoặc tạo key cố định từ chuỗi
            using (var deriveBytes = new Rfc2898DeriveBytes(encryptionKey, Encoding.UTF8.GetBytes("NCM3Salt"), 1000))
            {
                _key = deriveBytes.GetBytes(32); // 256 bits
                _iv = deriveBytes.GetBytes(16);  // 128 bits
            }
        }

        public string Encrypt(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            using (Aes aes = Aes.Create())
            {
                aes.Key = _key;
                aes.IV = _iv;

                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter sw = new StreamWriter(cs))
                        {
                            sw.Write(text);
                        }
                    }
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }

        public string Decrypt(string cipherText)
        {
            if (string.IsNullOrEmpty(cipherText))
                return cipherText;

            try
            {
                byte[] buffer = Convert.FromBase64String(cipherText);

                using (Aes aes = Aes.Create())
                {
                    aes.Key = _key;
                    aes.IV = _iv;

                    ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                    using (MemoryStream ms = new MemoryStream(buffer))
                    {
                        using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                        {
                            using (StreamReader sr = new StreamReader(cs))
                            {
                                return sr.ReadToEnd();
                            }
                        }
                    }
                }
            }
            catch
            {
                // Nếu không thể giải mã (có thể là dữ liệu không được mã hóa)
                return cipherText;
            }
        }
    }
}

```

### NCM3\Services\NotificationHelper.cs
```cs
using System;
using System.Threading.Tasks;
using NCM3.Models;
using NCM3.Services;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class NotificationHelper
    {        private readonly ITelegramNotificationService _telegramService;
        private readonly ConfigurationManagementService _configService;
        private readonly ILogger<NotificationHelper> _logger;
        private readonly IConfiguration _configuration;
        private readonly IWebhookNotificationService? _webhookService;
        private readonly NotificationLogger? _notificationLogger;
        
        public NotificationHelper(
            ITelegramNotificationService telegramService,
            ConfigurationManagementService configService,
            ILogger<NotificationHelper> logger,
            IConfiguration configuration,
            IWebhookNotificationService? webhookService = null,
            NotificationLogger? notificationLogger = null)
        {
            _telegramService = telegramService;
            _configService = configService;
            _logger = logger;
            _configuration = configuration;
            _webhookService = webhookService;
            _notificationLogger = notificationLogger;
        }
          /// <summary>
        /// Gửi thông báo về sự thay đổi cấu hình
        /// </summary>
        /// <param name="routerName">Tên router</param>
        /// <param name="changeType">Loại thay đổi (Cập nhật, Sao lưu, ...)</param>
        /// <param name="oldConfig">Cấu hình cũ</param>
        /// <param name="newConfig">Cấu hình mới</param>
        /// <returns>Task thực hiện việc gửi thông báo</returns>
        public async Task SendConfigurationChangeNotificationAsync(
            string routerName, 
            string changeType, 
            string oldConfig, 
            string newConfig)
        {
            try
            {
                // Tìm sự khác biệt giữa cấu hình cũ và mới
                string diffDetails = string.IsNullOrEmpty(oldConfig)
                    ? "Cấu hình mới được tạo"
                    : await _configService.GetConfigurationDiffAsync(oldConfig, newConfig);
                  // Gửi thông báo qua Telegram nếu được bật
                bool telegramEnabled = !string.IsNullOrEmpty(_configuration["Telegram:BotToken"]) &&
                                      !string.IsNullOrEmpty(_configuration["Telegram:ChatId"]);
                
                bool notifyOnConfigChange = true;
                if (_configuration["Notification:NotifyOnConfigChange"] != null)
                {
                    bool.TryParse(_configuration["Notification:NotifyOnConfigChange"], out notifyOnConfigChange);
                }
                
                if (telegramEnabled && notifyOnConfigChange)
                {
                    await _telegramService.SendConfigChangeNotificationAsync(
                        routerName,
                        changeType,
                        diffDetails
                    );
                }
                
                // Gửi webhook nếu được bật
                bool webhookEnabled = _webhookService != null && 
                                     !string.IsNullOrEmpty(_configuration["Notification:WebhookUrl"]);
                
                bool enableWebhook = false;
                if (_configuration["Notification:EnableWebhook"] != null)
                {
                    bool.TryParse(_configuration["Notification:EnableWebhook"], out enableWebhook);
                }
                
                if (webhookEnabled && enableWebhook)
                {
                    var payload = new 
                    {
                        routerName,
                        changeType,
                        diffDetails,
                        timestamp = DateTime.UtcNow
                    };
                    
                    await _webhookService!.SendWebhookNotificationAsync("configuration_change", payload);
                }
                
                _logger.LogInformation(
                    "Đã gửi thông báo thay đổi cấu hình cho router {RouterName}, loại thay đổi: {ChangeType}",
                    routerName,
                    changeType);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi gửi thông báo thay đổi cấu hình cho router {RouterName}: {Error}",
                    routerName,
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Kiểm tra sự thay đổi cấu hình và gửi thông báo nếu có thay đổi
        /// </summary>
        /// <param name="routerId">ID của router</param>
        /// <param name="newConfig">Cấu hình mới</param>
        /// <param name="changeType">Loại thay đổi (mặc định: Cập nhật cấu hình)</param>
        /// <returns>True nếu có thay đổi và thông báo được gửi, False nếu không có thay đổi</returns>
        public async Task<bool> DetectAndNotifyConfigurationChangeAsync(
            Router router,
            string newConfig,
            string changeType = "Cập nhật cấu hình")
        {
            if (router == null)
            {
                _logger.LogWarning("Không thể kiểm tra thay đổi cấu hình: router là null");
                return false;
            }
            
            // Kiểm tra cấu hình mới có thay đổi so với cấu hình cũ hay không
            var lastConfig = router.RouterConfigurations
                .OrderByDescending(c => c.BackupDate)
                .FirstOrDefault();
                
            var hasChanges = lastConfig == null || lastConfig.Content != newConfig;
            
            if (hasChanges)
            {
                string oldConfig = lastConfig?.Content ?? string.Empty;
                await SendConfigurationChangeNotificationAsync(
                    router.Hostname,
                    changeType,
                    oldConfig,
                    newConfig);
                return true;
            }
            
            return false;
        }
    }
}

```

### NCM3\Services\NotificationLogger.cs
```cs
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NCM3.Models;

namespace NCM3.Services
{
    /// <summary>
    /// Dịch vụ ghi log chi tiết cho hoạt động thông báo
    /// </summary>
    public class NotificationLogger
    {
        private readonly ILogger<NotificationLogger> _logger;
        private readonly IConfiguration _configuration;
        private readonly string _notificationLogPath;
        
        public NotificationLogger(
            ILogger<NotificationLogger> logger,
            IConfiguration configuration)
        {
            _logger = logger;
            _configuration = configuration;
            
            // Tạo thư mục log nếu cần
            var logFolder = _configuration["AppSettings:LogFolder"] ?? "Logs";
            _notificationLogPath = Path.Combine(logFolder, "notifications");
            
            if (!Directory.Exists(_notificationLogPath))
            {
                Directory.CreateDirectory(_notificationLogPath);
            }
        }
        
        /// <summary>
        /// Ghi log thông báo thay đổi cấu hình
        /// </summary>
        /// <param name="routerName">Tên router</param>
        /// <param name="changeType">Loại thay đổi</param>
        /// <param name="details">Chi tiết thay đổi</param>
        /// <param name="success">Thành công hay thất bại</param>
        /// <returns>Task ghi log</returns>
        public async Task LogConfigurationChangeNotificationAsync(
            string routerName, 
            string changeType, 
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "ConfigurationChange",
                    Router = routerName,
                    ChangeType = changeType,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("config_changes", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "Đã gửi thông báo thay đổi cấu hình cho router {RouterName}, loại thay đổi: {ChangeType}",
                        routerName,
                        changeType);
                }
                else
                {
                    _logger.LogWarning(
                        "Không thể gửi thông báo thay đổi cấu hình cho router {RouterName}, loại thay đổi: {ChangeType}",
                        routerName,
                        changeType);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi ghi log thông báo: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Ghi log thông báo kết nối
        /// </summary>
        /// <param name="routerName">Tên router</param>
        /// <param name="status">Trạng thái kết nối</param>
        /// <param name="details">Chi tiết</param>
        /// <param name="success">Thành công hay thất bại</param>
        /// <returns>Task ghi log</returns>
        public async Task LogConnectivityNotificationAsync(
            string routerName, 
            string status, 
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "Connectivity",
                    Router = routerName,
                    Status = status,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("connectivity", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "Đã gửi thông báo kết nối cho router {RouterName}, trạng thái: {Status}",
                        routerName,
                        status);
                }
                else
                {
                    _logger.LogWarning(
                        "Không thể gửi thông báo kết nối cho router {RouterName}, trạng thái: {Status}",
                        routerName,
                        status);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi ghi log thông báo: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Ghi log thông báo tuân thủ
        /// </summary>
        /// <param name="routerName">Tên router</param>
        /// <param name="ruleName">Tên quy tắc</param>
        /// <param name="severity">Mức độ nghiêm trọng</param>
        /// <param name="details">Chi tiết</param>
        /// <param name="success">Thành công hay thất bại</param>
        /// <returns>Task ghi log</returns>
        public async Task LogComplianceNotificationAsync(
            string routerName, 
            string ruleName, 
            string severity,
            string details, 
            bool success)
        {
            try
            {
                var logEntry = new
                {
                    Type = "Compliance",
                    Router = routerName,
                    Rule = ruleName,
                    Severity = severity,
                    Timestamp = DateTime.Now,
                    Success = success,
                    Details = details
                };
                
                await WriteLogEntryAsync("compliance", logEntry);
                
                if (success)
                {
                    _logger.LogInformation(
                        "Đã gửi thông báo tuân thủ cho router {RouterName}, quy tắc: {RuleName}, mức độ: {Severity}",
                        routerName,
                        ruleName,
                        severity);
                }
                else
                {
                    _logger.LogWarning(
                        "Không thể gửi thông báo tuân thủ cho router {RouterName}, quy tắc: {RuleName}, mức độ: {Severity}",
                        routerName,
                        ruleName,
                        severity);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi ghi log thông báo: {Error}",
                    ex.Message);
            }
        }
          private async Task WriteLogEntryAsync(string category, object logEntry)
        {
            try
            {
                string fileName = $"{DateTime.Now:yyyyMMdd}_{category}.log";
                string filePath = Path.Combine(_notificationLogPath, fileName);
                
                string logLine = JsonConvert.SerializeObject(logEntry) + Environment.NewLine;
                
                await File.AppendAllTextAsync(filePath, logLine, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi ghi log vào tệp: {Error}",
                    ex.Message);
            }
        }
        
        /// <summary>
        /// Lấy lịch sử thông báo gần đây
        /// </summary>
        /// <param name="filter">Bộ lọc: "all", "config", "connectivity", "compliance"</param>
        /// <param name="page">Trang hiện tại, bắt đầu từ 1</param>
        /// <param name="pageSize">Kích thước trang</param>
        /// <returns>Danh sách thông báo và thông tin phân trang</returns>
        public async Task<Models.ViewModels.NotificationHistoryViewModel> GetNotificationHistoryAsync(
            string filter = "all", 
            int page = 1, 
            int pageSize = 20)
        {
            var result = new Models.ViewModels.NotificationHistoryViewModel
            {
                CurrentFilter = filter,
                Page = page,
                PageSize = pageSize
            };
            
            try
            {
                var allLogs = new List<Models.ViewModels.NotificationLogEntry>();
                string[] filesToSearch = Directory.GetFiles(_notificationLogPath, "*.log")
                    .OrderByDescending(f => f)  // Sắp xếp theo thời gian tạo giảm dần
                    .Take(7)  // Lấy tối đa log của 7 ngày gần đây
                    .ToArray();
                
                foreach (var file in filesToSearch)
                {
                    string fileName = Path.GetFileNameWithoutExtension(file);
                    
                    // Bỏ qua các file không phù hợp với bộ lọc
                    if (filter != "all")
                    {
                        if (filter == "config" && !fileName.Contains("config_changes")) continue;
                        if (filter == "connectivity" && !fileName.Contains("connectivity")) continue;
                        if (filter == "compliance" && !fileName.Contains("compliance")) continue;
                    }
                    
                    if (File.Exists(file))
                    {
                        var lines = await File.ReadAllLinesAsync(file);
                        foreach (var line in lines)
                        {
                            try
                            {
                                var entry = JsonConvert.DeserializeObject<dynamic>(line);
                                var logEntry = new Models.ViewModels.NotificationLogEntry
                                {
                                    Type = entry.Type.ToString(),
                                    Router = entry.Router.ToString(),
                                    Timestamp = (DateTime)entry.Timestamp,
                                    Success = (bool)entry.Success,
                                    Details = entry.Details.ToString()
                                };
                                
                                if (entry.Type.ToString() == "Compliance")
                                {
                                    logEntry.Status = entry.Severity.ToString();
                                    logEntry.AdditionalInfo = entry.Rule.ToString();
                                }
                                else if (entry.Type.ToString() == "Connectivity")
                                {
                                    logEntry.Status = entry.Status.ToString();
                                }
                                else if (entry.Type.ToString() == "ConfigurationChange")
                                {
                                    logEntry.Status = entry.ChangeType.ToString();
                                }
                                
                                allLogs.Add(logEntry);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(ex, "Không thể phân tích log entry: {Line}", line);
                            }
                        }
                    }
                }
                
                // Sắp xếp theo thời gian giảm dần
                var sortedLogs = allLogs
                    .OrderByDescending(l => l.Timestamp)
                    .ToList();
                
                result.TotalCount = sortedLogs.Count;
                
                // Lấy dữ liệu theo trang
                result.RecentNotifications = sortedLogs
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .ToList();
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Lỗi khi lấy lịch sử thông báo: {Error}", ex.Message);
                return result;
            }
        }
    }
}

```

### NCM3\Services\RouterConnectionService.cs
```cs
using System;
using System.Threading.Tasks;
using System.Net.Sockets;
using NCM3.Models;
using NCM3.Constants;
using Microsoft.Extensions.Logging;

namespace NCM3.Services
{
    public class RouterConnectionService
    {
        private readonly ILogger<RouterConnectionService> _logger;
        
        public RouterConnectionService(ILogger<RouterConnectionService> logger)
        {
            _logger = logger;
        }
        
        /// <summary>
        /// Kiểm tra kết nối đến router
        /// </summary>
        /// <param name="router">Router cần kiểm tra</param>
        /// <returns>True nếu kết nối thành công, False nếu không kết nối được</returns>
        public async Task<bool> TestConnectionAsync(Router router)
        {
            if (router == null || string.IsNullOrEmpty(router.IpAddress))
            {
                _logger.LogWarning("Không thể kiểm tra kết nối đến router với IP rỗng hoặc null");
                return false;
            }
            
            _logger.LogDebug("Kiểm tra kết nối đến router {RouterName} ({IP})", 
                router.Hostname, router.IpAddress);
                
            // Kiểm tra kết nối TCP đến cổng SSH (mặc định là 22)
            using (var tcpClient = new TcpClient())
            {
                try
                {
                    var connectTask = tcpClient.ConnectAsync(router.IpAddress, DefaultSettings.SSHPort);
                    if (await Task.WhenAny(connectTask, Task.Delay(3000)) == connectTask)
                    {
                        _logger.LogInformation("Kết nối đến router {RouterName} ({IP}) thành công", 
                            router.Hostname, router.IpAddress);
                        return true;
                    }
                    else
                    {
                        _logger.LogWarning("Hết thời gian chờ kết nối đến router {RouterName} ({IP})", 
                            router.Hostname, router.IpAddress);
                        return false;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Không thể kết nối đến router {RouterName} ({IP}): {Message}", 
                        router.Hostname, router.IpAddress, ex.Message);
                    return false;
                }
            }
        }
    }
}

```

### NCM3\Services\RouterService.cs
```cs
using System;
using System.Threading.Tasks;
using System.Text;
using System.IO;
using System.Net.Sockets;
using NCM3.Models;
using NCM3.Constants;
using Renci.SshNet;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Configuration;

namespace NCM3.Services
{
    public class RouterService : IDisposable
    {
        private readonly IEncryptionService _encryptionService;
        private readonly NCMDbContext _context;
        private readonly ILogger<RouterService> _logger;
        private readonly IS3BackupService _s3Service;
        private readonly IConfiguration _configuration;
        private bool _disposed;

        public RouterService(
            IEncryptionService encryptionService, 
            NCMDbContext context, 
            ILogger<RouterService> logger,
            IS3BackupService s3Service,
            IConfiguration configuration)
        {
            _encryptionService = encryptionService;
            _context = context;
            _logger = logger;
            _s3Service = s3Service;
            _configuration = configuration;
        }

        public async Task<string> GetConfigurationAsync(Router router)
        {
            try
            {
                // Giải mã mật khẩu trước khi sử dụng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;
                
                // Test if the router's SSH port is reachable before attempting connection
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, DefaultSettings.SSHPort);
                        if (await Task.WhenAny(connectTask, Task.Delay(3000)) != connectTask)
                        {
                            return $"Error: Cannot establish TCP connection to router SSH port ({DefaultSettings.SSHPort}). Check if the device is online and port {DefaultSettings.SSHPort} is accessible.";
                        }
                    }
                    catch (Exception ex)
                    {
                        return $"Error: TCP connection failed - {ex.Message}";
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                try
                {
                client.Connect();
                }
                catch (Exception ex)
                {
                    return $"Error: SSH connection failed - {ex.Message}";
                }
                
                if (client.IsConnected)
                {
                    try
                    {
                        ShellStream shellStream = client.CreateShellStream("vt100", 80, 24, 800, 600, 1024);
                        
                        // Wait for the initial prompt
                        await Task.Delay(2000);
                        
                        // Clear any initial text
                        shellStream.Read();
                        
                        // If enable password is provided, enter privileged mode
                        if (!string.IsNullOrEmpty(decryptedEnablePassword))
                        {
                            shellStream.WriteLine(SSHCommands.Enable);
                            await Task.Delay(1000);
                            shellStream.WriteLine(decryptedEnablePassword);
                            await Task.Delay(1000);
                        }
                        
                        // Execute the show running-config command
                        shellStream.WriteLine(SSHCommands.TerminalLength);
                        await Task.Delay(1000);
                        shellStream.WriteLine(SSHCommands.ShowRunningConfig);
                        await Task.Delay(5000); // Longer wait for configuration to load
                        
                        // Read the output
                        string output = shellStream.Read();
                        client.Disconnect();
                        return output;
                    }
                    catch (Exception ex)
                    {
                        return $"Error during SSH session: {ex.Message}";
                    }
                    finally
                    {
                        if (client.IsConnected)
                        {
                    client.Disconnect();
                        }
                    }
                }
                
                return "Failed to connect to the router.";
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }
        
        // Debug method to test connectivity with detailed logging
        public async Task<string> DebugSshConnectionAsync(Router router)
        {
            StringBuilder log = new StringBuilder();
            
            try
            {
                // Giải mã mật khẩu trước khi sử dụng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;

                log.AppendLine($"[DEBUG] Attempting to connect to {router.IpAddress} with username {router.Username}");
                log.AppendLine($"[DEBUG] Enable password is {(string.IsNullOrEmpty(decryptedEnablePassword) ? "NOT SET" : "SET")}");
                log.AppendLine($"[DEBUG] Using SSH.NET library version: {typeof(Renci.SshNet.SshClient).Assembly.GetName().Version}");
                
                // Test if the port is even reachable
                log.AppendLine("[DEBUG] Testing TCP connectivity to port 22...");
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, 22);
                        if (await Task.WhenAny(connectTask, Task.Delay(5000)) != connectTask)
                        {
                            log.AppendLine("[DEBUG] ERROR: TCP connection timed out - port 22 is unreachable");
                            return log.ToString();
                        }
                        log.AppendLine("[DEBUG] TCP connection successful - port 22 is reachable");
                    }
                    catch (Exception ex)
                    {
                        log.AppendLine($"[DEBUG] ERROR: TCP connection failed - {ex.Message}");
                        return log.ToString();
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                log.AppendLine("[DEBUG] Connection timeout set to 45 seconds with 2 retry attempts");
                log.AppendLine("[DEBUG] Attempting to connect with standard SSH settings");
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                log.AppendLine("[DEBUG] Connecting via SSH...");
                try
                {
                    client.Connect();
                }
                catch (Exception ex)
                {
                    log.AppendLine($"[DEBUG] ERROR: {ex.Message}");
                    log.AppendLine($"[DEBUG] Stack trace: {ex.StackTrace}");
                    
                    if (ex.InnerException != null)
                    {
                        log.AppendLine($"[DEBUG] Inner exception: {ex.InnerException.Message}");
                    }
                    
                    log.AppendLine("[DEBUG] ------------ Cisco-specific troubleshooting ------------");
                    log.AppendLine("[DEBUG] This error typically occurs with Cisco devices when:");
                    log.AppendLine("[DEBUG] 1. The SSH service on the router needs to be reset");
                    log.AppendLine("[DEBUG] 2. The router has restrictions on allowed cipher suites");
                    log.AppendLine("[DEBUG] 3. The router's SSH version is incompatible");
                    log.AppendLine("[DEBUG] 4. There are resource constraints on the router");
                    log.AppendLine("[DEBUG] 5. The router's terminal monitor shows: SSH1: Session disconnected");
                    log.AppendLine("[DEBUG] ");
                    log.AppendLine("[DEBUG] Try the following on the router:");
                    log.AppendLine("[DEBUG] - no ip ssh server");
                    log.AppendLine("[DEBUG] - ip ssh server");
                    log.AppendLine("[DEBUG] - ip ssh version 2");
                    log.AppendLine("[DEBUG] - crypto key generate rsa modulus 2048");
                    log.AppendLine("[DEBUG] ------------ End Cisco troubleshooting tips ------------");
                    
                    return log.ToString();
                }
                
                if (client.IsConnected)
                {
                    log.AppendLine("[DEBUG] Successfully connected via SSH");
                    
                    log.AppendLine("[DEBUG] Creating shell stream");
                    ShellStream shellStream = client.CreateShellStream("vt100", 80, 24, 800, 600, 1024);
                    
                    log.AppendLine("[DEBUG] Waiting for initial prompt (3 seconds)");
                    await Task.Delay(3000);
                    
                    string initialOutput = shellStream.Read();
                    log.AppendLine($"[DEBUG] Initial prompt received: {initialOutput}");
                    
                    // If enable password is provided, enter privileged mode
                    if (!string.IsNullOrEmpty(decryptedEnablePassword))
                    {
                        log.AppendLine("[DEBUG] Sending 'enable' command");
                        shellStream.WriteLine("enable");
                        await Task.Delay(1000);
                        
                        string enablePrompt = shellStream.Read();
                        log.AppendLine($"[DEBUG] Enable prompt response: {enablePrompt}");
                        
                        log.AppendLine("[DEBUG] Sending enable password");
                        shellStream.WriteLine(decryptedEnablePassword);
                        await Task.Delay(1000);
                        
                        string passwordResponse = shellStream.Read();
                        log.AppendLine($"[DEBUG] Password response: {passwordResponse}");
                    }
                    else
                    {
                        log.AppendLine("[DEBUG] No enable password provided - skipping 'enable' command");
                    }
                    
                    // Test a simple command first
                    log.AppendLine("[DEBUG] Sending test command 'terminal length 0'");
                    shellStream.WriteLine("terminal length 0");
                    await Task.Delay(1000);
                    
                    string terminalResponse = shellStream.Read();
                    log.AppendLine($"[DEBUG] Terminal command response: {terminalResponse}");
                    
                    log.AppendLine("[DEBUG] Sending 'show version' command");
                    shellStream.WriteLine("show version");
                    await Task.Delay(3000);
                    
                    string versionOutput = shellStream.Read();
                    log.AppendLine($"[DEBUG] Version output (truncated): {versionOutput.Substring(0, Math.Min(100, versionOutput.Length))}...");
                    
                    log.AppendLine("[DEBUG] Disconnecting");
                    client.Disconnect();
                    log.AppendLine("[DEBUG] Disconnected successfully");
                    
                    return log.ToString();
                }
                else
                {
                    log.AppendLine("[DEBUG] Failed to connect to the router");
                    return log.ToString();
                }
            }
            catch (Exception ex)
            {
                log.AppendLine($"[DEBUG] ERROR: {ex.Message}");
                log.AppendLine($"[DEBUG] Stack trace: {ex.StackTrace}");
                
                if (ex.InnerException != null)
                {
                    log.AppendLine($"[DEBUG] Inner exception: {ex.InnerException.Message}");
                }
                
                return log.ToString();
            }
        }
        
        public async Task<bool> CheckConnectionAsync(Router router)
        {
            try
            {
                // Giải mã mật khẩu trước khi sử dụng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);

                // Test if the router's SSH port is reachable before attempting connection
                using (var tcpClient = new TcpClient())
                {
                    try
                    {
                        var connectTask = tcpClient.ConnectAsync(router.IpAddress, 22);
                        if (await Task.WhenAny(connectTask, Task.Delay(3000)) != connectTask)
                        {
                            router.Status = "Unreachable";
                            return false;
                        }
                    }
                    catch (Exception)
                    {
                        router.Status = "Unreachable";
                        router.IsAvailable = false;
                        return false;
                    }
                }
                
                // Configure SSH connection with longer timeouts and Cisco compatibility
                var connectionInfo = new Renci.SshNet.ConnectionInfo(
                    router.IpAddress,
                    22,
                    router.Username,
                    new PasswordAuthenticationMethod(router.Username, decryptedPassword)
                );
                
                // Longer timeouts and connection settings
                connectionInfo.Timeout = TimeSpan.FromSeconds(45);  // Even longer timeout
                connectionInfo.RetryAttempts = 2;
                
                // Cisco compatibility: use a client that's compatible with older Cisco routers
                using var client = new SshClient(connectionInfo);
                client.KeepAliveInterval = TimeSpan.FromSeconds(60);
                
                try
                {
                client.Connect();
                }
                catch (Exception)
                {
                    router.Status = "Authentication Failed";
                    router.IsAvailable = false;
                    return false;
                }
                
                bool isConnected = client.IsConnected;
                
                if (isConnected)
                {
                    var command = client.CreateCommand("show version");
                    string version = await Task.FromResult(command.Execute());
                    
                    // Parse the output to extract OS version and model information
                    // This is a simplified example - actual parsing would depend on the router's output format
                    if (!string.IsNullOrEmpty(version))
                    {
                        router.Status = "Connected";
                        router.IsAvailable = true;
                        
                        // Extract OS version (this is simplified)
                        if (version.Contains("Version"))
                        {
                            int startIndex = version.IndexOf("Version");
                            if (startIndex > 0)
                            {
                                int endIndex = version.IndexOf(",", startIndex);
                                if (endIndex > startIndex)
                                {
                                    router.OSVersion = version.Substring(startIndex, endIndex - startIndex).Trim();
                                }
                            }
                        }
                        
                        // Extract model information (simplified)
                        if (version.Contains("cisco"))
                        {
                            int startIndex = version.IndexOf("cisco");
                            if (startIndex > 0)
                            {
                                int endIndex = version.IndexOf("\n", startIndex);
                                if (endIndex > startIndex)
                                {
                                    router.Model = version.Substring(startIndex, endIndex - startIndex).Trim();
                                }
                            }
                        }
                    }
                    
                    client.Disconnect();
                    return true;
                }
                
                router.Status = "Disconnected";
                router.IsAvailable = false;
                return false;
            }
            catch (Exception)
            {
                router.Status = "Error";
                router.IsAvailable = false;
                return false;
            }
        }
        
        public async Task<bool> RestoreConfigurationAsync(Router router, string configuration)
        {
            // Validate input
            if (router == null)
            {
                _logger.LogError("Router cannot be null");
                return false;
            }
            
            if (string.IsNullOrWhiteSpace(configuration))
            {
                _logger.LogError("Configuration cannot be empty");
                return false;
            }
            
            // Validate IP address
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogError("Router {RouterName} has no IP address configured", router.Hostname);
                return false;
            }
            
            if (!System.Net.IPAddress.TryParse(router.IpAddress, out var ipAddress))
            {
                _logger.LogError("Router {RouterName} has invalid IP address: {IPAddress}", 
                    router.Hostname, router.IpAddress);
                return false;
            }

            _logger.LogInformation("Starting configuration restore for router {RouterName} at {IPAddress}", 
                router.Hostname, ipAddress.ToString());

            try
            {
                // Giải mã mật khẩu trước khi sử dụng
                string decryptedPassword = _encryptionService.Decrypt(router.Password);
                string? decryptedEnablePassword = !string.IsNullOrEmpty(router.EnablePassword) 
                    ? _encryptionService.Decrypt(router.EnablePassword) 
                    : string.Empty;
                
                using (var client = new SshClient(router.IpAddress, DefaultSettings.SSHPort, router.Username, decryptedPassword))
                {
                    _logger.LogInformation("Connecting to router {RouterName} at {IPAddress} to restore configuration", 
                        router.Hostname, router.IpAddress);
                    
                    // More generous timeout settings to avoid connection issues
                    client.ConnectionInfo.Timeout = TimeSpan.FromSeconds(45);
                    client.KeepAliveInterval = TimeSpan.FromSeconds(10);
                    
                    try
                    {
                        client.Connect();
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "SSH connection failed to router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                        return false;
                    }
                    
                    if (!client.IsConnected)
                    {
                        _logger.LogError("SSH connection failed - Unable to connect to router {RouterName}", router.Hostname);
                        return false;
                    }

                    // Create SSH shell with appropriate settings
                    using (var shell = client.CreateShellStream("dumb", 80, 24, 800, 600, 1024))
                    {
                        try
                        {
                            // Wait for initial prompt
                            _logger.LogDebug("Waiting for initial router prompt");
                            string output = await ReadUntilPromptAsync(shell, 8000);
                            
                            // Enter privileged mode if enable password is provided
                            if (!string.IsNullOrEmpty(decryptedEnablePassword))
                            {
                                _logger.LogDebug("Attempting to enter privileged mode");
                                shell.WriteLine("enable");
                                await Task.Delay(500);
                                
                                output = await ReadUntilPromptAsync(shell, 3000, new[] { "Password:", "password:" });
                                if (output.Contains("assword:"))
                                {
                                    shell.WriteLine(decryptedEnablePassword);
                                    await Task.Delay(1000);
                                    output = await ReadUntilPromptAsync(shell, 3000);
                                }
                                
                                if (!output.Contains("#"))
                                {
                                    _logger.LogWarning("Failed to enter privileged mode - continuing anyway but restoration may fail");
                                }
                                else
                                {
                                    _logger.LogDebug("Successfully entered privileged mode");
                                }
                            }
                            
                            // Enter configuration mode
                            _logger.LogDebug("Entering configuration mode");
                            shell.WriteLine("configure terminal");
                            await Task.Delay(1000);
                            output = await ReadUntilPromptAsync(shell, 3000);
                            
                            if (!output.Contains("config") && !output.Contains("conf t"))
                            {
                                _logger.LogWarning("Configuration mode prompt not detected, but continuing with restoration");
                            }
                            
                            // Process configuration line by line
                            int configLinesCount = 0;
                            int errorLinesCount = 0;
                            string[] configLines = configuration.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                            
                            _logger.LogInformation("Starting configuration restore with {LineCount} lines", configLines.Length);
                            
                            foreach (string line in configLines)
                            {
                                string trimmedLine = line.Trim();
                                if (string.IsNullOrWhiteSpace(trimmedLine) || trimmedLine.StartsWith("!") || trimmedLine.StartsWith("#"))
                                {
                                    continue; // Skip comments and empty lines
                                }
                                
                                shell.WriteLine(trimmedLine);
                                await Task.Delay(150); // Wait a bit between commands to avoid overwhelming the router
                                configLinesCount++;
                                
                                // Check for errors in router response
                                output = await ReadUntilPromptAsync(shell, 2000, new[] { 
                                    "% Invalid", "% Error", "% Incomplete", "% Ambiguous" 
                                });
                                
                                if (output.Contains("% Invalid") || output.Contains("% Error") || 
                                    output.Contains("% Incomplete") || output.Contains("% Ambiguous"))
                                {
                                    // Log error but continue with other commands
                                    _logger.LogWarning("Error encountered while applying line: {Line} - Response: {Output}", 
                                        trimmedLine, output.Trim());
                                    errorLinesCount++;
                                }
                            }
                            
                            double errorRate = configLinesCount > 0 ? (double)errorLinesCount / configLinesCount * 100 : 0;
                            _logger.LogInformation(
                                "Processed {ConfigLines} configuration lines with {ErrorCount} errors ({ErrorRate:F1}%)", 
                                configLinesCount, errorLinesCount, errorRate);
                            
                            // Exit config mode and save configuration
                            _logger.LogDebug("Exiting configuration mode");
                            shell.WriteLine("end");
                            await Task.Delay(1000);
                            output = await ReadUntilPromptAsync(shell, 3000);
                            
                            _logger.LogDebug("Saving configuration to NVRAM");
                            shell.WriteLine("write memory");
                            await Task.Delay(2000);
                            output = await ReadUntilPromptAsync(shell, 8000);
                            
                            // Check for failure conditions in the output
                            if (output.ToLower().Contains("fail") || output.ToLower().Contains("error") || 
                                output.ToLower().Contains("invalid"))
                            {
                                _logger.LogError("Failed to save configuration to NVRAM for router {RouterName}: {Output}", 
                                    router.Hostname, output.Trim());
                                return false;
                            }
                            
                            // If too many errors occurred, consider the restoration a failure
                            if (errorRate > 50 && configLinesCount > 10)
                            {
                                _logger.LogError(
                                    "Configuration restore had too many errors ({ErrorCount}/{TotalLines}, {ErrorRate:F1}%)", 
                                    errorLinesCount, configLinesCount, errorRate);
                                return false;
                            }
                            
                            _logger.LogInformation("Successfully restored and saved configuration for router {RouterName}", 
                                router.Hostname);
                            return true;
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex, "Error during configuration restore for router {RouterName}: {ErrorMessage}", 
                                router.Hostname, ex.Message);
                            return false;
                        }
                        finally
                        {
                            try
                            {
                                // Ensure we disconnect cleanly
                                if (client.IsConnected)
                                {
                                    _logger.LogDebug("Disconnecting from router {RouterName}", router.Hostname);
                                    client.Disconnect();
                                }
                            }
                            catch (Exception ex)
                            {
                                _logger.LogWarning(ex, "Error while disconnecting from router {RouterName}", router.Hostname);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled exception during configuration restore for router {RouterName}: {ErrorMessage}", 
                    router.Hostname, ex.Message);
                return false;
            }
        }
        
        private async Task<string> ReadUntilPromptAsync(ShellStream shell, int timeout, string[]? errorStrings = null)
        {
            var result = new StringBuilder();
            var startTime = DateTime.Now;
            
            // Define common prompt patterns for different router types
            string[] promptPatterns = new[] { 
                "#",                 // Standard privileged mode prompt
                ">",                 // Standard user mode prompt
                ":",                 // Sometimes seen in prompts
                "Password:",         // Password prompt
                "(config)#",         // Global configuration mode
                "(config-if)#",      // Interface configuration mode
                "(config-line)#",    // Line configuration mode
                "(config-router)#",  // Router protocol configuration
                "(config-dhcp)#",    // DHCP configuration
                "More--",            // Pager prompt
                "[yes/no]:",         // Confirmation prompt
                "[confirm]"          // Another confirmation pattern
            };
            
            _logger.LogDebug("Waiting for router prompt with {TimeoutMs}ms timeout", timeout);
            
            // Keep track of how much data we've received to detect stalled connections
            int lastResultLength = 0;
            int stallCounter = 0;
            
            while ((DateTime.Now - startTime).TotalMilliseconds < timeout)
            {
                if (shell.DataAvailable)
                {
                    string data = shell.Read();
                    if (!string.IsNullOrEmpty(data))
                    {
                        result.Append(data);
                        _logger.LogTrace("Received {DataLength} characters from router", data.Length);
                        
                        // Reset stall counter when we receive data
                        stallCounter = 0;
                        lastResultLength = result.Length;
                    }
                    
                    // Check for error strings if provided
                    if (errorStrings != null)
                    {
                        foreach (var errorString in errorStrings)
                        {
                            if (data.Contains(errorString) || result.ToString().Contains(errorString))
                            {
                                _logger.LogDebug("Detected error string in output: {ErrorString}", errorString);
                                return result.ToString();
                            }
                        }
                    }
                    
                    // Check for common prompt patterns
                    foreach (var pattern in promptPatterns)
                    {
                        if (data.Contains(pattern))
                        {
                            _logger.LogDebug("Detected prompt pattern: {Pattern}", pattern);
                            return result.ToString();
                        }
                    }
                    
                    // Use regex to detect general prompt patterns like hostname# or hostname>
                    // This helps with routers that have custom hostnames in their prompts
                    if (System.Text.RegularExpressions.Regex.IsMatch(data, @"\S+[#>](\s|$)"))
                    {
                        _logger.LogDebug("Detected generic prompt pattern with regex");
                        return result.ToString();
                    }
                }
                else
                {
                    // If the result hasn't changed in a while, we might be at a prompt but didn't match our patterns
                    if (result.Length > 0 && result.Length == lastResultLength)
                    {
                        stallCounter++;
                        if (stallCounter >= 10) // After ~1 second of no new data
                        {
                            _logger.LogDebug("No new data received for ~1 second, assuming prompt is available");
                            return result.ToString();
                        }
                    }
                }
                
                await Task.Delay(100);
            }
            
            _logger.LogWarning("Timeout reached while waiting for prompt. Timeout: {TimeoutMs}ms", timeout);
            _logger.LogWarning("Last received data: {LastData}", 
                result.Length > 0 ? result.ToString().Substring(Math.Max(0, result.Length - 50)) : "No data");
            return result.ToString();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    _context.Dispose();
                }
                _disposed = true;
            }
        }
    }
}
```

### NCM3\Services\S3BackupService.cs
```cs
using System;
using System.IO;
using System.Threading.Tasks;
using Amazon.S3;
using Amazon.S3.Model;
using Amazon.S3.Transfer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace NCM3.Services
{
    public interface IS3BackupService
    {
        Task<bool> UploadBackupAsync(int routerId, string configContent, string version, string backupBy);
        Task<bool> UploadDatabaseBackupAsync(string filePath);
        Task<string> DownloadBackupAsync(string key);
        Task<bool> DeleteBackupAsync(string key);
        Task<ListObjectsV2Response> ListBackupsAsync(string prefix = "");
    }

    public class S3BackupService : IS3BackupService
    {
        private readonly IAmazonS3 _s3Client;
        private readonly ILogger<S3BackupService> _logger;
        private readonly string _bucketName;
        private readonly string _configBackupPrefix;
        private readonly string _databaseBackupPrefix;

        public S3BackupService(
            IAmazonS3 s3Client,
            IConfiguration configuration,
            ILogger<S3BackupService> logger)
        {
            _s3Client = s3Client;
            _logger = logger;
            
            _bucketName = configuration["AWS:S3:BucketName"];
            _configBackupPrefix = configuration["AWS:S3:ConfigBackupPrefix"] ?? "config-backups/";
            _databaseBackupPrefix = configuration["AWS:S3:DatabaseBackupPrefix"] ?? "db-backups/";

            _logger.LogDebug($"S3BackupService initialized. Bucket: '{_bucketName}', ConfigPrefix: '{_configBackupPrefix}', DbPrefix: '{_databaseBackupPrefix}'");

            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("AWS S3 BucketName is not configured in appsettings.json. S3 backups will fail.");
                throw new ArgumentException("AWS S3 BucketName must be configured in appsettings.json");
            }
        }

        public async Task<bool> UploadBackupAsync(int routerId, string configContent, string version, string backupBy)
        {
            _logger.LogInformation("Attempting to upload backup to S3 for RouterId: {RouterId}, Version: {Version}", routerId, version);
            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("S3 BucketName is not configured. Cannot upload backup for RouterId: {RouterId}", routerId);
                return false;
            }

            try
            {
                string timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
                string key = $"{_configBackupPrefix}router_{routerId}/{timestamp}_{version}.config";
                _logger.LogDebug("Generated S3 key for RouterId {RouterId}: {Key}", routerId, key);
                
                using (var stream = new MemoryStream())
                using (var writer = new StreamWriter(stream))
                {
                    writer.Write(configContent);
                    writer.Flush();
                    stream.Position = 0;
                    
                    var request = new PutObjectRequest
                    {
                        BucketName = _bucketName,
                        Key = key,
                        InputStream = stream,
                        ContentType = "text/plain",
                        Metadata = 
                        {
                            ["router-id"] = routerId.ToString(),
                            ["backup-date"] = DateTime.UtcNow.ToString("o"), // ISO 8601 format
                            ["version"] = version,
                            ["backup-by"] = backupBy
                        }
                    };
                    
                    _logger.LogDebug("Sending PutObjectRequest to S3 for key: {Key}", key);
                    var response = await _s3Client.PutObjectAsync(request);
                    _logger.LogInformation("Successfully uploaded router configuration to S3: {Key}. HTTP Status: {StatusCode}, RequestId: {RequestId}", 
                                         key, response.HttpStatusCode, response.ResponseMetadata?.RequestId);
                    return true;
                }
            }
            catch (Amazon.S3.AmazonS3Exception s3Ex)
            {
                _logger.LogError(s3Ex, "AmazonS3Exception during S3 upload for RouterId: {RouterId}. ErrorCode: {ErrorCode}, StatusCode: {StatusCode}, AWSRequestId: {AWSRequestId}, Message: {S3Message}", 
                                 routerId, s3Ex.ErrorCode, s3Ex.StatusCode, s3Ex.RequestId, s3Ex.Message);
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Generic error uploading router configuration to S3 for RouterId: {RouterId}. Message: {ExceptionMessage}", 
                                 routerId, ex.Message);
                return false;
            }
        }

        public async Task<bool> UploadDatabaseBackupAsync(string filePath)
        {
            _logger.LogInformation("Attempting to upload database backup to S3 from path: {FilePath}", filePath);
            if (string.IsNullOrEmpty(_bucketName))
            {
                _logger.LogError("S3 BucketName is not configured. Cannot upload database backup from: {FilePath}", filePath);
                return false;
            }
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.LogError("Database backup file not found: {FilePath}", filePath);
                    return false;
                }
                
                string fileName = Path.GetFileName(filePath);
                string key = $"{_databaseBackupPrefix}{fileName}";
                _logger.LogDebug("Generated S3 key for database backup {FileName}: {Key}", fileName, key);
                
                // Use TransferUtility for larger files
                var fileTransferUtility = new TransferUtility(_s3Client);
                
                var uploadRequest = new TransferUtilityUploadRequest
                {
                    FilePath = filePath,
                    BucketName = _bucketName,
                    Key = key,
                    // Optional: Add metadata if needed
                    Metadata = 
                    {
                        ["backup-date"] = DateTime.UtcNow.ToString("o")
                    }
                };
                
                _logger.LogDebug("Sending TransferUtilityUploadRequest to S3 for key: {Key}", key);
                await fileTransferUtility.UploadAsync(uploadRequest);
                _logger.LogInformation("Successfully uploaded database backup to S3: {Key}", key);
                return true;
            }
            catch (Amazon.S3.AmazonS3Exception s3Ex)
            {
                 _logger.LogError(s3Ex, "AmazonS3Exception during S3 database backup upload from {FilePath}. ErrorCode: {ErrorCode}, StatusCode: {StatusCode}, AWSRequestId: {AWSRequestId}, Message: {S3Message}", 
                                 filePath, s3Ex.ErrorCode, s3Ex.StatusCode, s3Ex.RequestId, s3Ex.Message);
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Generic error uploading database backup to S3 from {FilePath}: {ExceptionMessage}", 
                                 filePath, ex.Message);
                return false;
            }
        }

        public async Task<string> DownloadBackupAsync(string key)
        {
            try
            {
                var request = new GetObjectRequest
                {
                    BucketName = _bucketName,
                    Key = key
                };
                
                using (var response = await _s3Client.GetObjectAsync(request))
                using (var reader = new StreamReader(response.ResponseStream))
                {
                    return await reader.ReadToEndAsync();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error downloading backup from S3: {Key}, {ErrorMessage}", key, ex.Message);
                throw;
            }
        }

        public async Task<bool> DeleteBackupAsync(string key)
        {
            try
            {
                var request = new DeleteObjectRequest
                {
                    BucketName = _bucketName,
                    Key = key
                };
                
                await _s3Client.DeleteObjectAsync(request);
                _logger.LogInformation("Successfully deleted backup from S3: {Key}", key);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting backup from S3: {Key}, {ErrorMessage}", key, ex.Message);
                return false;
            }
        }

        public async Task<ListObjectsV2Response> ListBackupsAsync(string prefix = "")
        {
            try
            {
                var request = new ListObjectsV2Request
                {
                    BucketName = _bucketName,
                    Prefix = string.IsNullOrEmpty(prefix) ? _configBackupPrefix : prefix,
                    MaxKeys = 1000
                };
                
                return await _s3Client.ListObjectsV2Async(request);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error listing backups from S3: {ErrorMessage}", ex.Message);
                throw;
            }
        }
    }
}
```

### NCM3\Services\TelegramNotificationService.cs
```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Linq;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services
{
    public interface ITelegramNotificationService
    {
        Task SendConfigChangeNotificationAsync(string routerName, string changeType, string details, string priority = "Low");
        Task SendComplianceAlertAsync(string routerName, string ruleName, string severity, string details);
        Task SendConnectivityAlertAsync(string routerName, string status, string details);
        Task SendConfigurationChangedEventAsync(ConfigurationChangedEvent configChangedEvent);
        Task SendDailySummaryAsync();
        void Initialize();
    }    public class TelegramNotificationService : ITelegramNotificationService, IDisposable
    {
        private readonly HttpClient _httpClient;
        private readonly string? _botToken;
        private readonly string? _chatId;
        private readonly ILogger<TelegramNotificationService> _logger;
        private readonly NotificationLogger? _notificationLogger;
        private readonly IConfiguration _configuration;
        
        private System.Timers.Timer? _consolidationTimer;
        private System.Timers.Timer? _dailySummaryTimer;
        private readonly ConcurrentDictionary<string, List<ConfigurationChangedEvent>> _pendingNotifications = new();
        private readonly ConcurrentBag<ConfigurationChangedEvent> _allEvents = new();
        
        private bool _isInitialized = false;        public TelegramNotificationService(
            IConfiguration configuration, 
            HttpClient httpClient, 
            ILogger<TelegramNotificationService> logger,
            NotificationLogger? notificationLogger = null)
        {
            _httpClient = httpClient;
            _configuration = configuration;
            _botToken = configuration["Telegram:BotToken"];
            _chatId = configuration["Telegram:ChatId"];
            _logger = logger;
            _notificationLogger = notificationLogger;
        }public async Task SendConfigChangeNotificationAsync(string routerName, string changeType, string details, string priority = "Low")
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram không được cấu hình. Bỏ qua gửi thông báo.");
                
                // Ghi log thông báo
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogConfigurationChangeNotificationAsync(
                        routerName, 
                        changeType, 
                        "Bỏ qua do Telegram chưa được cấu hình", 
                        false);
                }
                
                return; // Skip if Telegram is not configured
            }

            var message = $"🔔 *Thay đổi Cấu hình*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Loại thay đổi:* {changeType}\n" +
                         $"*Mức độ ưu tiên:* {priority}\n" +
                         $"*Chi tiết:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log thông báo
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    routerName, 
                    changeType, 
                    details, 
                    success);
            }
        }
          public async Task SendComplianceAlertAsync(string routerName, string ruleName, string severity, string details)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram không được cấu hình. Bỏ qua gửi thông báo.");
                
                // Ghi log thông báo
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogComplianceNotificationAsync(
                        routerName, 
                        ruleName, 
                        severity,
                        "Bỏ qua do Telegram chưa được cấu hình", 
                        false);
                }
                
                return;
            }

            var message = $"⚠️ *Cảnh báo tuân thủ*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Quy tắc:* {ruleName}\n" +
                         $"*Mức độ:* {severity}\n" +
                         $"*Chi tiết:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log thông báo
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogComplianceNotificationAsync(
                    routerName, 
                    ruleName, 
                    severity,
                    details, 
                    success);
            }
        }
          public async Task SendConnectivityAlertAsync(string routerName, string status, string details)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram không được cấu hình. Bỏ qua gửi thông báo.");
                
                // Ghi log thông báo
                if (_notificationLogger != null)
                {
                    await _notificationLogger.LogConnectivityNotificationAsync(
                        routerName, 
                        status, 
                        "Bỏ qua do Telegram chưa được cấu hình", 
                        false);
                }
                
                return;
            }

            var message = $"🔌 *Cảnh báo kết nối*\n\n" +
                         $"*Router:* {routerName}\n" +
                         $"*Trạng thái:* {status}\n" +
                         $"*Chi tiết:*\n{details}";

            bool success = await SendTelegramMessageAsync(message);
            
            // Ghi log thông báo
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConnectivityNotificationAsync(
                    routerName, 
                    status, 
                    details, 
                    success);
            }
        }      private async Task<bool> SendTelegramMessageAsync(string message)
    {
        try
        {
            var url = $"https://api.telegram.org/bot{_botToken}/sendMessage";
            string? parseMode = _configuration.GetValue<string>("Telegram:NotificationFormat", "MarkdownV2");
            parseMode ??= "MarkdownV2";
            bool enableMarkdown = _configuration.GetValue<bool>("Telegram:EnableMarkdownFormatting", true);
            
            // Format the message according to parse mode
            string formattedMessage = FormatMessage(message, parseMode, enableMarkdown);
            
            // Check if message is too long (Telegram limit is 4096 characters)
            const int telegramMaxMessageLength = 4096;
            
            if (formattedMessage.Length > telegramMaxMessageLength)
            {
                _logger.LogWarning("Message exceeds Telegram's 4096 character limit. Current length: {Length}. Truncating message.", formattedMessage.Length);
                
                // Find a good breaking point - preferably before a code block
                int truncateIndex = telegramMaxMessageLength - 100; // Leave room for the truncation notice
                
                // Try to find a natural break point like a newline
                int lastNewLine = formattedMessage.LastIndexOf('\n', truncateIndex);
                if (lastNewLine > telegramMaxMessageLength / 2)
                {
                    truncateIndex = lastNewLine;
                }
                
                // Truncate and add notice
                string truncatedMessage = formattedMessage.Substring(0, truncateIndex);
                truncatedMessage += "\n\n...[Nội dung bị cắt ngắn do quá dài]...";
                
                formattedMessage = truncatedMessage;
            }
            
            var payload = new
            {
                chat_id = _chatId,
                text = formattedMessage,
                parse_mode = parseMode
            };

            var content = new StringContent(
                JsonConvert.SerializeObject(payload),
                Encoding.UTF8,
                "application/json");

            _logger.LogDebug("Sending Telegram message with parse_mode: {ParseMode}", parseMode);
            _logger.LogTrace("Message content length: {Length}", formattedMessage.Length);

            var response = await _httpClient.PostAsync(url, content);
            
            if (!response.IsSuccessStatusCode)
            {
                var errorResponse = await response.Content.ReadAsStringAsync();
                _logger.LogError("Telegram API error: {StatusCode} {Response}", response.StatusCode, errorResponse);
                return false;
            }

            _logger.LogInformation("Successfully sent Telegram notification");
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending Telegram notification: {Message}", ex.Message);
            return false;
        }
    }
    
    private string FormatMessage(string message, string parseMode, bool enableMarkdown)
    {
        // If we're using HTML format or markdown is disabled, ensure no Markdown formatting is present
        if (!enableMarkdown)
        {
            message = message.Replace("*", "")
                           .Replace("_", "")
                           .Replace("`", "");
            return message;
        }
        
        if (parseMode.Equals("HTML", StringComparison.OrdinalIgnoreCase))
        {
            // Properly convert text formatting to paired HTML tags
            return ConvertMarkdownToHtml(message);
        }
        
        if (parseMode.Equals("MarkdownV2", StringComparison.OrdinalIgnoreCase))
        {
            // Replace code blocks first
            message = message.Replace("```", "ːːː"); // Temporary replacement
            
            // Escape special characters for MarkdownV2
            message = message.Replace("\\", "\\\\") // Must be first
                           .Replace("_", "\\_")
                           .Replace("*", "\\*")
                           .Replace("[", "\\[")
                           .Replace("]", "\\]")
                           .Replace("(", "\\(")
                           .Replace(")", "\\)")
                           .Replace("~", "\\~")
                           .Replace("`", "\\`")
                           .Replace(">", "\\>")
                           .Replace("#", "\\#")
                           .Replace("+", "\\+")
                           .Replace("-", "\\-")
                           .Replace("=", "\\=")
                           .Replace("|", "\\|")
                           .Replace(".", "\\.")
                           .Replace("!", "\\!")
                           .Replace("{", "\\{")
                           .Replace("}", "\\}");

            // Restore code blocks
            message = message.Replace("ːːː", "```");
        }
        
        return message;
    }public void Initialize()
        {
            if (_isInitialized)
            {
                return;
            }
            
            // Set up consolidation timer
            int consolidationInterval = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:ConsolidationIntervalMinutes", 
                _configuration.GetValue<int>("Telegram:ConsolidationIntervalMinutes", 30));
            
            _logger.LogInformation("Setting up notification consolidation timer with interval of {Minutes} minutes", 
                consolidationInterval);
                
            _consolidationTimer = new System.Timers.Timer(consolidationInterval * 60 * 1000); // Convert to milliseconds
            _consolidationTimer.Elapsed += async (sender, e) => await ProcessConsolidatedNotificationsAsync();
            _consolidationTimer.AutoReset = true;
            _consolidationTimer.Start();
            
            // Set up daily summary timer
            bool dailySummaryEnabled = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:DailySummaryEnabled", true);
            
            if (dailySummaryEnabled)
            {
                int dailySummaryHour = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:DailySummaryHour", 
                    _configuration.GetValue<int>("Telegram:DailySummaryHour", 9));
                    
                int dailySummaryMinute = _configuration.GetValue<int>("ChangeDetection:NotificationSettings:DailySummaryMinute",
                    _configuration.GetValue<int>("Telegram:DailySummaryMinute", 0));
                
                _logger.LogInformation("Setting up daily summary timer for {Hour}:{Minute}", 
                    dailySummaryHour, dailySummaryMinute.ToString("00"));
                
                var now = DateTime.Now;
                var summaryTime = new DateTime(now.Year, now.Month, now.Day, dailySummaryHour, dailySummaryMinute, 0);
                
                if (now > summaryTime)
                {
                    summaryTime = summaryTime.AddDays(1);
                }
                
                var timeToNextSummary = summaryTime - now;
                _logger.LogInformation("Next daily summary will run in {Hours} hours and {Minutes} minutes", 
                    timeToNextSummary.Hours, timeToNextSummary.Minutes);
                    
                _dailySummaryTimer = new System.Timers.Timer(timeToNextSummary.TotalMilliseconds);
                _dailySummaryTimer.Elapsed += async (sender, e) => 
                {
                    await SendDailySummaryAsync();
                    _dailySummaryTimer.Interval = 24 * 60 * 60 * 1000; // Set to 24 hours for subsequent runs
                };
                _dailySummaryTimer.AutoReset = true;
                _dailySummaryTimer.Start();
            }
            else
            {
                _logger.LogInformation("Daily summary notifications are disabled");
            }
            
            // Subscribe to the event bus if available
            try
            {
                var eventBus = GetEventBus();
                if (eventBus != null)
                {
                    eventBus.Subscribe<ConfigurationChangedEvent>(async (configChangedEvent) => 
                    {
                        await SendConfigurationChangedEventAsync(configChangedEvent);
                    });
                    _logger.LogInformation("Successfully subscribed to ConfigurationChangedEvent");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to subscribe to event bus: {ErrorMessage}", ex.Message);
            }
            
            _isInitialized = true;
        }
        
        private IEventBus? GetEventBus()
        {
            try
            {
                // Create a service scope to resolve the event bus (which might be registered as singleton)
                var serviceProvider = _httpClient.GetType().Assembly
                    .GetType("Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions")?
                    .GetMethod("GetService")?
                    .MakeGenericMethod(typeof(IServiceProvider))
                    .Invoke(null, new object[] { _httpClient }) as IServiceProvider;
                    
                if (serviceProvider != null)
                {
                    return serviceProvider.GetService(typeof(IEventBus)) as IEventBus;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resolving event bus: {ErrorMessage}", ex.Message);
            }
            
            return null;
        }
          public async Task SendConfigurationChangedEventAsync(ConfigurationChangedEvent configChangedEvent)
        {
            if (string.IsNullOrEmpty(_botToken) || string.IsNullOrEmpty(_chatId))
            {
                _logger.LogWarning("Telegram không được cấu hình. Bỏ qua gửi thông báo.");
                return;
            }
            
            // Add to all events for summary
            _allEvents.Add(configChangedEvent);
            
            // Check if this is a high-priority notification that should be sent immediately
            var sendImmediatelyFor = _configuration
                .GetSection("ChangeDetection:NotificationSettings:SendImmediatelyForPriorities")
                .Get<List<string>>() ?? new List<string> { "High" };
                
            if (sendImmediatelyFor.Any(p => string.Equals(p, configChangedEvent.Priority, StringComparison.OrdinalIgnoreCase)))
            {
                await SendImmediateNotificationAsync(configChangedEvent);
                return;
            }
            
            // Check if we should consolidate by router group
            bool consolidateByRouterGroup = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:ConsolidateByRouterGroup", true);
            
            // Get router key for grouping notifications
            string routerKey;
            if (consolidateByRouterGroup && !string.IsNullOrEmpty(configChangedEvent.Router.Group))
            {
                // Use router group for consolidation
                routerKey = $"Group:{configChangedEvent.Router.Group}";
                _logger.LogDebug("Using router group '{Group}' for consolidation of router {RouterName}", 
                    configChangedEvent.Router.Group, configChangedEvent.Router.Hostname);
            }
            else
            {
                // Use individual router for consolidation
                routerKey = configChangedEvent.Router.Hostname;
            }
            
            // Add to pending notifications for consolidation
            _pendingNotifications.AddOrUpdate(
                routerKey,
                new List<ConfigurationChangedEvent> { configChangedEvent },
                (_, existingList) => 
                {
                    existingList.Add(configChangedEvent);
                    
                    // Check if we've exceeded the warning threshold
                    int warningThreshold = _configuration.GetValue<int>(
                        "ChangeDetection:NotificationSettings:AlertThresholds:WarningChangesCount", 5);
                    int criticalThreshold = _configuration.GetValue<int>(
                        "ChangeDetection:NotificationSettings:AlertThresholds:CriticalChangesCount", 10);
                    
                    if (existingList.Count == warningThreshold)
                    {
                        // Log a warning about the number of pending changes
                        _logger.LogWarning("Warning threshold reached: {Count} pending changes for {RouterKey}", 
                            existingList.Count, routerKey);
                    }
                    else if (existingList.Count == criticalThreshold)
                    {
                        // Log a critical warning and trigger immediate processing for this router
                        _logger.LogCritical("Critical threshold reached: {Count} pending changes for {RouterKey}. Processing immediately.", 
                            existingList.Count, routerKey);
                            
                        // Schedule immediate processing for this router
                        Task.Run(async () => 
                        {
                            try
                            {
                                await ProcessConsolidatedNotificationsForKeyAsync(routerKey);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "Error processing immediate consolidated notifications for {RouterKey}", routerKey);
                            }
                        });
                    }
                    
                    return existingList;
                });
                
            _logger.LogDebug("Added configuration change for router {RouterName} to pending notifications queue under key {RouterKey}", 
                configChangedEvent.Router.Hostname, routerKey);
        }
        
        private async Task SendImmediateNotificationAsync(ConfigurationChangedEvent configChangedEvent)
        {
            _logger.LogInformation("Sending immediate notification for high-priority change on router {RouterName}", 
                configChangedEvent.Router.Hostname);
                
            bool sendDiffs = _configuration.GetValue<bool>("Telegram:SendDiffs", true);
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            
            string diffDetails = "Change details not available";
            
            if (sendDiffs && !string.IsNullOrEmpty(configChangedEvent.OldContent) && 
                !string.IsNullOrEmpty(configChangedEvent.NewContent))
            {
                diffDetails = GetDiffSummary(configChangedEvent.OldContent, configChangedEvent.NewContent, maxDiffLines);
            }
                
            var message = $"🚨 *IMPORTANT Configuration Change*\n\n" +
                         $"*Router:* {configChangedEvent.Router.Hostname}\n" +
                         $"*Detection Method:* {configChangedEvent.DetectionStrategy}\n" +
                         $"*Priority:* {configChangedEvent.Priority}\n" +
                         $"*Time:* {configChangedEvent.Timestamp.ToLocalTime():yyyy-MM-dd HH:mm:ss}\n" +
                         $"*Description:* {configChangedEvent.ChangeDescription}\n\n" +
                         $"*Changes:*\n```\n{diffDetails}\n```";
                         
            await SendTelegramMessageAsync(message);
            
            // Log notification
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    configChangedEvent.Router.Hostname, 
                    "High Priority - " + configChangedEvent.ChangeDescription, 
                    diffDetails, 
                    true);
            }
        }
          private async Task ProcessConsolidatedNotificationsAsync()
        {
            _logger.LogInformation("Processing consolidated notifications");
            
            int count = _pendingNotifications.Count;
            if (count == 0)
            {
                _logger.LogInformation("No pending notifications to process");
                return;
            }
            
            // Process each router's or group's notifications
            foreach (var routerKey in _pendingNotifications.Keys.ToArray())
            {
                await ProcessConsolidatedNotificationsForKeyAsync(routerKey);
            }
        }
        
        private async Task ProcessConsolidatedNotificationsForKeyAsync(string routerKey)
        {
            if (!_pendingNotifications.TryGetValue(routerKey, out var events) || events.Count == 0)
            {
                _logger.LogInformation("No pending notifications to process for {RouterKey}", routerKey);
                return;
            }
            
            _logger.LogInformation("Processing consolidated notifications for {RouterKey} with {Count} events", 
                routerKey, events.Count);
                
            bool sendDiffs = _configuration.GetValue<bool>("Telegram:SendDiffs", true);
            int maxDiffLines = _configuration.GetValue<int>("Telegram:MaxDiffLines", 10);
            int maxChangesPerMessage = _configuration.GetValue<int>(
                "ChangeDetection:NotificationSettings:MaxChangesPerConsolidatedMessage", 10);
            
            // Build a consolidated message
            var message = new StringBuilder();
            
            // Check if this is a group or individual router
            bool isGroup = routerKey.StartsWith("Group:", StringComparison.OrdinalIgnoreCase);
            string displayName = isGroup ? routerKey.Substring(6) : routerKey; // Remove "Group:" prefix if present
            
            message.AppendLine($"📊 *Consolidated Configuration Changes*");
            message.AppendLine();
            
            if (isGroup)
            {
                message.AppendLine($"*Router Group:* {displayName}");
                
                // Count unique routers in this group
                var uniqueRouters = events.Select(e => e.Router.Hostname).Distinct().ToList();
                message.AppendLine($"*Affected Routers:* {uniqueRouters.Count}");
                message.AppendLine($"*Routers:* {string.Join(", ", uniqueRouters.Take(5))}{(uniqueRouters.Count > 5 ? $" and {uniqueRouters.Count - 5} more..." : "")}");
            }
            else
            {
                message.AppendLine($"*Router:* {displayName}");
            }
            
            message.AppendLine($"*Number of changes:* {events.Count}");
            message.AppendLine($"*Time period:* {events.Min(e => e.Timestamp).ToLocalTime():HH:mm} - {events.Max(e => e.Timestamp).ToLocalTime():HH:mm}");
            message.AppendLine();
            
            // Group by priority
            var byPriority = events
                .GroupBy(e => e.Priority)
                .OrderBy(g => g.Key == "High" ? 0 : g.Key == "Medium" ? 1 : 2);
                
            message.AppendLine("*Changes by priority:*");
            foreach (var priorityGroup in byPriority)
            {
                string priorityEmoji = priorityGroup.Key == "High" ? "🔴" : 
                                       priorityGroup.Key == "Medium" ? "🟠" : "🟢";
                message.AppendLine($"{priorityEmoji} *{priorityGroup.Key}:* {priorityGroup.Count()} changes");
            }
            
            message.AppendLine();
            message.AppendLine("*Most significant changes:*");
            
            // Get the most recent high-priority event, if any
            var mostSignificantEvent = events
                .OrderBy(e => e.Priority == "High" ? 0 : e.Priority == "Medium" ? 1 : 2)
                .ThenByDescending(e => e.Timestamp)
                .FirstOrDefault();
                
            if (mostSignificantEvent != null && sendDiffs)
            {
                string diffDetails = GetDiffSummary(
                    mostSignificantEvent.OldContent, 
                    mostSignificantEvent.NewContent, 
                    maxDiffLines);
                    
                message.AppendLine("```");
                message.AppendLine(diffDetails);
                message.AppendLine("```");
            }
            
            await SendTelegramMessageAsync(message.ToString());
            
            // Log consolidated notification
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    routerKey, 
                    "Consolidated Changes", 
                    $"{events.Count} changes detected between {events.Min(e => e.Timestamp)} and {events.Max(e => e.Timestamp)}", 
                    true);
            }
            
            // Remove processed notifications
            _pendingNotifications.TryRemove(routerKey, out _);
        }
        
        public async Task SendDailySummaryAsync()
        {
            _logger.LogInformation("Generating daily notification summary");
            
            if (_allEvents.IsEmpty)
            {
                _logger.LogInformation("No events to include in the daily summary");
                return;
            }
            
            // Filter events from the last 24 hours
            var last24Hours = DateTime.UtcNow.AddDays(-1);
            var recentEvents = _allEvents.Where(e => e.Timestamp >= last24Hours).ToList();
            
            if (recentEvents.Count == 0)
            {
                _logger.LogInformation("No recent events to include in the daily summary");
                return;
            }
            
            var message = new StringBuilder();
            message.AppendLine($"📅 *Daily Configuration Change Summary*");
            message.AppendLine($"*Period:* {last24Hours.ToLocalTime():yyyy-MM-dd HH:mm} - {DateTime.Now:yyyy-MM-dd HH:mm}");
            message.AppendLine();
            
            // Group by router
            var byRouter = recentEvents
                .GroupBy(e => e.Router.Hostname)
                .OrderBy(g => g.Key);
                
            message.AppendLine($"*Total changes:* {recentEvents.Count} across {byRouter.Count()} routers");
            message.AppendLine();
            
            // Group by priority
            var byPriority = recentEvents
                .GroupBy(e => e.Priority)
                .OrderBy(g => g.Key == "High" ? 0 : g.Key == "Medium" ? 1 : 2);
                
            message.AppendLine("*Changes by priority:*");
            foreach (var priorityGroup in byPriority)
            {
                string priorityEmoji = priorityGroup.Key == "High" ? "🔴" : 
                                     priorityGroup.Key == "Medium" ? "🟠" : "🟢";
                message.AppendLine($"{priorityEmoji} *{priorityGroup.Key}:* {priorityGroup.Count()} changes");
            }
            
            message.AppendLine();
            message.AppendLine("*Changes by router:*");
            
            foreach (var routerGroup in byRouter)
            {
                message.AppendLine($"• *{routerGroup.Key}:* {routerGroup.Count()} changes");
                
                // Group by detection strategy
                var byStrategy = routerGroup
                    .GroupBy(e => e.DetectionStrategy)
                    .OrderBy(g => g.Key);
                    
                foreach (var strategyGroup in byStrategy)
                {
                    message.AppendLine($"  - {strategyGroup.Key}: {strategyGroup.Count()} changes");
                }
            }
            
            await SendTelegramMessageAsync(message.ToString());
            
            // Log daily summary
            if (_notificationLogger != null)
            {
                await _notificationLogger.LogConfigurationChangeNotificationAsync(
                    "All Routers", 
                    "Daily Summary", 
                    $"{recentEvents.Count} changes across {byRouter.Count()} routers in the last 24 hours", 
                    true);
            }
        }          private string GetDiffSummary(string oldContent, string newContent, int maxLines)
        {
            try
            {
                // Get diff settings from configuration
                bool ignoreWhitespace = _configuration.GetValue<bool>("ChangeDetection:DiffGeneration:IgnoreWhitespace", true);
                bool ignoreCase = _configuration.GetValue<bool>("ChangeDetection:DiffGeneration:IgnoreCase", false);
                
                // Apply filters based on configuration
                bool ignoreCommentChanges = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:FilterRules:IgnoreCommentChanges", true);
                bool ignoreDateTimeChanges = _configuration.GetValue<bool>("ChangeDetection:NotificationSettings:FilterRules:IgnoreDateTimeChanges", true);
                
                // More aggressive filtering to reduce message size
                bool compactMode = true; // Always use compact mode to reduce size
                
                // Simple diff implementation - split and compare lines
                var oldLines = FilterLines(oldContent, ignoreWhitespace, ignoreCase, ignoreCommentChanges, ignoreDateTimeChanges);
                var newLines = FilterLines(newContent, ignoreWhitespace, ignoreCase, ignoreCommentChanges, ignoreDateTimeChanges);
                
                var addedLines = newLines.Except(oldLines).ToList();
                var removedLines = oldLines.Except(newLines).ToList();
                
                var result = new StringBuilder();
                
                // Add a small summary
                int totalChanges = addedLines.Count + removedLines.Count;
                result.AppendLine($"Tổng thay đổi: {totalChanges} dòng ({removedLines.Count} xóa, {addedLines.Count} thêm)");
                
                if (totalChanges > 0)
                {
                    result.AppendLine();
                    
                    if (compactMode)
                    {
                        // In compact mode, just show limited number of the most significant changes
                        int shownChanges = Math.Min(maxLines, Math.Max(1, totalChanges));
                        
                        // Prioritize important keywords in the changes
                        var prioritizedRemovals = PrioritizeImportantChanges(removedLines);
                        var prioritizedAdditions = PrioritizeImportantChanges(addedLines);
                        
                        // Show most important removed lines first (with - prefix)
                        int removalsToShow = Math.Min(prioritizedRemovals.Count, maxLines / 2);
                        if (removalsToShow > 0)
                        {
                            result.AppendLine("Nội dung bị xóa:");
                            foreach (var line in prioritizedRemovals.Take(removalsToShow))
                            {
                                result.AppendLine($"- {line}");
                            }
                            
                            if (removedLines.Count > removalsToShow)
                            {
                                result.AppendLine($"- ... và {removedLines.Count - removalsToShow} dòng khác...");
                            }
                        }
                        
                        if (prioritizedAdditions.Any() && prioritizedRemovals.Any())
                        {
                            result.AppendLine();
                        }
                        
                        // Show most important added lines (with + prefix)
                        int additionsToShow = Math.Min(prioritizedAdditions.Count, maxLines / 2);
                        if (additionsToShow > 0)
                        {
                            result.AppendLine("Nội dung mới thêm vào:");
                            foreach (var line in prioritizedAdditions.Take(additionsToShow))
                            {
                                result.AppendLine($"+ {line}");
                            }
                            
                            if (addedLines.Count > additionsToShow)
                            {
                                result.AppendLine($"+ ... và {addedLines.Count - additionsToShow} dòng khác...");
                            }
                        }
                    }
                    else
                    {
                        // Standard mode - shows equal number of removed and added lines
                        // Show removed lines first (with - prefix)
                        foreach (var line in removedLines.Take(maxLines / 2))
                        {
                            result.AppendLine($"- {line}");
                        }
                        
                        if (removedLines.Count > maxLines / 2)
                        {
                            result.AppendLine($"- ... và {removedLines.Count - maxLines / 2} dòng xóa khác...");
                        }
                        
                        if (removedLines.Any() && addedLines.Any())
                        {
                            result.AppendLine("---");
                        }
                        
                        // Then show added lines (with + prefix)
                        foreach (var line in addedLines.Take(maxLines / 2))
                        {
                            result.AppendLine($"+ {line}");
                        }
                        
                        if (addedLines.Count > maxLines / 2)
                        {
                            result.AppendLine($"+ ... và {addedLines.Count - maxLines / 2} dòng thêm khác...");
                        }
                    }
                }
                else
                {
                    result.AppendLine("Không phát hiện thay đổi");
                }
                
                return result.ToString();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating diff summary: {Message}", ex.Message);
                return "Error generating diff";
            }
        }
        
        private List<string> FilterLines(string content, bool ignoreWhitespace, bool ignoreCase, bool ignoreCommentChanges, bool ignoreDateTimeChanges)
        {
            return content.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(line => {
                    // Apply filters based on configuration
                    if (ignoreWhitespace)
                        line = line.Trim();
                    if (ignoreCase)
                        line = line.ToLowerInvariant();
                    if (ignoreCommentChanges && (line.TrimStart().StartsWith("!") || line.TrimStart().StartsWith("//")))
                        return null; // Skip comment lines
                    if (ignoreDateTimeChanges && (line.Contains("uptime") || line.Contains("Last configuration change")))
                        return null; // Skip timestamp lines
                    return line;
                })
                .Where(line => line != null)
                .ToList();
        }
        
        private List<string> PrioritizeImportantChanges(List<string> lines)
        {
            // Keywords that indicate important configuration changes
            var importantKeywords = new[] {
                "interface", "ip address", "router", "hostname", "enable", "password", 
                "crypto", "access-list", "route", "nat", "firewall", "policy", "vlan", 
                "security", "username", "service", "tunnel"
            };
            
            // Prioritize lines containing important keywords
            var prioritized = lines
                .Select(line => new { 
                    Line = line, 
                    Priority = importantKeywords.Any(k => line.Contains(k, StringComparison.OrdinalIgnoreCase)) ? 0 : 1
                })
                .OrderBy(x => x.Priority)
                .Select(x => x.Line)
                .ToList();
                
            return prioritized;
        }
        
        private string ConvertMarkdownToHtml(string markdown)
        {
            var result = new StringBuilder();
            var chars = markdown.ToCharArray();
            var i = 0;
            var openTags = new Stack<char>();

            while (i < chars.Length)
            {
                switch (chars[i])
                {
                    case '*':
                        if (openTags.Count > 0 && openTags.Peek() == '*')
                        {
                            result.Append("</b>");
                            openTags.Pop();
                        }
                        else
                        {
                            result.Append("<b>");
                            openTags.Push('*');
                        }
                        break;
                    case '_':
                        if (openTags.Count > 0 && openTags.Peek() == '_')
                        {
                            result.Append("</i>");
                            openTags.Pop();
                        }
                        else
                        {
                            result.Append("<i>");
                            openTags.Push('_');
                        }
                        break;
                    case '`':
                        if (i + 2 < chars.Length && chars[i + 1] == '`' && chars[i + 2] == '`')
                        {
                            // Handle code blocks (```
                            if (openTags.Count > 0 && openTags.Peek() == '3')
                            {
                                result.Append("</pre>");
                                openTags.Pop();
                            }
                            else
                            {
                                result.Append("<pre>");
                                openTags.Push('3');
                            }
                            i += 2; // Skip the next two backticks
                        }
                        else
                        {
                            // Handle inline code (`
                            if (openTags.Count > 0 && openTags.Peek() == '`')
                            {
                                result.Append("</code>");
                                openTags.Pop();
                            }
                            else
                            {
                                result.Append("<code>");
                                openTags.Push('`');
                            }
                        }
                        break;
                    default:
                        result.Append(chars[i]);
                        break;
                }
                i++;
            }

            // Close any remaining open tags
            while (openTags.Count > 0)
            {
                var tag = openTags.Pop();
                switch (tag)
                {
                    case '*':
                        result.Append("</b>");
                        break;
                    case '_':
                        result.Append("</i>");
                        break;
                    case '`':
                        result.Append("</code>");
                        break;
                    case '3':
                        result.Append("</pre>");
                        break;
                }
            }

            return result.ToString();
        }
        
        public void Dispose()
        {
            _consolidationTimer?.Stop();
            _consolidationTimer?.Dispose();
            
            _dailySummaryTimer?.Stop();
            _dailySummaryTimer?.Dispose();
        }
    }
}
```

### NCM3\Services\WebhookNotificationService.cs
```cs
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NCM3.Models;

namespace NCM3.Services
{
    public interface IWebhookNotificationService
    {
        Task SendWebhookNotificationAsync(string eventType, object payload);
    }
      public class WebhookNotificationService : IWebhookNotificationService
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<WebhookNotificationService> _logger;
        private readonly IConfiguration _configuration;
        private readonly NotificationLogger? _notificationLogger;
        
        public WebhookNotificationService(
            HttpClient httpClient,
            ILogger<WebhookNotificationService> logger,
            IConfiguration configuration,
            NotificationLogger? notificationLogger = null)
        {
            _httpClient = httpClient;
            _logger = logger;
            _configuration = configuration;
            _notificationLogger = notificationLogger;
        }
          public async Task SendWebhookNotificationAsync(string eventType, object payload)
        {
            var webhookUrl = _configuration["Notification:WebhookUrl"];
            if (string.IsNullOrEmpty(webhookUrl))
            {
                _logger.LogWarning("Webhook không được cấu hình. Bỏ qua gửi thông báo.");
                return;
            }
            
            try
            {
                var notificationPayload = new
                {
                    eventType,
                    timestamp = DateTime.UtcNow,
                    data = payload
                };
                
                var content = new StringContent(
                    JsonConvert.SerializeObject(notificationPayload),
                    Encoding.UTF8,
                    "application/json");
                
                var response = await _httpClient.PostAsync(webhookUrl, content);
                response.EnsureSuccessStatusCode();
                
                _logger.LogInformation(
                    "Gửi webhook thành công cho sự kiện {EventType}",
                    eventType);
                  // Ghi log thông báo
                if (_notificationLogger != null)
                {
                    // Xác định loại thông báo dựa trên eventType
                    if (eventType == "configuration_change")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var configData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogConfigurationChangeNotificationAsync(
                            configData?.routerName?.ToString() ?? "Unknown",
                            configData?.changeType?.ToString() ?? "Unknown",
                            configData?.diffDetails?.ToString() ?? "No details",
                            true);
                    }
                    else if (eventType == "connectivity_alert")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var connectData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogConnectivityNotificationAsync(
                            connectData?.routerName?.ToString() ?? "Unknown",
                            connectData?.status?.ToString() ?? "Unknown",
                            connectData?.details?.ToString() ?? "No details",
                            true);
                    }
                    else if (eventType == "compliance_alert")
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var complianceData = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        await _notificationLogger.LogComplianceNotificationAsync(
                            complianceData?.routerName?.ToString() ?? "Unknown",
                            complianceData?.ruleName?.ToString() ?? "Unknown",
                            complianceData?.severity?.ToString() ?? "Unknown",
                            complianceData?.details?.ToString() ?? "No details",
                            true);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Lỗi khi gửi webhook cho sự kiện {EventType}: {Message}",
                    eventType,
                    ex.Message);
                  // Ghi log thông báo
                if (_notificationLogger != null)
                {
                    try
                    {
                        var jsonPayload = JsonConvert.SerializeObject(payload);
                        var data = JsonConvert.DeserializeObject<dynamic>(jsonPayload);
                        string routerName = data?.routerName?.ToString() ?? "Unknown";
                        
                        if (eventType == "configuration_change")
                        {
                            await _notificationLogger.LogConfigurationChangeNotificationAsync(
                                routerName,
                                data?.changeType?.ToString() ?? "Unknown",
                                $"Lỗi gửi webhook: {ex.Message}",
                                false);
                        }
                    }
                    catch
                    {
                        // Bỏ qua lỗi khi xử lý dữ liệu payload
                        _logger.LogWarning("Không thể ghi log thông báo do định dạng dữ liệu không hợp lệ");
                    }
                }
            }
        }
    }
}

```

### NCM3\Services\ChangeDetection\ChangeDetectionOrchestrator.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Orchestrates multiple configuration change detection strategies
    /// </summary>
    public class ChangeDetectionOrchestrator : BackgroundService
    {        private readonly ILogger<ChangeDetectionOrchestrator> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<IEnumerable<IChangeDetectionStrategy>> _strategiesFactory;
        private readonly IEventBus _eventBus;
        
        public ChangeDetectionOrchestrator(
            ILogger<ChangeDetectionOrchestrator> logger,
            IConfiguration configuration,
            Func<IEnumerable<IChangeDetectionStrategy>> strategiesFactory,
            IEventBus eventBus)
        {
            _logger = logger;
            _configuration = configuration;
            _strategiesFactory = strategiesFactory;
            _eventBus = eventBus;
        }
        
        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            try
            {
                _logger.LogInformation("Starting Change Detection Orchestrator");
                  // Initialize all strategies
                var strategies = _strategiesFactory();
                foreach (var strategy in strategies)
                {
                    try
                    {
                        await strategy.InitializeAsync(stoppingToken);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error initializing strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
                
                // Start all enabled strategies
                foreach (var strategy in strategies)
                {
                    try
                    {
                        if (strategy.IsEnabled)
                        {
                            await strategy.StartDetectionAsync(_eventBus, stoppingToken);
                            _logger.LogInformation("Started change detection strategy: {StrategyName} (Priority: {Priority})",
                                strategy.Name, strategy.Priority);
                        }
                        else
                        {
                            _logger.LogInformation("Strategy {StrategyName} is disabled and will not be started",
                                strategy.Name);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error starting strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
                
                // Keep the service running until cancellation is requested
                while (!stoppingToken.IsCancellationRequested)
                {
                    await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
                }
            }
            catch (OperationCanceledException)
            {
                // Normal cancellation, no need to log an error
                _logger.LogInformation("Change Detection Orchestrator was stopped");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled exception in Change Detection Orchestrator: {ErrorMessage}", ex.Message);
                throw;
            }
            finally
            {                // Clean shutdown - stop all strategies
                var strategies = _strategiesFactory();
                foreach (var strategy in strategies)
                {
                    try
                    {
                        if (strategy.IsEnabled)
                        {
                            await strategy.StopDetectionAsync();
                            _logger.LogInformation("Stopped change detection strategy: {StrategyName}", strategy.Name);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error stopping strategy {StrategyName}: {ErrorMessage}",
                            strategy.Name, ex.Message);
                    }
                }
            }
        }
    }
}

```

### NCM3\Services\ChangeDetection\ChangeDetectionStrategy.cs
```cs

```

### NCM3\Services\ChangeDetection\IChangeDetectionStrategy.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using NCM3.Models;
using NCM3.Services.Events;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Interface defining the contract for configuration change detection strategies
    /// </summary>
    public interface IChangeDetectionStrategy
    {
        /// <summary>
        /// Name of the strategy
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// Priority level of this detection strategy (lower number = higher priority)
        /// </summary>
        int Priority { get; }
        
        /// <summary>
        /// Whether this strategy is enabled in the configuration
        /// </summary>
        bool IsEnabled { get; }
        
        /// <summary>
        /// Initialize the strategy with any prerequisites
        /// </summary>
        Task InitializeAsync(CancellationToken stoppingToken = default);
        
        /// <summary>
        /// Start the detection process
        /// </summary>
        /// <param name="eventBus">Event bus to publish change events</param>
        /// <param name="stoppingToken">Cancellation token</param>
        Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default);
        
        /// <summary>
        /// Stop the detection process
        /// </summary>
        Task StopDetectionAsync();
        
        /// <summary>
        /// Check a specific router for changes
        /// </summary>
        /// <param name="router">The router to check</param>
        /// <param name="eventBus">Event bus to publish change events</param>
        /// <returns>True if changes were detected, false otherwise</returns>
        Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus);
    }
}
```

### NCM3\Services\ChangeDetection\SNMPPollingStrategy.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;
using System.Net;
using SnmpSharpNet;
using Microsoft.EntityFrameworkCore;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Uses SNMP polling to detect configuration changes on routers
    /// </summary>
    public class SNMPPollingStrategy : IChangeDetectionStrategy
    {
        private readonly ILogger<SNMPPollingStrategy> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<RouterService> _routerServiceFactory;
        private readonly Func<NCMDbContext> _dbContextFactory;
        private readonly Dictionary<int, DateTime> _lastModifiedTimes = new();
        private System.Timers.Timer? _pollingTimer;
        private IEventBus? _eventBus;
        private CancellationToken _stoppingToken;
        
        public string Name => "SNMP Polling";
        public int Priority => 1; // Higher priority than SSH (lower number = higher priority)
        
        public bool IsEnabled
        {
            get
            {
                return _configuration.GetValue<bool>("ChangeDetection:Strategies:SNMPPolling:Enabled", false);
            }
        }
        
        private int PollingIntervalMinutes
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:IntervalMinutes", 5);
            }
        }
          private string OidConfigLastChanged
        {
            get
            {
                return _configuration.GetValue<string>(
                    "ChangeDetection:Strategies:SNMPPolling:OIDConfigLastChanged", 
                    "1.3.6.1.4.1.9.9.43.1.1.1.0") ?? "1.3.6.1.4.1.9.9.43.1.1.1.0";
            }
        }
        
        private string SnmpCommunity
        {
            get
            {
                return _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Community", "public") ?? "public";
            }
        }
          private string SnmpVersionSetting
        {
            get
            {
                return _configuration.GetValue<string>("ChangeDetection:Strategies:SNMPPolling:Version", "Auto") ?? "Auto";
            }
        }
        
        private int SnmpTimeout
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Timeout", 2000);
            }
        }
        
        private int SnmpRetries
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Retries", 2);
            }
        }
        
        private int SnmpPort
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SNMPPolling:Port", 161);
            }
        }

        public SNMPPollingStrategy(
            ILogger<SNMPPollingStrategy> logger,
            IConfiguration configuration,
            Func<RouterService> routerServiceFactory,
            Func<NCMDbContext> dbContextFactory)
        {
            _logger = logger;
            _configuration = configuration;
            _routerServiceFactory = routerServiceFactory;
            _dbContextFactory = dbContextFactory;
        }
        
        public Task InitializeAsync(CancellationToken stoppingToken = default)
        {
            _stoppingToken = stoppingToken;
            _logger.LogInformation("Initializing SNMP Polling Strategy");
            
            return Task.CompletedTask;
        }
        
        public Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default)
        {
            if (!IsEnabled)
            {
                _logger.LogInformation("SNMP Polling Strategy is disabled, not starting");
                return Task.CompletedTask;
            }
            
            _eventBus = eventBus;
            _stoppingToken = stoppingToken;
            
            _logger.LogInformation("Starting SNMP Polling Strategy with interval of {IntervalMinutes} minutes", 
                PollingIntervalMinutes);
            
            // Setup timer for polling
            _pollingTimer = new System.Timers.Timer(PollingIntervalMinutes * 60 * 1000); // Convert to milliseconds
            _pollingTimer.Elapsed += OnPollingTimerElapsed;
            _pollingTimer.AutoReset = true;
            _pollingTimer.Start();
            
            // Run an initial check immediately
            Task.Run(RunPollingCycle);
            
            return Task.CompletedTask;
        }
        
        public Task StopDetectionAsync()
        {
            _logger.LogInformation("Stopping SNMP Polling Strategy");
            
            _pollingTimer?.Stop();
            _pollingTimer?.Dispose();
            _pollingTimer = null;
            
            return Task.CompletedTask;
        }
        
        private void OnPollingTimerElapsed(object? sender, ElapsedEventArgs e)
        {
            // Don't start a new polling cycle if the previous one is still running
            if (_pollingTask == null || _pollingTask.IsCompleted)
            {
                _pollingTask = RunPollingCycle();
            }
            else
            {
                _logger.LogWarning("Previous SNMP polling cycle still running, skipping this cycle");
            }
        }
        
        private Task? _pollingTask;
        
        private async Task RunPollingCycle()
        {
            try
            {
                _logger.LogDebug("Running SNMP polling cycle");
                
                if (_stoppingToken.IsCancellationRequested)
                {
                    return;
                }
                
                if (_eventBus == null)
                {
                    _logger.LogError("Event bus not set for SNMP Polling Strategy");
                    return;
                }
                
                // Get all routers
                using var dbContext = _dbContextFactory();
                var routers = await dbContext.Routers.ToListAsync();
                
                foreach (var router in routers)
                {
                    if (_stoppingToken.IsCancellationRequested)
                    {
                        break;
                    }
                    
                    if (!router.IsAvailable)
                    {
                        _logger.LogDebug("Skipping unavailable router: {RouterName}", router.Hostname);
                        continue;
                    }
                    
                    try
                    {
                        await CheckForChangesAsync(router, _eventBus);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error checking for changes on router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SNMP polling cycle: {ErrorMessage}", ex.Message);
            }
        }
        
        public async Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus)
        {
            if (!IsEnabled)
            {
                return false;
            }
              _logger.LogDebug("Checking for changes via SNMP on router {RouterName}", router.Hostname);
            
            // Validate IP address
            if (string.IsNullOrWhiteSpace(router.IpAddress))
            {
                _logger.LogWarning("Router {RouterName} has no IP address configured", router.Hostname);
                return false;
            }
            
            try
            {
                // Try to parse the IP address, which may fail if the IP is invalid
                if (!IPAddress.TryParse(router.IpAddress, out IPAddress? ipAddress))
                {
                    _logger.LogWarning("Router {RouterName} has invalid IP address: {IPAddress}", 
                        router.Hostname, router.IpAddress);
                    return false;
                }
                
                var community = new OctetString(SnmpCommunity);
                var param = new AgentParameters(community);
                var target = new UdpTarget(ipAddress, SnmpPort, SnmpTimeout, SnmpRetries);
                
                try
                {
                    // Create Pdu for SNMP GET
                    var pdu = new Pdu(PduType.Get);
                    var oid = new Oid(OidConfigLastChanged);
                    pdu.VbList.Add(oid);
                      // Determine SNMP version to use based on config
                    string snmpVersion = SnmpVersionSetting?.ToLower() ?? "auto";
                    string versionUsed = "";
                    SnmpPacket? result = null;
                    
                    if (snmpVersion == "v1" || snmpVersion == "1")
                    {
                        // Use SNMPv1
                        param.Version = SnmpSharpNet.SnmpVersion.Ver1;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv1";
                    }
                    else if (snmpVersion == "v2" || snmpVersion == "v2c" || snmpVersion == "2")
                    {
                        // Use SNMPv2c
                        param.Version = SnmpSharpNet.SnmpVersion.Ver2;
                        result = target.Request(pdu, param);
                        versionUsed = "SNMPv2c";
                    }
                    else // "auto" or any other value
                    {
                        // Try SNMPv2c first, then fallback to SNMPv1 if it fails
                        try
                        {
                            param.Version = SnmpSharpNet.SnmpVersion.Ver2;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv2c";
                        }
                        catch (Exception ex)
                        {
                            _logger.LogInformation("SNMPv2c request failed for router {RouterName}, falling back to SNMPv1: {ErrorMessage}", 
                                router.Hostname, ex.Message);
                            
                            // Reset PDU for new request
                            pdu = new Pdu(PduType.Get);
                            pdu.VbList.Add(oid);
                            
                            param.Version = SnmpSharpNet.SnmpVersion.Ver1;
                            result = target.Request(pdu, param);
                            versionUsed = "SNMPv1";
                        }
                    }
                    
                    // Process the result based on the actual type returned
                    if (result != null)
                    {
                        string? lastModifiedSnmp = null;
                        bool success = false;
                        
                        if (result is SnmpV2Packet v2Packet && v2Packet.Pdu.ErrorStatus == 0)
                        {
                            foreach (var vb in v2Packet.Pdu.VbList)
                            {
                                if (vb.Oid.ToString() == OidConfigLastChanged)
                                {
                                    lastModifiedSnmp = vb.Value.ToString();
                                    success = true;
                                }
                            }
                        }
                        else if (result is SnmpV1Packet v1Packet && v1Packet.Pdu.ErrorStatus == 0)
                        {
                            foreach (var vb in v1Packet.Pdu.VbList)
                            {
                                if (vb.Oid.ToString() == OidConfigLastChanged)
                                {
                                    lastModifiedSnmp = vb.Value.ToString();
                                    success = true;
                                }
                            }
                        }
                        
                        if (success && lastModifiedSnmp != null)
                        {
                            // The value is in TimeTicks (1/100th seconds since device boot)
                            // We need to convert it to a DateTime
                            if (long.TryParse(lastModifiedSnmp, out long ticks))
                            {
                                // Convert timeticks (in 1/100 seconds) to DateTime
                                var lastModified = DateTime.UtcNow.AddMilliseconds(-(ticks * 10));
                                
                                // Check if we have seen this router before
                                if (_lastModifiedTimes.TryGetValue(router.Id, out var lastRecordedTime))
                                {
                                    if (lastModified > lastRecordedTime)
                                    {
                                        _logger.LogInformation(
                                            "Detected configuration change on router {RouterName} via SNMP ({Version}). " +
                                            "Last modified time: {LastModified}, previous recorded time: {PreviousTime}",
                                            router.Hostname, versionUsed, lastModified, lastRecordedTime);
                                        
                                        // Update last modified time
                                        _lastModifiedTimes[router.Id] = lastModified;
                                        
                                        // Get the current configuration to send the change event
                                        using var routerService = _routerServiceFactory();
                                        var currentConfig = await routerService.GetConfigurationAsync(router);
                                        var lastConfig = router.RouterConfigurations
                                            .OrderByDescending(c => c.BackupDate)
                                            .FirstOrDefault();
                                        
                                        // Only raise event if we have both configs and they're different
                                        if (lastConfig != null && lastConfig.Content != currentConfig)
                                        {
                                            // Determine priority based on config differences
                                            var priority = DeterminePriority(lastConfig.Content, currentConfig);
                                            
                                            var configChangedEvent = new ConfigurationChangedEvent(
                                                router,
                                                lastConfig?.Content ?? string.Empty,
                                                currentConfig,
                                                priority,
                                                Name,
                                                $"Configuration change detected via SNMP polling ({versionUsed})");
                                            
                                            await eventBus.PublishAsync(configChangedEvent);
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // First time seeing this router, just record the time
                                    _lastModifiedTimes[router.Id] = lastModified;
                                    _logger.LogInformation(
                                        "Established baseline SNMP time for router {RouterName} ({Version}): {LastModified}",
                                        router.Hostname, versionUsed, lastModified);
                                }
                            }
                            else if (TryParseUptimeString(lastModifiedSnmp, out var lastModified))
                            {
                                // Check if we have seen this router before
                                if (_lastModifiedTimes.TryGetValue(router.Id, out var lastRecordedTime))
                                {
                                    if (lastModified > lastRecordedTime)
                                    {
                                        _logger.LogInformation(
                                            "Detected configuration change on router {RouterName} via SNMP ({Version}). " +
                                            "Last modified time: {LastModified}, previous recorded time: {PreviousTime}",
                                            router.Hostname, versionUsed, lastModified, lastRecordedTime);
                                        
                                        // Update last modified time
                                        _lastModifiedTimes[router.Id] = lastModified;
                                        
                                        // Get the current configuration to send the change event
                                        using var routerService = _routerServiceFactory();
                                        var currentConfig = await routerService.GetConfigurationAsync(router);
                                        var lastConfig = router.RouterConfigurations
                                            .OrderByDescending(c => c.BackupDate)
                                            .FirstOrDefault();
                                        
                                        // Only raise event if we have both configs and they're different
                                        if (lastConfig != null && lastConfig.Content != currentConfig)
                                        {
                                            // Determine priority based on config differences
                                            var priority = DeterminePriority(lastConfig.Content, currentConfig);
                                            
                                            var configChangedEvent = new ConfigurationChangedEvent(
                                                router,
                                                lastConfig?.Content ?? string.Empty,
                                                currentConfig,
                                                priority,
                                                Name,
                                                $"Configuration change detected via SNMP polling ({versionUsed})");
                                            
                                            await eventBus.PublishAsync(configChangedEvent);
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // First time seeing this router, just record the time
                                    _lastModifiedTimes[router.Id] = lastModified;
                                    _logger.LogInformation(
                                        "Established baseline SNMP time for router {RouterName} ({Version}): {LastModified}",
                                        router.Hostname, versionUsed, lastModified);
                                }
                            }
                            else
                            {
                                _logger.LogWarning("Could not parse SNMP time ticks for router {RouterName}: {Ticks}",
                                    router.Hostname, lastModifiedSnmp);
                            }
                        }
                        else
                        {
                            string errorStatus = "unknown";
                            int errorIndex = -1;
                            
                            if (result is SnmpV2Packet v2P)
                            {
                                errorStatus = v2P.Pdu.ErrorStatus.ToString();
                                errorIndex = v2P.Pdu.ErrorIndex;
                            }
                            else if (result is SnmpV1Packet v1P)
                            {
                                errorStatus = v1P.Pdu.ErrorStatus.ToString();
                                errorIndex = v1P.Pdu.ErrorIndex;
                            }
                            
                            _logger.LogWarning("SNMP GET failed for router {RouterName} using {Version}. Error: {ErrorStatus}, Index: {ErrorIndex}",
                                router.Hostname, versionUsed, errorStatus, errorIndex);
                        }
                    }
                    else
                    {
                        _logger.LogWarning("No SNMP response received from router {RouterName} using {Version}",
                            router.Hostname, versionUsed);
                    }
                }
                finally
                {
                    target.Close();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking SNMP for router {RouterName}: {ErrorMessage}",
                    router.Hostname, ex.Message);
            }
            
            return false;
        }
        
        private string DeterminePriority(string oldConfig, string newConfig)
        {
            // This is a simplified example of priority determination
            // In a real implementation, you would perform more sophisticated analysis
            
            if (ContainsSecurityChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsInterfaceChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsRouteChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            if (ContainsACLChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            return "Low";
        }
        
        private bool ContainsSecurityChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "password", "secret", "key", "enable secret", "crypto", "ssh",
                "authentication", "authorization"
            });
        }
        
        private bool ContainsInterfaceChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "interface", "shutdown", "ip address", "no shutdown", "mtu"
            });
        }
        
        private bool ContainsRouteChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "ip route", "router ospf", "router bgp", "router eigrp", "network"
            });
        }
        
        private bool ContainsACLChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "access-list", "permit", "deny", "ip access-group"
            });
        }
        
        private bool ContainsAnyKeyword(string oldConfig, string newConfig, string[] keywords)
        {
            // Get the diff as a list of line changes
            var diffLines = GetDiffLines(oldConfig, newConfig);
            
            foreach (var line in diffLines)
            {
                foreach (var keyword in keywords)
                {
                    if (line.Contains(keyword, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private List<string> GetDiffLines(string oldConfig, string newConfig)
        {
            // This is a simple diff implementation
            // In a real implementation, you'd use a proper diff algorithm
            var oldLines = oldConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var newLines = newConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            
            var result = new List<string>();
            
            // Just collect lines that are in new but not in old
            foreach (var line in newLines)
            {
                if (!oldLines.Contains(line))
                {
                    result.Add(line);
                }
            }
            
            return result;
        }
        
        private bool TryParseUptimeString(string uptime, out DateTime lastChanged)
        {
            lastChanged = DateTime.MinValue;
            try
            {
                int days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
                var parts = uptime.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                foreach (var part in parts)
                {
                    if (part.EndsWith("d")) int.TryParse(part.TrimEnd('d'), out days);
                    else if (part.EndsWith("h")) int.TryParse(part.TrimEnd('h'), out hours);
                    else if (part.EndsWith("m") && !part.EndsWith("ms")) int.TryParse(part.TrimEnd('m'), out minutes);
                    else if (part.EndsWith("s") && !part.EndsWith("ms")) int.TryParse(part.TrimEnd('s'), out seconds);
                    else if (part.EndsWith("ms")) int.TryParse(part.TrimEnd("ms".ToCharArray()), out milliseconds);
                }
                var span = new TimeSpan(days, hours, minutes, seconds, milliseconds);
                lastChanged = DateTime.UtcNow - span;
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}
```

### NCM3\Services\ChangeDetection\SNMPVerificationService.cs
```cs

```

### NCM3\Services\ChangeDetection\SSHPollingStrategy.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using NCM3.Models;
using NCM3.Services.Events;
using System.Linq;
using Microsoft.EntityFrameworkCore;

namespace NCM3.Services.ChangeDetection
{
    /// <summary>
    /// Uses SSH polling to detect configuration changes on routers with a lower frequency than SNMP polling
    /// </summary>
    public class SSHPollingStrategy : IChangeDetectionStrategy
    {        private readonly ILogger<SSHPollingStrategy> _logger;
        private readonly IConfiguration _configuration;
        private readonly Func<RouterService> _routerServiceFactory;
        private readonly Func<NCMDbContext> _dbContextFactory;
        private readonly Dictionary<int, DateTime> _lastBackupDates = new();
        private readonly Dictionary<int, string> _lastKnownConfigurations = new();
        private System.Timers.Timer? _pollingTimer;
        private IEventBus? _eventBus;
        private CancellationToken _stoppingToken;
        
        public string Name => "SSH Polling";
        public int Priority => 2; // Lower priority than SNMP (higher number = lower priority)
        
        public bool IsEnabled
        {
            get
            {
                return _configuration.GetValue<bool>("ChangeDetection:Strategies:SSHPolling:Enabled", false);
            }
        }
        
        private int PollingIntervalHours
        {
            get
            {
                return _configuration.GetValue<int>("ChangeDetection:Strategies:SSHPolling:IntervalHours", 24);
            }
        }          public SSHPollingStrategy(
            ILogger<SSHPollingStrategy> logger,
            IConfiguration configuration,
            Func<RouterService> routerServiceFactory,
            Func<NCMDbContext> dbContextFactory)
        {
            _logger = logger;
            _configuration = configuration;
            _routerServiceFactory = routerServiceFactory;
            _dbContextFactory = dbContextFactory;
        }
        
        public Task InitializeAsync(CancellationToken stoppingToken = default)
        {
            _stoppingToken = stoppingToken;
            _logger.LogInformation("Initializing SSH Polling Strategy");
            
            return Task.CompletedTask;
        }
        
        public Task StartDetectionAsync(IEventBus eventBus, CancellationToken stoppingToken = default)
        {
            if (!IsEnabled)
            {
                _logger.LogInformation("SSH Polling Strategy is disabled, not starting");
                return Task.CompletedTask;
            }
            
            _eventBus = eventBus;
            _stoppingToken = stoppingToken;
            
            _logger.LogInformation("Starting SSH Polling Strategy with interval of {IntervalHours} hours", 
                PollingIntervalHours);
            
            // Setup timer for polling
            _pollingTimer = new System.Timers.Timer(PollingIntervalHours * 60 * 60 * 1000); // Convert to milliseconds
            _pollingTimer.Elapsed += OnPollingTimerElapsed;
            _pollingTimer.AutoReset = true;
            _pollingTimer.Start();
            
            // Run an initial check immediately
            Task.Run(RunPollingCycle);
            
            return Task.CompletedTask;
        }
        
        public Task StopDetectionAsync()
        {
            _logger.LogInformation("Stopping SSH Polling Strategy");
            
            _pollingTimer?.Stop();
            _pollingTimer?.Dispose();
            _pollingTimer = null;
            
            return Task.CompletedTask;
        }
        
        private void OnPollingTimerElapsed(object? sender, ElapsedEventArgs e)
        {
            // Don't start a new polling cycle if the previous one is still running
            if (_pollingTask == null || _pollingTask.IsCompleted)
            {
                _pollingTask = RunPollingCycle();
            }
            else
            {
                _logger.LogWarning("Previous SSH polling cycle still running, skipping this cycle");
            }
        }
        
        private Task? _pollingTask;
        
        private async Task RunPollingCycle()
        {
            try
            {
                _logger.LogDebug("Running SSH polling cycle");
                
                if (_stoppingToken.IsCancellationRequested)
                {
                    return;
                }
                
                if (_eventBus == null)
                {
                    _logger.LogError("Event bus not set for SSH Polling Strategy");
                    return;
                }                // Get all routers using a scoped DbContext
                using var dbContext = _dbContextFactory();
                var routers = await dbContext.Routers.ToListAsync();
                
                foreach (var router in routers)
                {
                    if (_stoppingToken.IsCancellationRequested)
                    {
                        break;
                    }
                    
                    if (!router.IsAvailable)
                    {
                        _logger.LogDebug("Skipping unavailable router: {RouterName}", router.Hostname);
                        continue;
                    }
                    
                    try
                    {
                        await CheckForChangesAsync(router, _eventBus);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error checking for changes on router {RouterName}: {ErrorMessage}", 
                            router.Hostname, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in SSH polling cycle: {ErrorMessage}", ex.Message);
            }
        }
        
        public async Task<bool> CheckForChangesAsync(Router router, IEventBus eventBus)
        {
            if (!IsEnabled)
            {
                return false;
            }
            
            _logger.LogDebug("Checking for changes via SSH on router {RouterName}", router.Hostname);
            
            try
            {                // Get the current configuration via SSH using a scoped RouterService
                using var routerService = _routerServiceFactory();
                string currentConfig = await routerService.GetConfigurationAsync(router);
                
                // If it's an error message, skip this router
                if (currentConfig.StartsWith("Error:"))
                {
                    _logger.LogWarning("Unable to retrieve configuration from router {RouterName}: {ErrorMessage}",
                        router.Hostname, currentConfig);
                    return false;
                }
                
                // Check if we have seen this router before
                if (_lastKnownConfigurations.TryGetValue(router.Id, out var lastConfig))
                {
                    // If the configuration has changed
                    if (lastConfig != currentConfig)
                    {
                        _logger.LogInformation(
                            "Detected configuration change on router {RouterName} via SSH polling.",
                            router.Hostname);
                        
                        // Update our cached configuration
                        _lastKnownConfigurations[router.Id] = currentConfig;
                        _lastBackupDates[router.Id] = DateTime.UtcNow;
                        
                        // Determine priority based on config differences
                        var priority = DeterminePriority(lastConfig, currentConfig);
                        
                        var configChangedEvent = new ConfigurationChangedEvent(
                            router,
                            lastConfig,
                            currentConfig,
                            priority,
                            Name,
                            "Configuration change detected via SSH polling");
                        
                        await eventBus.PublishAsync(configChangedEvent);
                        return true;
                    }
                }
                else
                {
                    // First time seeing this router or first run
                    _logger.LogInformation("Initial configuration captured for router {RouterName} via SSH", 
                        router.Hostname);
                    
                    _lastKnownConfigurations[router.Id] = currentConfig;
                    _lastBackupDates[router.Id] = DateTime.UtcNow;
                    
                    // Get the latest configuration from the database for comparison
                    var dbConfig = router.RouterConfigurations
                        .OrderByDescending(c => c.BackupDate)
                        .FirstOrDefault();
                        
                    if (dbConfig != null && dbConfig.Content != currentConfig)
                    {
                        _logger.LogInformation(
                            "Detected difference between database configuration and current configuration for router {RouterName}",
                            router.Hostname);
                            
                        // Determine priority based on config differences
                        var priority = DeterminePriority(dbConfig.Content, currentConfig);
                        
                        var configChangedEvent = new ConfigurationChangedEvent(
                            router,
                            dbConfig.Content,
                            currentConfig,
                            priority,
                            Name,
                            "Configuration change detected during initial SSH poll");
                        
                        await eventBus.PublishAsync(configChangedEvent);
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking SSH for router {RouterName}: {ErrorMessage}",
                    router.Hostname, ex.Message);
            }
            
            return false;
        }
        
        private string DeterminePriority(string oldConfig, string newConfig)
        {
            // Use the same priority determination as SNMP strategy for consistency
            if (ContainsSecurityChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsInterfaceChanges(oldConfig, newConfig))
            {
                return "High";
            }
            
            if (ContainsRouteChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            if (ContainsACLChanges(oldConfig, newConfig))
            {
                return "Medium";
            }
            
            return "Low";
        }
        
        private bool ContainsSecurityChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "password", "secret", "key", "enable secret", "crypto", "ssh",
                "authentication", "authorization"
            });
        }
        
        private bool ContainsInterfaceChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "interface", "shutdown", "ip address", "no shutdown", "mtu"
            });
        }
        
        private bool ContainsRouteChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "ip route", "router ospf", "router bgp", "router eigrp", "network"
            });
        }
        
        private bool ContainsACLChanges(string oldConfig, string newConfig)
        {
            return ContainsAnyKeyword(oldConfig, newConfig, new[] {
                "access-list", "permit", "deny", "ip access-group"
            });
        }
        
        private bool ContainsAnyKeyword(string oldConfig, string newConfig, string[] keywords)
        {
            // Get the diff as a list of line changes
            var diffLines = GetDiffLines(oldConfig, newConfig);
            
            foreach (var line in diffLines)
            {
                foreach (var keyword in keywords)
                {
                    if (line.Contains(keyword, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        private List<string> GetDiffLines(string oldConfig, string newConfig)
        {
            // This is a simple diff implementation
            // In a real implementation, you'd use a proper diff algorithm
            var oldLines = oldConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var newLines = newConfig.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            
            var result = new List<string>();
            
            // Just collect lines that are in new but not in old
            foreach (var line in newLines)
            {
                if (!oldLines.Contains(line))
                {
                    result.Add(line);
                }
            }
            
            return result;
        }
    }
}
```

### NCM3\Services\Events\ConfigurationChangedEvent.cs
```cs
using System;
using NCM3.Models;

namespace NCM3.Services.Events
{
    /// <summary>
    /// Event raised when a router's configuration has changed
    /// </summary>
    public class ConfigurationChangedEvent : IEvent
    {
        /// <summary>
        /// When the event occurred
        /// </summary>
        public DateTime Timestamp { get; } = DateTime.UtcNow;
        
        /// <summary>
        /// Unique identifier for the event
        /// </summary>
        public Guid Id { get; } = Guid.NewGuid();
        
        /// <summary>
        /// The router that had its configuration changed
        /// </summary>
        public Router Router { get; }
        
        /// <summary>
        /// The old configuration content
        /// </summary>
        public string OldContent { get; }
        
        /// <summary>
        /// The new configuration content
        /// </summary>
        public string NewContent { get; }
        
        /// <summary>
        /// The priority of this change
        /// </summary>
        public string Priority { get; }
        
        /// <summary>
        /// The strategy that detected the change
        /// </summary>
        public string DetectionStrategy { get; }
        
        /// <summary>
        /// A human-readable description of the change
        /// </summary>
        public string ChangeDescription { get; }
        
        public ConfigurationChangedEvent(
            Router router, 
            string oldContent, 
            string newContent, 
            string priority,
            string detectionStrategy,
            string changeDescription)
        {
            Router = router;
            OldContent = oldContent;
            NewContent = newContent;
            Priority = priority;
            DetectionStrategy = detectionStrategy;
            ChangeDescription = changeDescription;
        }
    }
}
```

### NCM3\Services\Events\EventBus.cs
```cs

```

### NCM3\Services\Events\IEventBus.cs
```cs
using System;
using System.Threading.Tasks;

namespace NCM3.Services.Events
{
    /// <summary>
    /// Base interface for application events
    /// </summary>
    public interface IEvent
    {
        /// <summary>
        /// When the event occurred
        /// </summary>
        DateTime Timestamp { get; }
        
        /// <summary>
        /// Unique identifier for the event
        /// </summary>
        Guid Id { get; }
    }
    
    /// <summary>
    /// The event bus interface
    /// </summary>
    public interface IEventBus
    {
        /// <summary>
        /// Publish an event
        /// </summary>
        Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent;
        
        /// <summary>
        /// Subscribe to events of a specific type
        /// </summary>
        void Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
        
        /// <summary>
        /// Unsubscribe from events of a specific type
        /// </summary>
        void Unsubscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
    }
}
```

### NCM3\Services\Events\InMemoryEventBus.cs
```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace NCM3.Services.Events
{
    /// <summary>
    /// An in-memory implementation of the event bus
    /// </summary>
    public class InMemoryEventBus : IEventBus
    {
        private readonly ILogger<InMemoryEventBus> _logger;
        private readonly ConcurrentDictionary<Type, List<Func<IEvent, Task>>> _handlers = new();

        public InMemoryEventBus(ILogger<InMemoryEventBus> logger)
        {
            _logger = logger;
        }

        /// <summary>
        /// Publish an event to all subscribers
        /// </summary>
        public async Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent
        {
            var eventType = typeof(TEvent);
            _logger.LogDebug("Publishing event of type {EventType} with ID {EventId}", eventType.Name, @event.Id);

            if (!_handlers.TryGetValue(eventType, out var handlers))
            {
                _logger.LogDebug("No handlers registered for event type {EventType}", eventType.Name);
                return;
            }

            var tasks = new List<Task>();
            foreach (var handler in handlers.ToList()) // Create a copy to avoid concurrent modification issues
            {
                try
                {
                    tasks.Add(handler(@event));
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error handling event of type {EventType}: {ErrorMessage}", 
                        eventType.Name, ex.Message);
                }
            }

            // Wait for all handlers to complete
            await Task.WhenAll(tasks);
            _logger.LogDebug("All handlers for event type {EventType} completed", eventType.Name);
        }

        /// <summary>
        /// Subscribe to events of a specific type
        /// </summary>
        public void Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent
        {
            var eventType = typeof(TEvent);
            _logger.LogDebug("Subscribing to event type {EventType}", eventType.Name);

            // Wrap the typed handler in a handler that takes IEvent
            Func<IEvent, Task> wrappedHandler = async (e) => 
            {
                if (e is TEvent typedEvent)
                {
                    await handler(typedEvent);
                }
            };

            _handlers.AddOrUpdate(
                eventType,
                new List<Func<IEvent, Task>> { wrappedHandler },
                (_, existingHandlers) =>
                {
                    existingHandlers.Add(wrappedHandler);
                    return existingHandlers;
                });
        }

        /// <summary>
        /// Unsubscribe from events of a specific type
        /// </summary>
        public void Unsubscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent
        {
            // This is a simplified implementation that doesn't actually remove the handler
            // In a real implementation, we would need to track the wrapped handlers
            _logger.LogWarning("Unsubscribe operation not fully implemented for InMemoryEventBus");
        }
    }
}
```

### NCM3\Validators\ModelValidators.cs
```cs
using System;
using FluentValidation;
using NCM3.Models;

namespace NCM3.Validators
{
    public class RouterValidator : AbstractValidator<Router>
    {
        public RouterValidator()
        {
            RuleFor(x => x.Hostname)
                .NotEmpty().WithMessage("Tên Hostname không được để trống")
                .MaximumLength(100).WithMessage("Tên Hostname không được vượt quá 100 ký tự")
                .Matches("^[a-zA-Z0-9.-]+$").WithMessage("Tên Hostname chỉ được chứa chữ cái, số, dấu chấm và dấu gạch ngang");
                
            RuleFor(x => x.IpAddress)
                .NotEmpty().WithMessage("Địa chỉ IP không được để trống")
                .Matches(@"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                .WithMessage("Địa chỉ IP không hợp lệ");
                
            RuleFor(x => x.Username)
                .NotEmpty().WithMessage("Tên đăng nhập không được để trống")
                .MaximumLength(50).WithMessage("Tên đăng nhập không được vượt quá 50 ký tự");
                
            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("Mật khẩu không được để trống");
        }
    }
    
    public class RouterConfigurationValidator : AbstractValidator<RouterConfiguration>
    {
        public RouterConfigurationValidator()
        {
            RuleFor(x => x.RouterId)
                .GreaterThan(0).WithMessage("RouterId phải lớn hơn 0");
                
            RuleFor(x => x.BackupDate)
                .NotEmpty().WithMessage("Ngày sao lưu không được để trống");
                
            RuleFor(x => x.Content)
                .NotEmpty().WithMessage("Nội dung cấu hình không được để trống");
        }
    }
    
    public class ComplianceRuleValidator : AbstractValidator<ComplianceRule>
    {
        public ComplianceRuleValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("Tên quy tắc không được để trống")
                .MaximumLength(100).WithMessage("Tên quy tắc không được vượt quá 100 ký tự");
                
            RuleFor(x => x.Pattern)
                .NotEmpty().WithMessage("Biểu thức tìm kiếm không được để trống");
        }
    }
    
    public class ConfigTemplateValidator : AbstractValidator<ConfigTemplate>
    {
        public ConfigTemplateValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("Tên template không được để trống")
                .MaximumLength(100).WithMessage("Tên template không được vượt quá 100 ký tự");
                
            RuleFor(x => x.Content)
                .NotEmpty().WithMessage("Nội dung template không được để trống");
        }
    }
}

```

### NCM3\wwwroot\js\site.js
```js
﻿// Please see documentation at https://learn.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.

```

### Tests\MSTestSettings.cs
```cs
﻿[assembly: Parallelize(Scope = ExecutionScope.MethodLevel)]

```

### Tests\SNMPPollingStrategyTests.cs
```cs

```

### Tests\TelegramNotificationServiceTests.cs
```cs
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using Moq.Protected;
using NCM3.Services;
using System.Threading;

namespace NCM3.Tests
{
    [TestClass]
    public class TelegramNotificationServiceTests
    {
        private IConfiguration _config;
        private Mock<ILogger<TelegramNotificationService>> _loggerMock;
        private Mock<HttpMessageHandler> _handlerMock;
        private HttpClient _httpClient;
        private TelegramNotificationService _service;

        [TestInitialize]
        public void Setup()
        {
            var inMemorySettings = new Dictionary<string, string> {
                {"Telegram:BotToken", "test_bot_token"},
                {"Telegram:ChatId", "test_chat_id"},
                {"Telegram:NotificationFormat", "MarkdownV2"},
                {"Telegram:EnableMarkdownFormatting", "true"}
            };

            _config = new ConfigurationBuilder()
                .AddInMemoryCollection(inMemorySettings)
                .Build();

            _loggerMock = new Mock<ILogger<TelegramNotificationService>>();
            _handlerMock = new Mock<HttpMessageHandler>();
            _httpClient = new HttpClient(_handlerMock.Object);

            // Setup handler mock
            _handlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>()
                )
                .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.OK));

            _service = new TelegramNotificationService(_config, _httpClient, _loggerMock.Object);
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithMarkdownV2_ShouldEscapeSpecialCharacters()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "Testing * special _ characters + [ ] ( )";

            // Act
            await _service.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithCodeBlock_ShouldPreserveFormatting()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "```\nThis is a code block\n```";

            // Act
            await _service.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }

        [TestMethod]
        public async Task SendConfigChangeNotification_WithHtmlMode_ShouldConvertToHtmlTags()
        {
            // Arrange
            var routerName = "Router1";
            var changeType = "Test";
            var details = "*bold text* and _italic text_ and ```code block```";

            // Set HTML mode
            var htmlConfig = new ConfigurationBuilder()
                .AddInMemoryCollection(new Dictionary<string, string> {
                    {"Telegram:BotToken", "test_bot_token"},
                    {"Telegram:ChatId", "test_chat_id"},
                    {"Telegram:NotificationFormat", "HTML"},
                    {"Telegram:EnableMarkdownFormatting", "true"}
                })
                .Build();

            var serviceWithHtml = new TelegramNotificationService(htmlConfig, _httpClient, _loggerMock.Object);

            // Act
            await serviceWithHtml.SendConfigChangeNotificationAsync(routerName, changeType, details);

            // Assert
            _handlerMock
                .Protected()
                .Verify<Task<HttpResponseMessage>>(
                    "SendAsync",
                    Times.Once(),
                    ItExpr.Is<HttpRequestMessage>(req => true),
                    ItExpr.IsAny<CancellationToken>()
                );
        }
    }
}

```

### Tests\Test1.cs
```cs
﻿namespace NCM3.Tests;

[TestClass]
public sealed class Test1
{
    [TestMethod]
    public void TestMethod1()
    {
    }
}

```
